<DashboardPluginModel description="Description of New Model 0" name="VIA - Time Range Picker" is_init="false">
  <ModelInfo validated="true">
    <Properties>
    </Properties>
    <Widgets>
      <Widget name="TimeRangePicker" private="false">
        <PropertyText>
          <![CDATA[[{
    "name"  :   "model",
    "label" :   "Model",
    "type"  :   "json",
    "value":    "\"includeTime\": true"
}]]]>
        </PropertyText>
        <CodeText segment="#methods">
          <![CDATA[        
        options: {
			// presetRanges: array of objects; each object describes an item in the presets menu
			// and must have the properties: text, dateStart, dateEnd.
			// dateStart, dateEnd are functions returning a moment object
			presetRanges: [
			    { text: 'Today', value: 'today', offset: 0, units: "hours",  fullDays: true },
			    { text: 'Yesterday', value: 'yesterday', offset: 1, units: "days",  fullDays: true },
			    { text: 'Last 24 Hours', value: '24H', offset: 24, units: "hours",  fullDays: false },
			    { text: 'Last 7 Days', value: '7D', offset: 6, units: "days",  fullDays: true }
				
			],
			dateFormat:         'MM/DD/YYYY', // displayed date format. Available formats: http://api.jqueryui.com/datepicker/#utility-formatDate
			timeFormat:         'HH:mm',
			allowFuture:        false,
			allowPast:          true
        },
        
        resize : function() {
        
            var self = this; 
            if( !window.$ || window.$ === undefined ){
                //require(["/proto/lib/jquery-3.2.1.js"], function() {
                require(["/vitria-oi/rest/app/dbp/user/via_common/dbpm/VIA - JQuery Library?op=vt:dbp:resource:v3.3.1"], function(){
                    $(document).ready(function(){
                        self._loadRequiredLibs();
                    });
                });
            } else {
                $(document).ready(function(){
                    self._loadRequiredLibs();
                });
            }
        
        },
        
        setModel : function(values) {
            alert("setModel()");
        },
        
        getModel : function() {
            //alert("getModel()");
            //alert( this._model );
            return this._model;
            
        },
        _model:         null,
        _fromVal:       null,
        _fromTime:      "00:00",
        _toVal:         null,
        _toTime:        "00:00",
        _action:        "absolute",
        _preset:        "today",
        _initComplete:  false,
        
        _loadRequiredLibs: function(callback){
            var self = this;
            //https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.js

                if( $ !== undefined ){
                            //console.log( "JQuery loaded ");
                            if( $.ui !== undefined ){
                                //console.log( "jquery-ui loaded" );
                                //require(["https://momentjs.com/downloads/moment.js"], function(resp){
                                require(["/vitria-oi/rest/app/dbp/user/via_common/dbpm/VIA - Moment Library?op=vt:dbp:resource:v2.24.0"], function(resp){
                                    window.moment = resp;
                                    if( moment !== undefined ){
                                        //console.log("momentJS loaded");
                                        require(["/vitria-oi/rest/app/dbp/user/via_common/dbpm/VIA - Time Range Picker?op=vt:dbp:resource:timePicker"], function (timepicker) {
                                            if(!$.timepicker) {
                                                $.timepicker = timepicker;
                                            }
                                            //console.log("timepicker loaded");
                                            $("#drPicker").ready(function(){
                                                self._initPicker();
                                                setTimeout(function(){
                                                    self._initComplete = true;
                                                    
                                                    var inp1 = $("#input1").val(); 
                                                    if( inp1 != null && inp1 != "" ){
                                    		            $("#fromPicker").datepicker('setDate', inp1);
                                    		        }
                                    		    
                                    		        var inp2 = $("#input2").val();
                                    		        if( inp2 != null && inp2 != "" ){
                                    		            $("#fromPicker").datepicker('setDate', inp2);
                                    		        }
                                                     
                                                }, 250 );
                                            });
                                        });
                                    }
                                });
                        
                    } else {
                        //require(["https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.js"], function(response) {
                        require(["/vitria-oi/rest/app/dbp/user/via_common/dbpm/VIA - JQuery UI Library?op=vt:dbp:resource:v1.12.1"], function(response){
                            if( $.ui !== undefined ){
                                //console.log( "jquery-ui loaded" );
                                //require(["https://momentjs.com/downloads/moment.js"], function(resp){
                                require(["/vitria-oi/rest/app/dbp/user/via_common/dbpm/VIA - Moment Library?op=vt:dbp:resource:v2.24.0"], function(resp){
                                    window.moment = resp;
                                    if( moment !== undefined ){
                                        //console.log("momentJS loaded");
                                        require(["/vitria-oi/rest/app/dbp/user/via_common/dbpm/VIA - Time Range Picker?op=vt:dbp:resource:timePicker"], function (timepicker) {
                                           if(!$.timepicker) {
                                                $.timepicker = timepicker;
                                            }
                                            //console.log("timepicker loaded");
                                            $("#drPicker").ready(function(){
                                                self._initPicker();
                                                setTimeout(function(){
                                                    self._initComplete = true;
                                                    
                                                    var inp1 = $("#input1").val(); 
                                                    if( inp1 != null && inp1 != "" ){
                                    		            $("#fromPicker").datepicker('setDate', inp1);
                                    		        }
                                    		    
                                    		        var inp2 = $("#input2").val();
                                    		        if( inp2 != null && inp2 != "" ){
                                    		            $("#fromPicker").datepicker('setDate', inp2);
                                    		        } 
		    
                                                }, 250 );
                                            });
                                            
                                        });
                                    }
                                });
                            }
                        });  
                    }
                }
          
        },
        
        _setModel: function(){
            var self = this;
            var _fDate      = moment($("#input1").val()).unix();
            var _fTime      = moment.unix( _fDate ).format( self.options.timeFormat );
            var _tDate      = moment($("#input2").val()).unix();
            var _tTime      = moment.unix( _tDate ).format( self.options.timeFormat );
            if(isNaN(_tDate) && !isNaN(_fDate)){
                _tDate = _fDate;
            }

            _fTime = $("#fromTime").val();
            _tTime = $("#toTime").val();
            
            //alert($("#fromTime").val());
            
            if( self._action == "preset" ){
                self["_model"] = "predefined:" + self["_preset"];
            } else {
                
                if( _fTime && _tTime ){
                    self["_model"]      =  "absolute:" + ( _fDate + self._parseTimeToSeconds(_fTime) ) + "/" + ( _tDate  + self._parseTimeToSeconds(_tTime) ) ;
                } else {
                    self["_model"]      =  "absolute:" + self["_fromVal"] + "/" + self["_toVal"]  ; 
                }
            }
            
            
            if( self.renderer && self.renderer !== null  ){
                self.renderer.updateSelection([ self["_model"] ]);
            }

        },

        _parseTimeToSeconds : function(ts){
            var c_12h   = 43200;
            var c_1h    = 3600;
            var c_1m    = 60;
        
            var suffArr = ts.split(" ");
            var tsObj   = ts;
            var suff    = 0;
            var hr      = 0;
            var mn      = 0;
            var isPM    = false;
        
            if ( suffArr && suffArr.length == 2 ) {
                suff  = ( suffArr[1].toLowerCase() == "pm" ) ? c_12h : 0;
                tsObj = suffArr[0];
            } else {
                suff  = 0;   
            }
        
            var tsArr = tsObj.split(":");
            if( suff == 0 ) {
                suff  = ( tsArr[1].toLowerCase().indexOf( "pm" ) > -1 ) ? c_12h : 0;
                if( suff > 0 ) { 
                    isPM = true; 
                }
            }
            if( tsArr.length == 2 ) {
                if( parseInt( tsArr[0] ) > 12 ){
                    suff = 0;
                }
                if( suffArr && suffArr.length == 2 && parseInt( tsArr[0] ) == 12 ){
                    hr = 0;
                } else {
                    hr = parseInt( tsArr[0] ) * c_1h;
                }
                mn = parseInt( tsArr[1] ) * c_1m;
            }
        
            return ( suff+ hr + mn );
        
        },

        _initPicker: function(){
            var self = this;
            
            if( this._fromVal != null && this._toVal != null ) {
                            
                var tmpFrom     = moment.unix(this._fromVal).format(this.options.dateFormat);
                this._fromTime  = moment.unix( this._fromVal).format( this.options.timeFormat );
                var tmpTo       = moment.unix(this._toVal).format(this.options.dateFormat);
                this._toTime    = moment.unix( this._toVal).format( this.options.timeFormat );
                
                $("#input1").val(tmpFrom);
                $("#input2").val(tmpTo);
                
            }
            
            //console.log("_initPicker");
            
            //self._loadCSS("https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/themes/smoothness/jquery-ui.css");
            self._loadCSS("/vitria-oi/rest/app/dbp/user/via_common/dbpm/VIA - JQuery UI Library?op=vt:dbp:resource:v1.12.1-theme-smoothness");

            $("#fromPicker").datepicker({
    			numberOfMonths: 1,
    			prevText: "Prior Month",
    			nextText: "Following Month",
    			beforeShowDay: function(date) {
    			    
    				 if( $("#input1").val() != "" && $("#input2").val() != "" ){
    				    
    				  //  self["_fromVal"]   = moment($("#input1").val()).unix() ;
    				  //  self["_toVal"]     = moment($("#input2").val()).unix() ;
    				  //  self._setModel();
    				    
    				} 

    				var date1 = $.datepicker.parseDate($.datepicker._defaults.dateFormat, $("#input1").val());
    				var date2 = $.datepicker.parseDate($.datepicker._defaults.dateFormat, $("#input2").val());
    				return [true, date1 && ((date.getTime() == date1.getTime()) || (date2 && date >= date1 && date <= date2)) ? "dp-highlight" : ""];

    			},
    			onSelect: function(dateText, inst) {
                    $("#input1").get(0).setCustomValidity('');
                    $("#input2").get(0).setCustomValidity('');
    				var date1 = $.datepicker.parseDate($.datepicker._defaults.dateFormat, $("#input1").val());
    				var date2 = $.datepicker.parseDate($.datepicker._defaults.dateFormat, $("#input2").val());
        				if (!date1 || date2) {
        					$("#input1").val(dateText);
        					$("#input2").val("");
        					$("#fromTime").val("00:00");
                            $('#fromTime').get(0).setCustomValidity('');
                            $(this).datepicker();
                            $("li.preset.ui-menu-item").removeClass("selected");
        				  //  $("#input2").focus();
        				} else {
        					//$("#input2").val( moment(dateText).add(1,'days').format( self.options.dateFormat ) );
        					$("#input2").val( moment(dateText).add(0,'days').format( self.options.dateFormat ) );
        					$("#toTime").val("00:00");
                            $('#toTime').get(0).setCustomValidity('');
                            $(this).datepicker();
                            self._action = "absolute";
                            self._preset = "";
                            self._setModel();
                            $("li.preset.ui-menu-item").removeClass("selected");
        				}
        				
        				var isOutOfOrder = self._validateRange( $("#input1").val(), $("#input2").val() );
        				if( isOutOfOrder ){
        				    alert("Selected Dates are out of order.\nPlease re-enter begin and end dates...");
        				    self._clearSelection();
        				}
    			 }
    		});  
    	    
    	    if(document.activeElement === $("#input1").get(0))
    	        $("#input1").blur();
    	    //$("#input2").blur();
		
		    $("#clearDateSelection").click(function(){
		        self._clearSelection();
		    });
		    
		    $("#input1").click(function(){
		        var inp1 = $("#input1").val();
		        if( inp1 != null && inp1 != "" ){
		            $("#fromPicker").datepicker('setDate', inp1);
		            $("li.preset.ui-menu-item").removeClass("selected");
		        }
		    });
		    
		    $("#input2").click(function(){
		        var inp2 = $("#input2").val();
		        if( inp2 != null && inp2 != "" ){
		            $("#fromPicker").datepicker('setDate', inp2);  
		            $("li.preset.ui-menu-item").removeClass("selected");
		        }
		    });
		    
            $("#input1").focusout(dateFocusoutHandler);

            $("#input2").focusout(dateFocusoutHandler);
		    
		    self._buildPresetsMenu( self.options.presetRanges, self.options.dateFormat, function(){ return true });
		    
		    self._buildTimePickers();
		    self._setModel();
		    
            function dateFocusoutHandler(){
                try{
                    var from = $.datepicker.parseDate($.datepicker._defaults.dateFormat, $("#input1").val());
                    $("#input1").get(0).setCustomValidity('');
                }catch(e){
                    $("#input1").get(0).setCustomValidity('Invalid form format.');
                }
                try{
                    var to = $.datepicker.parseDate($.datepicker._defaults.dateFormat, $("#input2").val());
                    $("#input2").get(0).setCustomValidity('');
                }catch(e){
                    $("#input2").get(0).setCustomValidity('Invalid to format.');
                }
                if(from != null && to != null && from > to){
                    $("#input1").get(0).setCustomValidity('From should be earlier than to.');
                    $("#input2").get(0).setCustomValidity('From should be earlier than to.');
                }
                self._checkTimeValidity();
                $("#fromPicker").datepicker( "refresh" );
            }

        },
        
        _validateRange: function( date1, date2 ){
            
           var _date1 = $.datepicker.parseDate( $.datepicker._defaults.dateFormat, date1 );
    	   var _date2 = $.datepicker.parseDate( $.datepicker._defaults.dateFormat, date2 );
    	   var outOfOrder = false;
    	   
    	   if( _date1 != null && _date2 != null ){
    	        if( _date1 > _date2 ) outOfOrder = true;   
    	   }
            
            return outOfOrder;
            
        },
        
        _clearSelection: function(){
            this._action = this._originalAction;
            this._preset = this._originalPreset;
            if (this._originalFromVal != null && this._originalToVal != null) {
                this._fromVal = this._originalFromVal;
                this._toVal = this._originalToVal;
            
                var tmpFrom     = moment.unix(this._fromVal).format(this.options.dateFormat);
                this._fromTime  = moment.unix( this._fromVal).format( this.options.timeFormat );
                var tmpTo       = moment.unix(this._toVal).format(this.options.dateFormat);
                this._toTime    = moment.unix( this._toVal).format( this.options.timeFormat );
                $("#fromTime").timepicker('setTime', this._fromTime);
                $("#toTime").timepicker('setTime', this._toTime);
                $("#input1").val(tmpFrom);
                $("#fromPicker").datepicker('setDate', tmpFrom);
                $("#input2").val(tmpTo);
                $("#fromPicker").datepicker('setDate', tmpTo);
                this._setModel();
            } else {
                $("#input1").val("");
                $("#input2").val("");
                this["_fromVal"] = null;
                this["_toVal"]   = null;
                $(".dp-highlight").removeClass("dp-highlight");
                $("#fromPicker").datepicker('setDate', null );
            }
            $('#input1').get(0).setCustomValidity('');
            $('#input2').get(0).setCustomValidity('');
            $('#fromTime').get(0).setCustomValidity('');
            $('#toTime').get(0).setCustomValidity('');
        },
        
        _buildTimePickers: function() {
            var self = this;
            var lwidth      = $("#input1").width();
            var rwidth      = $("#input2").width();
            
            $( ".fromTime").width(lwidth + 5);
            $( ".toTime").width(rwidth + 5);
            
            self._initTimePickers( self._fromTime, self._toTime  ); 
        },
        
        _initTimePickers: function( ftime, ttime){
            var self  = this;
            if($.timepicker) {
                    $("#fromTime").timepicker({
                        'minTime': '00:00', 
                        'maxTime': '24:00',
                        'forceRoundTime': true,
                        'timeFormat': 'H:i',
                        'setTime': ftime,
                        'step': 5
                    });
                    $("#fromTime").timepicker('setTime', ftime );
                    
                    
                    $("#fromTime").on('changeTime', function() {
                        if( self._initComplete == true ){
                            this.setCustomValidity('');
                            if(self._checkTimeValidity() == false) return;
                        	self._fromTime = $(this).val();
                        	self._action = "absolute";
                        	self._preset = "";
                        	self._setModel();
                        }
                    
                    });
                    
                    $("#toTime").timepicker({ 
                        'minTime': '00:00', 
                        'maxTime': '24:00',
                        'forceRoundTime': true,
                        'timeFormat': 'H:i',
                        'setTime': ttime,
                        'step': 5
                    });
                    $("#toTime").timepicker('setTime', ttime );
                    
                    $("#toTime").on('changeTime', function() {
                        if( self._initComplete == true ){
                            this.setCustomValidity('');
                            if(self._checkTimeValidity() == false) return;
                        	self._toTime = $(this).val();
                        	self._action = "absolute";
                        	self._preset = "";
                            self._setModel();
                        }
                    });

                    $('#fromTime, #toTime').on('timeFormatError', function(evt) {
                        evt.target.setCustomValidity('Invalid time format.');
                    });
            } else {
                console.error("plugin not loaded");
            }
        },

        _checkTimeValidity : function(){
            if($('#fromTime').get(0).validationMessage != 'Invalid time format.')
                var fromTime = this._parseTimeToSeconds($('#fromTime').val());   
            if($('#toTime').get(0).validationMessage != 'Invalid time format.')
                var toTime = this._parseTimeToSeconds($('#toTime').val());    
            var from = $.datepicker.parseDate($.datepicker._defaults.dateFormat, $("#input1").val());
            var to = $.datepicker.parseDate($.datepicker._defaults.dateFormat, $("#input2").val()); 
            if(from && to && from.getTime() == to.getTime() && fromTime > toTime){
                $('#fromTime').get(0).setCustomValidity('From time should be earlier than to time.');
                $('#toTime').get(0).setCustomValidity('From time should be earlier than to time.');
            }else{
                if(isFinite(fromTime)) $('#fromTime').get(0).setCustomValidity('');
                if(isFinite(toTime)) $('#toTime').get(0).setCustomValidity('');
                if(isFinite(fromTime) && isFinite(toTime)) return true;
            }
            return false;
        },

        _buildPresetsMenu: function ( presetRanges, dateFormat, onClick) {
            var self = this;
            
    		var $self,
    			$menu,
    			$heading;
        
    		function init() {
    			$self = $('.presetList');
    			$self.empty();
                
                $heading = $('<div>Predefined Ranges</div>')
                $heading.addClass('header-predefined');
                $self.append($heading);
                
    			$menu = $('<ul></ul>');
    
    			$.each( presetRanges, function() {
    				var li = $('<li class="preset"><a href="#">' + this.text + '</a></li>');
                    var _dateStart, _dateEnd, _timeStart, _timeEnd;
                    
                    switch( this.value ){
                        case 'today':
                            _dateStart  = moment().startOf('day');
    				        // _dateEnd    = moment().add(1, 'days').startOf('day');
    				        _dateEnd    = moment().add(0, 'days').endOf('day').subtract(5, 'minutes');
                            break;
                        case 'yesterday':
                            _dateStart  = moment().subtract(this.offset, this.units).startOf('day');
    				        //_dateEnd    = moment().startOf('day');
                            _dateEnd    = moment().subtract(this.offset, this.units).endOf('day').subtract(5, 'minutes');;
                            break;
                        default:
                            if( this.fullDays == true ){
                                _dateStart  = moment().subtract(this.offset, this.units).startOf('day');
                                //_dateEnd    = moment().add(1, 'days').startOf('day');
                                _dateEnd    = moment().endOf('day').subtract(5,'minutes');;
                            } else {
                                _dateStart  = moment().subtract(this.offset, this.units);
                                _dateEnd    = moment();
                            }
                            break;
                    }
                      
                        
                    li.attr('data-startdate', moment( _dateStart ).format(dateFormat) );
    			    li.attr('data-starttime', moment( _dateStart ).format(self.options.timeFormat) );
    			    li.attr('data-enddate',   moment( _dateEnd ).format(dateFormat) );
    			    li.attr('data-endtime', moment( _dateEnd ).format(self.options.timeFormat) );
    			    li.attr('data-presetValue', this.value );
    			    li.attr('data-fulldays',  this.fullDays );
				    li.click(function(){
				        
				        $("li.preset.ui-menu-item").removeClass("selected");
				        $(this).addClass("selected");
				        
				        $("#input1").val( $(this).attr("data-startdate") );
				        $("#input2").val( $(this).attr("data-enddate") );
				        $("#fromTime").timepicker('setTime', $(this).attr("data-starttime") );
				        $("#toTime").timepicker('setTime', $(this).attr("data-endtime") );
				        //$(this) toggle selected and toggle others off... Set selected ass css class.
				        $("#fromPicker").datepicker( "refresh" );
				        $("#input1").blur();
				        $("#input2").blur();
				        self._action = "preset";
				        self._preset = $(this).attr("data-presetValue");
				        self._setModel();
				        
				        
                        var inp1 = $("#input1").val(); 
                        if( inp1 != null && inp1 != "" ){
        		            $("#fromPicker").datepicker('setDate', inp1);
        		        }
        		    
        		        var inp2 = $("#input2").val();
        		        if( inp2 != null && inp2 != "" ){
        		            $("#fromPicker").datepicker('setDate', inp2);
        		        }
				        
                        $('#fromTime').get(0).setCustomValidity('');
                        $('#toTime').get(0).setCustomValidity('');
				    })
				    
				    if( self._action == "preset" && this.value == self._preset ){
				        self._originalFromVal = _dateStart.valueOf()/1000;
				        self._originalToVal = _dateEnd.valueOf()/1000;
						li.addClass("selected");
						$("#input1").val( li.attr("data-startdate") );
				        $("#input2").val( li.attr("data-enddate") );
				        
				        $("#fromTime").timepicker('setTime', li.attr("data-starttime") );
				        self._fromTime  = $("#fromTime").val();
				        
				        $("#toTime").timepicker('setTime', li.attr("data-endtime") );
				        self._toTime    = $("#toTime").val();
				        
				        //$("#fromPicker").datepicker( "refresh" );
				        //$("#input1").blur();
				        //$("#input2").blur();
				        self._action = "preset";
				        self._preset = li.attr("data-presetValue");
				        self._setModel();
				        
				        
                        var inp1 = $("#input1").val(); 
                        if( inp1 != null && inp1 != "" ){
        		            $("#fromPicker").datepicker('setDate', inp1);
        		        }
        		    
        		        var inp2 = $("#input2").val();
        		        if( inp2 != null && inp2 != "" ){
        		            $("#fromPicker").datepicker('setDate', inp2);
        		        }
                                		        
					}
				    
				    li.appendTo($menu);
    				    
    			});
    
    			$self.append($menu);
    
    			$menu.menu()
    				.data('ui-menu').delay = 0; // disable submenu delays
    		}
    
    		init();
    		return {
    			getElement: function() { return $self; }
    		};
    	},
        
        _loadCSS: function(href) {
          var cssLink = $("<link>");
          $("head").append(cssLink); //IE hack: append before setting href
    
            cssLink.attr({
                rel:  "stylesheet",
                type: "text/css",
                href: href
            });
        },
        
        _updateSelection: function(){
            alert('update selection');
            var fDate   = null;
            var fTime   = null;
            var tDate   = null;
            var tTime   = null;
         // _self.renderer.updateSelection([_dtObj]);  
        },
        
        newInstance: function (clazz, arguments, scope) {
        	  return new (Function.prototype.bind.apply(clazz, [scope].concat(arguments)));
        },
        
        getCurrentUnixTime: function () {
            var dt = new Date();
            return Math.floor(dt.getTime() / 1000);
        },
        

        "$getValueAsString" : function(_val, _dim) {
            var self = this;
            var value = null;
            var prefix = null;
            
            if( _val.indexOf(":") > 0 ){
                prefix = _val.split(":")[0];
                value = _val.split(":")[1];
            } else {
                value = _val;   
            }
            
            if( prefix == "predefined"){
                if (_dim != null && _dim.dialog != null && _dim.dialog.widget != null && _dim.dialog.widget.config != null) {
                    if (_dim.dialog.widget.config.predefined != null && Array.isArray(_dim.dialog.widget.config.predefined)) {
                        for (var i=0; i<_dim.dialog.widget.config.predefined.length; i++) {
                            if (_dim.dialog.widget.config.predefined[i]["value"] == value) {
                                return _dim.dialog.widget.config.predefined[i]["label"] || value;
                            }
                        }
                    }
                }
                return value;   
            } 
            
            if (value != null && value != "" && value.indexOf("/") != -1) {
                var toks = value.split("/");
                var dt0 = new Date(Number(toks[0]) * 1000);
                var dt1 = new Date(Number(toks[1]) * 1000);
                var date0 = processDatetoLocaleString( dt0 );
                var date1 = processDatetoLocaleString( dt1 );

                return date0 + " to " + date1;
            } else if ( Array.isArray(value) && value.length == 2) {
                var dt0 = processDatetoLocaleString( parseDateValue( value[0] ) );
                var dt1 = processDatetoLocaleString( parseDateValue( value[1] ) );
                return dt0 + " to " + dt1;
               
                
            } else {
                return null;
            }
            
            function processDatetoLocaleString(dt){
                var dt0 = dt.toLocaleDateString(); 
                // var date0 = dt0.substring(0, 10) + " " + padZeros((new Date(Number(dt) * 1000)).getHours()) + ":" + padZeros((new Date(Number(dt) * 1000)).getMinutes());
                var date0 = dt0.substring(0, 10) + " " + padZeros( new Date(Number(dt) ).getHours() ) + ":" + padZeros( new Date(Number(dt) ).getMinutes() );
                return date0;
            }
            
            function padZeros(input){
                var output = input;
                if( input < 10 ){
                    output = "0" + input;   
                }
                return output;
            }
            
            function newInstance(clazz, arguments, scope) {
            	  return new (Function.prototype.bind.apply(clazz, [scope].concat(arguments)));
            }
            
            function getCurrentUnixTime() {
                var dt = new Date();
                return Math.floor(dt.getTime() / 1000);
            }
            
            function parseDateValue(value) {
                
                    if (Array.isArray(value)) {
                        // applies to this form, but specified as an array of numbers, eg. [99, 5, 24, 11, 33, 30, 0]
                        // var d = new Date(99, 5, 24, 11, 33, 30, 0);
                        value = newInstance(Date, value);
                    }
                    else if (typeof value == "string") {
                        if (value.toLowerCase() == "now") {
                            // get current time (to seconds)
                            value = new Date(getCurrentUnixTime() * 1000);
                        }
                        else if (value.charAt(0) == "+") {
                            // number of seconds after now (in the future)
                            var delta = Number(value.substring(1));
                            if (!isNaN(delta)) {
                                var unixTime = getCurrentUnixTime() + delta;
                                value = new Date(unixTime * 1000);
                            }
                        }
                        else if (value.charAt(0) == "-") {
                            // number of seconds before now (in the past)
                            var delta = Number(value.substring(1));
                            if (!isNaN(delta)) {
                                var unixTime = getCurrentUnixTime() - delta;
                                value = new Date(unixTime * 1000);
                            }
                        }
                        else if (value.indexOf("now+") == 0) {
                            // number of seconds after now (in the future)
                            var delta = Number(value.substring(4));
                            if (!isNaN(delta)) {
                                var unixTime = getCurrentUnixTime() + delta;
                                value = new Date(unixTime * 1000);
                            }
                        }
                        else if (value.indexOf("now-") == 0) {
                            // number of seconds before now (in the past)
                            var delta = Number(value.substring(4));
                            if (!isNaN(delta)) {
                                var unixTime = getCurrentUnixTime() - delta;
                                value = new Date(unixTime * 1000);
                            }
                        }
                        else if (value.toLowerCase() == "today") {
                            // get time (to start of today)
                            value = new Date(getCurrentUnixTime() * 1000);
                            value.setHours(0, 0, 0);
                        }
                        else if (value.indexOf("today+") == 0) {
                            // number of days (24 hours) after start of today (in the future)
                            // not sure if this works when it crosses daylight saving transition...
                            // appears to work... but should do more tests
                            var delta = Number(value.substring(6));
                            if (!isNaN(delta)) {
                                value = new Date(getCurrentUnixTime() * 1000);
                                value.setHours(0, 0, 0);
                                value.setDate(value.getDate() + delta);
                            }
                        }
                        else if (value.indexOf("today-") == 0) {
                            // number of days (24 hours) after start of today (in the past)
                            // not sure if this works when it crosses daylight saving transition...
                            // appears to work... but should do more tests
                            var delta = Number(value.substring(6));
                            if (!isNaN(delta)) {
                                value = new Date(getCurrentUnixTime() * 1000);
                                value.setHours(0, 0, 0);
                                value.setDate(value.getDate() - delta);
                            }
                        }
                        else if (!isNaN(Number(value))) {
                            // unixtime
                            value = new Date(Number(value)*1000);
                        }
                        else {
                            // applies to this form
                            // var d = new Date("October 13, 2014 11:13:00");
                            value = new Date(value);
                        }
                    }
                    else if (typeof value == "number") {
                        // applies to this form, but in UNIXTIME (secs)
                        // var d = new Date(86400000);
                        value = new Date(value * 1000);
                    }
                    return value;
                }
        
        },
        
        
]]>
        </CodeText>
        <CodeText segment="#postCreate">
          <![CDATA[            var self = this; 
            if( !window.$ || window.$ === undefined ){
                //require(["/proto/lib/jquery-3.2.1.js"], function() {
                require(["/vitria-oi/rest/app/dbp/user/via_common/dbpm/VIA - JQuery Library?op=vt:dbp:resource:v3.3.1"], function(){
                    $(document).ready(function(){
                        self._loadRequiredLibs();
                    });
                });
            } else {
                $(document).ready(function(){
                    self._loadRequiredLibs();
                });
            }
           ]]>
        </CodeText>
        <CodeText segment="#constructor">
          <![CDATA[            var self = this;
            var predefs = [];
            var value = null;

            if(  self.editorConfig && self.editorConfig.predefined && self.editorConfig.predefined.length > 0 ){
                predefs = self.editorConfig.predefined;
                self.options.presetRanges = [];
                for( var p=0; p < predefs.length; p++ ){
                    var obj = predefs[p];
                    var pObj = null;
                    if( obj.value == "today"){
                      pObj = { text: 'Today', value: obj.value, offset: 0, units: "hours",  fullDays: true };
                    } else if ( obj.value == "yesterday") {
                      pObj = { text: 'Yesterday', value: obj.value, offset: 1, units: "days",  fullDays: true };
                    } else if ( obj.value.indexOf("H") > 0 ){
                        var offset = obj.value.split("H")[0];
                      pObj = { text: obj.label, value: obj.value, offset: offset, units: "hours",  fullDays: false };
                    } else if ( obj.value.indexOf("D") > 0 ){
                        var offset = obj.value.split("D")[0]-1;
                        pObj = { text: obj.label, value: obj.value, offset: offset, units: "days",  fullDays: true };
                    } else if ( obj.value.indexOf("M") > 0 ){
                        var offset = obj.value.split("M")[0]-1;
                        pObj = { text: obj.label, value: obj.value, offset: offset, units: "months",  fullDays: true };
                    } else if ( obj.value.indexOf("W") > 0 ){
                        var offset = obj.value.split("W")[0]-1;
                        pObj = { text: obj.label, value: obj.value, offset: offset, units: "weeks",  fullDays: true };
                    } else if ( obj.value.indexOf("Y") > 0 ){
                        var offset = obj.value.split("Y")[0]-1;
                        pObj = { text: obj.label, value: obj.value, offset: offset, units: "years",  fullDays: true };
                    } else if ( obj.value.indexOf("Q") > 0 ){
                        var offset = obj.value.split("Q")[0]-1;
                        pObj = { text: obj.label, value: obj.value, offset: offset, units: "quarters",  fullDays: true };
                    }
                    if( pObj != null ){
                        self.options.presetRanges.push(pObj);
                    }
                }
            }   
    
            var valIn = null;
            if( self.initialConfig.model){
                if(Array.isArray(self.initialConfig.model) && self.initialConfig.model.length == 2){
                    var v1 = newInstance(Date, self.initialConfig.model[0]).getTime() / 1000;
                    var v2 = newInstance(Date, self.initialConfig.model[1]).getTime() / 1000;
                    valIn = v1 + "/" + v2;
                } else if( self.initialConfig.model.indexOf(":") > 0 ){
                    var prefix  = self.initialConfig.model.split(":")[0];
                    var valIn   = self.initialConfig.model.split(":")[1];

                    if( prefix == "predefined"){
                         self["_action"] = "preset";
                         self["_preset"] = valIn;
                         
                    } else if ( prefix == "absolute" ) {
                        self["_action"] = "absolute";
                        self["_preset"] = null;
                    }
                    
                } else {
                    valIn = self.initialConfig.model;
                }
            }
            value = valIn;
            
            if (value != null && value != "") {
               
               if( value.indexOf("/") > -1 ){
                var toks = value.split("/");
                self._fromVal = parseInt(toks[0]);
                self._toVal = parseInt(toks[1]);
               } else if ( Array.isArray(value) && value.length == 2 ){
                   var dt0 = parseInt( value[0] );
                   var dt1 = parseInt( value[1] );
                   self._fromVal = dt0;
                   self._toVal   = dt1;

                   
               }
            } else {
               self._fromVal = ( ( Date.now() - 86400000 ) / 1000 ) ;
               self._toVal = ( Date.now() / 1000 ); 
            }
            
            self._originalFromVal = self._fromVal;
            self._originalToVal = self._toVal;
            self._originalAction = self._action;
            self._originalPreset = self._preset;
            
            function newInstance(clazz, arguments, scope) {
            	  return new (Function.prototype.bind.apply(clazz, [scope].concat(arguments)));
            }
            ]]>
        </CodeText>
        <CodeText segment="#onNotify">
          <![CDATA[            var self = this;
            if( evt != null && evt.length > 0 ){
                for( var a=0; a < evt.length; a++ ){
                    if( evt[a]["__TYPE__"] == "filter"){
                        var edata = evt[a]["__EVENT__"].data;
                        if( edata != null && edata.length > 0 ){
                            var trObj = null;
                            for( var i=0; i < edata.length; i++ ){
                                if( edata[i]["name"] == "data.timeRange") {
                                    trObj = edata[i];
                                }
                            }
                            if( trObj != null && ( trObj.value && trObj.value != null ) ){
                               //var value = trObj.value;
                               
                               
                               
                               var valIn = null;
                                if( trObj.value){
                                    if( trObj.value.indexOf(":") > 0 ){
                                        var prefix  = trObj.value.split(":")[0];
                                        var valIn   = trObj.value.split(":")[1];
                    
                                        if( prefix == "predefined"){
                                             self["_action"] = "preset";
                                             self["_preset"] = valIn;
                                             
                                        } else if ( prefix == "absolute" ) {
                                            self["_action"] = "absolute";
                                            self["_preset"] = null;
                                        }
                                        
                                        self._originalAction = self._action;
                                        self._originalPreset = self._preset;
                                    } else {
                                        valIn = trObj.value;
                                    }
                                }
                                value = valIn;
                               
                               
                               if( value.indexOf("/") > -1 ){
                                    var toks = value.split("/");
                                    this._fromVal = parseInt(toks[0]);
                                    this._toVal = parseInt(toks[1]);
                                    
                               } else if ( Array.isArray(value) && value.length == 2 ){
                                   //var dt0 = this.parseDateValue( value[0] ).getTime()/1000;
                                   //var dt1 = this.parseDateValue( value[1] ).getTime()/1000;
                                   var dt0 = moment( value[0] ).unix();
                                   var dt1 = moment( value[1] ).unix();
                                   this._fromVal = dt0;
                                   this._toVal   = dt1;
                                   
                               }
                               
                               if( this._fromVal != null && this._toVal != null ){
                                    this._originalFromVal = this._fromVal;
                                    this._originalToVal = this._toVal;
                               		if( window.moment !== undefined ){
                                    	updatePicker( this._fromVal, this._toVal );
                               		}   
                               }
                            }
                        }
                    } else if( evt[a]["__TYPE__"] == "config") {
                        var cdata = evt[a]["__EVENT__"].data;
                        if( cdata && cdata !== null && cdata.predefined != null && cdata.predefined.length > 0  ){
                            self.options.presetRanges = [];
                            for( var c=0; c < cdata.predefined.length; c++ ){
                                var obj = cdata.predefined[c];
                                var pObj = null;
                                if( obj.value == "today"){
                                  pObj = { text: 'Today', value: obj.value, offset: 0, units: "hours",  fullDays: true };
                                } else if ( obj.value == "yesterday") {
                                  pObj = { text: 'Yesterday', value: obj.value, offset: 1, units: "days",  fullDays: true };
                                } else if ( obj.value.indexOf("H") > 0 ){
                                    var offset = obj.value.split("H")[0];
                                  pObj = { text: obj.label, value: obj.value, offset: offset, units: "hours",  fullDays: false };
                                } else if ( obj.value.indexOf("D") > 0 ){
                                    var offset = obj.value.split("D")[0]-1;
                                    pObj = { text: obj.label, value: obj.value, offset: offset, units: "days",  fullDays: true };
                                }
                                if( pObj != null ){
                                    self.options.presetRanges.push(pObj);
                                }
                            }
                            
                            if( self.options.presetRanges && self.options.presetRanges.length > 0 ){
                                //require(["https://momentjs.com/downloads/moment.js"], function(resp){
                                require(["/vitria-oi/rest/app/dbp/user/via_common/dbpm/VIA - Moment Library?op=vt:dbp:resource:v2.24.0"], function(resp){
                                    window.moment = resp;
                                    if( moment !== undefined ){
                                        setTimeout( function(){
                                        	if( this.action && this.action !== null ) self._action = this.action;
                                        	if( this.preset && this.preset !== null ) self._preset = this.preset;
											self._buildPresetsMenu( self.options.presetRanges, self.options.dateFormat, function(){ return true });

                                        }.bind(this), 1500 );
                                    }
                                 }.bind( { action: self._action, preset: self._preset } ) );
                                   
                            }
                        }
                    }
                }
            }
            
            function updatePicker( fval, tval ){
                    
                        var datastartdate = moment.unix(fval).format(self.options.dateFormat) ;
        			    var dataenddate   = moment.unix(tval).format(self.options.dateFormat) ;
        			    $("#input1").val( datastartdate );
    				    $("#input2").val( dataenddate );
        			    $("#fromTime").timepicker('setTime', moment.unix(fval).format( self.options.timeFormat ) );
    				    $("#toTime").timepicker('setTime', moment.unix(tval).format( self.options.timeFormat ) );
        			    $("#fromPicker").datepicker( "refresh" );
    				    $("#input1").blur();
    				    $("#input2").blur();
    				    self._action = "absolute";
    				    self._preset = "";
    				    self._setModel();
    				    
    				    var inp1 = $("#input1").val();
        		        if( inp1 != null && inp1 != "" ){
        		            $("#fromPicker").datepicker('setDate', inp1);   
        		        }
    				   
            }
            ]]>
        </CodeText>
        <HtmlText>
          <![CDATA[<div class="pickerContainer">
    <div id="timeRangePicker" class="timeRangePicker">
    
    <style>
    
    /*!
     * Copyright (c) 2017 Tamble, Inc.
     * Licensed under MIT (https://github.com/tamble/jquery-ui-daterangepicker/raw/master/LICENSE.txt)
     */

    .appDialogCenter .appDialogContent .dijitContentPane.contentDiv {
        background-color: white !important;
    }
    
    .pickerContainer {
        width: 100%;
        height: 100%;
        background-color: #f5f5f5;
    }
    
    .timeRangePicker {
        position: absolute;
        padding: 10px;
        /* padding-left: 15px; */
        width: 485px;
        height: 250px !important;
        background-color: #ffffff;
    }
    
    
    .timeRangePicker .ui-state-default, .ui-widget-content .ui-state-default,
    .timeRangePicker .ui-datepicker-header.ui-widget-header.ui-helper-clearfix.ui-corner-all {
        background: none;
        background-color: rgba(20,138,196,.1);
        border-color: rgba(20,138,196,.2);
        border-radius: 4px;
    }
    
    .timeRangePicker .ui-state-highlight, 
    .ui-widget-content .ui-state-highlight {
            border: 1px solid #fcefa1;
            background: #fbf9ee url(images/ui-bg_glass_55_fbf9ee_1x400.png) 50% 50% repeat-x;
            color: #363636;
    }
    
    .drPicker{
        display: block;
    }
    
    .timeRangePicker .presetList {
        display: inline-block;
        width: 175px;
        height: 100%;
        background-color: #fff;
        padding: 0 0 0 5px;
        border-right: 1px solid #148ac4;
    }
    
    .header-predefined {
        line-height: 19px;
        font-weight: bold;
        PADDING-LEFT: 5PX;
        border-bottom: 1px solid #148ac4;
        margin-bottom: 5px;
        margin-right: 10px;
    }
    
    .timeRangePicker .pickerWidget {
        float: right;  
        width: 300px;
    }
    
    .timeRangePicker .buttonbar {
        width: auto;
        height: 20px;
        background-color: transparent;
        position: absolute;
        right: 10px;
        bottom: 10px;
    }
    
    .timeRangePicker .buttonbar #clearDateSelection {
        height: 100%;
        float: right;
        border: none;
        color: #148ac4;
        background-color: white;
        font-family: Arial;
        font-size: 12px;
        border-radius: 10px;
        cursor: pointer;
    }
    
    
    .timeRangePicker a.ui-datepicker-next-hover.ui-corner-all,
    .timeRangePicker a.ui-datepicker-prev-hover.ui-corner-all,
    .timeRangePicker a.ui-datepicker-next.ui-corner-all:hover,
    .timeRangePicker a.ui-datepicker-prev.ui-corner-all:hover {
        border: 1px solid transparent;
        background: none;
        background-color: rgba(20,138,196,.4) !important;   
    }
    
    .timeRangePicker .buttonbar #clearDateSelection:hover {
        color: #ffffff;
        background-color: #148ac4;
    }
    
    .ui-datepicker-inline.ui-datepicker.ui-widget {
        padding-left: 42px;
        width: 250px;
    }
    
    .ui-widget.ui-widget-content {
        width: 100%;
        border: none;
    }
    
    li.ui-menu-item {
        height: 20px;
        font-face: Arial;
        font-size: 11px;
    }
    
    .dp-highlight .ui-state-default {
        background: #148ac4;
        color: #FFF;
    }
    
    .ui-menu .ui-menu-item-wrapper {
        position: relative;
        padding: 0px 1em 3px .4em;
    }
    
    li.ui-menu-item A {
        color: #148ac4;   
    }
    
    li.ui-menu-item:hover {
        background-color: rgba(20,138,196,.35);
        color: #000000;
        box-shadow: none;
        border: none;
    }
    
    li.ui-menu-item.selected {
        background-color: rgba(20,138,196,.9);
        color: #ffffff;
    }
    
    li.ui-menu-item.selected A {
        color: white;
        background: transparent;
    } 
    
    li.ui-menu-item:hover A {
        color: #000000;
        background: transparent;
        box-shadow: none;
        border: none;
    }   
    
    .ui-state-active A {
        background: transparent;
    }
    
    .ui-datepicker.ui-datepicker-multi  {
      width: 100% !important;
    }
    
    .ui-datepicker-multi .ui-datepicker-group {
        float:none;
    }
    
    .timeRangePicker INPUT[type="text"] {
        border: none;
        text-align: center;
        border-bottom: 1px solid #148ac4;
        margin-left: 5px;
        color: #148ac4;
        margin-right: -4px;
        cursor: pointer;
        font-size: 12px !important;
        width: 105px;
    }
    
    .timeRangePicker INPUT[type="text"]:focus {
        font-weight: bold;
    }
    
    .timeRangePicker .timeLayer {
        width: 100%;
        height: 22px;
        text-align: right;
    }
    
    .timeRangePicker .fromTime {
        margin-right: 27px;   
    }
    
    .timeRangePicker .toTime {
        margin-right: 2px;   
    }
    
    .timeRangePicker .fromTime, 
    .timeRangePicker .toTime {
        width: 50%;
        height: 100%;
        display: inline-block;
        
    }
    
    .timeRangePicker .timeInput {
        width: 100%;
        display: inline-flex;
        text-align: center;
        border: none;
        color: #148ac4;
        cursor: pointer;
        font-size: 12px !important;
        
    }
    
.ui-timepicker-wrapper {
	overflow-y: auto;
	max-height: 150px;
	width: 6.5em;
	background: #fff;
	border: 1px solid #ddd;
	-webkit-box-shadow:0 5px 10px rgba(0,0,0,0.2);
	-moz-box-shadow:0 5px 10px rgba(0,0,0,0.2);
	box-shadow:0 5px 10px rgba(0,0,0,0.2);
	outline: none;
	z-index: 10052;
	margin: 0;
}

.ui-timepicker-wrapper.ui-timepicker-with-duration {
	width: 13em;
}

.ui-timepicker-wrapper.ui-timepicker-with-duration.ui-timepicker-step-30,
.ui-timepicker-wrapper.ui-timepicker-with-duration.ui-timepicker-step-60 {
	width: 11em;
}

.ui-timepicker-list {
	margin: 0;
	padding: 0;
	list-style: none;
}

.ui-timepicker-duration {
	margin-left: 5px; color: #888;
}

.ui-timepicker-list:hover .ui-timepicker-duration {
	color: #888;
}

.ui-timepicker-list li {
	padding: 3px 0 3px 5px;
	cursor: pointer;
	white-space: nowrap;
	color: #000;
	list-style: none;
	margin: 0;
}

.ui-timepicker-list:hover .ui-timepicker-selected {
	background: #fff; color: #000;
}

li.ui-timepicker-selected,
.ui-timepicker-list li:hover,
.ui-timepicker-list .ui-timepicker-selected:hover {
	background: #1980EC; color: #fff;
}

li.ui-timepicker-selected .ui-timepicker-duration,
.ui-timepicker-list li:hover .ui-timepicker-duration {
	color: #ccc;
}

.ui-timepicker-list li.ui-timepicker-disabled,
.ui-timepicker-list li.ui-timepicker-disabled:hover,
.ui-timepicker-list li.ui-timepicker-selected.ui-timepicker-disabled {
	color: #888;
	cursor: default;
}

.ui-timepicker-list li.ui-timepicker-disabled:hover,
.ui-timepicker-list li.ui-timepicker-selected.ui-timepicker-disabled {
	background: #f2f2f2;
}

.pickerContainer :invalid{
    box-shadow : 0 2px 0 0 red;
}

.pickerContainer :invalid:focus{
    box-shadow : none;
}

        
    </style>
        <div class="presetList"></div>
        <div class="pickerWidget">
            
            <div>
                <label><b>From:</b></label>
                <input type="text" id="input1" size="10">
                <label><b>To:</b></label>
                <input type="text" id="input2" size="10">
            </div>
            <div class="timeLayer">
                <div class="fromTime">
                    <input class="timeInput" id="fromTime" type:"text"/>
                </div>
                <div class="toTime">
                    <input class="timeInput" id="toTime" type:"text"/>
                </div>
            </div>
            <div id="fromPicker" class="drPicker"></div>
            <div class="buttonbar">
                <button id="clearDateSelection">clear selection</button>
            </div>
        </div>
        
    
    </div>
    
</div>]]>
        </HtmlText>
        <DocText segment="#detail">
          <![CDATA[<br/>
<p style="font-size: 1.25em; font-weight: bold;">*** Times are assumed to be <b>local time only</b> ( widget does not convert between locality and GMT / Zulu time </p>
<br/>
<p style="font-size: 1.25em; font-weight: bold;">I. When implementing as a standalone component, time range picker can receive configuration for predefined values via Notify port.</p>
<br/>
<p>Event for notifying widget to create preset list is as follows:
<br/>
<pre>

    {
       "__TYPE__": "config",
       "__EVENT__": {
           "origin": "Service Health",
           "data": { 
                "predefined": [
                     {
                      "label": "Last 4 Hours",
                      "value": "4H"
                     },
                     {
                      "label": "Last 24 Hours",
                      "value": "24H"
                     },
                     {
                      "label": "Today",
                      "value": "today"
                     },
                     {
                      "label": "Yesterday",
                      "value": "yesterday"
                     },
                     {
                      "label": "Last 8 Days",
                      "value": "8D"
                     },
                     {
                      "label": "Last 30 Days",
                      "value": "30D"
                     },
                     {
                      "label": "Last 60 Days",
                      "value": "60D"
                     }
                  ]
            }
       }
       
</pre>
</p>
<br/>
<p>Event <b>__TYPE__</b> must be set to "config" </p>
<br/>
<p><b>Event.data</b> must contain object <b>"predefined"</b> as an array of objects with label and value nodes configured</p>
<br/>
<p><b>Label</b> is the text to display on the screen for the line item</p>
<br/>
<p><b>Value</b> is that which will be parsed by the widget in terms of count and units to offset based on current time. Currently all offsets are negative which means that all ranges are configured as ending at curent time.</p>
<br/>
<p><b>Exceptions</b> are for pre-defined key term items such as <b>"today"</b> and  <b>"yesterday"</b></p>
<br/>
<p>predefined values are broken down as: ( ie: 24H ) where the numeric value is the count of intervals ( or offset ) and the character suffix is the inicator for interval size
</p> 
<p>
    <ul>
        <li>"H" = "hours"</li>
        <li>"D" = "days"</li>
        <li>"W" = "Weeks"</li>
        <li>"M" = "months"</li>
            
    </ul>
</p>
<br/>
<P>Event for notifying widget of set value to display is as follows:</P>
<br/>
<P>
    <pre>
    
        {
            "__TYPE__": "filter",
            "__EVENT__": {
                "origin": "Service Health",
                "label": "Time Interval: 01/01/2019, 00:00 - 01/05/2019, 00:00 PM",
                "data": [
                      {
                       "name": "data.timeRange",
                       "value": a_testRange
                      }
                ]
            }
       }
    </pre>
</P>
<br/>
<p>Event <b>__TYPE__</b> must be set to <b>"filter"</b> and the data array must contain a named object for <b>"data.timeRange"</b> </p>
<br/>
<p>Named object breaks down as follows:</p>
<br/>
<p>
<ul>
    <li><b>"name"</b> = Must be set to "data.timeRange" for widget to identify the value as a preset being passed in.</li>
    <li><b>"value"</b> = this value is the widget will parse in. Values can be passed in various forms as identified below:
    <br/>
    <p>
        <p style="padding-left: 15px">
            <b>* As unmarked string:</b> "1546329600/1546675200" where start and end dates are in unix / epoch time separated by"/".
        </p>
        <p style="padding-left: 15px">
            <b>* As unmarked array (string representations):</b> [1546329600,1546675200] Simple array of two integers representing start and end dates in unix / epoch time. 
        </p>
        <p style="padding-left: 15px">
            <b>* As unmarked array (array representation):</b> [[2019,1,1,0,0,0],[2019,1,5,0,0,0]] Simple array of two integers representing start and end dates in unix / epoch time. 
        </p>
        <p style="padding-left: 15px">
            <b>* As marked renge:</b> "predefined:24H" Relative range ( as described above ) ( ie: 24H - 24 hours prior to current ) and prefixed with "predefined" as consistent with widget output.
        </p>
        <p style="padding-left: 15px">
            <b>* As marked adhoc or "absolute" value:</b> "absolute:1546329600/1546675200" Basically same as unmarked string but prefixed by "absolute:" consistent with widget output format.
        </p>
        <p style="padding-left: 30px; font-weight: bold; color: red; ">
            *** Please note that while the unmarked formats are implemented as a means of supporting legacy implementations, the unmarked forms are not reccommended as they are inconsistent with the outputs of the widget and, with best practice effort, the inputs to the widget should be kept consistent with its outputs.
        </p>
    </p>
    </li>
</ul>
     
</p>
<br/>
<br/>   
<p></p>
<br/>
<p style="font-size: 1.25em; font-weight: bold;">II. Time Range Picker can also be implemented as part of the <b></b>VIA Common - Dimension Filter</b> plugin</p>
<br/>
<p>When defining the <b>"type-mixins"</b>, the predefined values are passed as the <b>"predefined"</b> object passed in ont he <b>"config"</b> object for the component definition</p>
<br>
<p>The definition objects are the same as defined for the standalone implementation, in terms of notation and support levels</p>
<br/>
<p>
    <pre>
        
"widget"   : {
    "path"   : "/app/dbp/user/via_common/dbpm/VIA - Time Range Picker/TimeRangePicker",
    "config" : {
        "predefined" : [
    	{ "value" : "4H", "label" : "Last 4 Hours" },
    	{ "value" : "24H", "label" : "Last 24 Hours" },
    	{ "value" : "today", "label" : "Today" },
    	{ "value" : "yesterday", "label" : "Yesterday" },
    	{ "value" : "8D", "label" : "Last 8 Days" },
    	{ "value" : "30D", "label" : "Last 30 Days" },
    	{ "value" : "60D", "label" : "Last 60 Days" }
         ]
       }
}
        
    </pre>
</p>
<br/>
<p>The initial value can be passed in ob the <b>"dimension"</b> definition as its <b>"default"</b> value, and can be passed as any of the four (4) formats indicated above.</p>
<br/>
<p>
    <pre>
        
"dimensions" : [ 
    {
	"name": "timeRange",
	"label": "Custom Time Range",
	"type" : "TimeIntervalPicker",
    	"asLocalTime" : true,
    	"style" : "white-space:normal;height:22px;",
    	"dependent" : ["data.predefined"],
    	"enable" : true,
    	"initialize" : true,
	"default": "predefined:24H"
    }
]
        
    </pre>
</p>]]>
        </DocText>
      </Widget>
    </Widgets>
    <Functions>
    </Functions>
    <Services>
    </Services>
    <Resources>
      <Resource uuid="c8863b91-b5a9-4f16-8533-4a28b0f721bc" name="timePicker" type="application/javascript" size="36197" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
    </Resources>
    <Plugins>
    </Plugins>
  </ModelInfo>
</DashboardPluginModel>