<DashboardPluginModel description="Description of New Model 0" name="VIA - TimeSeriesChart" is_init="false">
  <ModelInfo validated="true">
    <Properties>
    </Properties>
    <Widgets>
      <Widget name="timeSeriesChart" private="false">
        <PropertyText>
          <![CDATA[[{
    "name"  :   "model",
    "label" :   "Model",
    "type"  :   "json",
    "value":    ""
}]]]>
        </PropertyText>
        <CodeText segment="#methods">
          <![CDATA[    
        _configProps: null,
        
        _uuid: 12345,
        
        _box: null,
        
        _data: null,
        
        _useDummyData : function() {
            if (this.controller.initialConfig.appId == "dbp") {
                // in Dashboard Plugin app... so either modeling preview or summary preview
                return true;
            }
            if (this.controller.initialConfig.appId == "ax" && this.controller.mode == "edit.model") {
                // in dashboard builder modeling context
                return true;
            }
            return false;
        },
        
        _getDummyData : function(callback) {
            var _self = this;
            if(_self._debug) console.log("_getDummyData");
            var uri = this.properties._model.substring(0, this.properties._model.lastIndexOf("/"));
            _self._plotly.d3.json("/vitria-oi/rest" + uri + "?op=vt:dbp:resource:incidentData", function(error, json) {
                if (error) console.log(json);
                if (error) console.log(error);
                callback(json);
            });
        },
        
        _loadRequiredLibs : function(callback) {

            // var PLOTLY_LIBRARY_PATH = AppUtil.getItemURL("/app/dbp/user/via_common/dbpm/VIA%20-%20Plotly%20Library")+"?op=vt:dbp:resource:v1.47.4.modified";
            var PLOTLY_LIBRARY_PATH = "scripts/plotly/plotly-1.47.4.min";

            var me = this;
            require([PLOTLY_LIBRARY_PATH], function(plotly) {
                me._plotly = plotly;
                console.debug("_loadRequiredLibs done");
                callback();
            });
        },
        
        _initChart: function() {
            this._box.innerHTML = "";
            if( this.renderer.result && this.renderer.result != null && this.renderer.result.length > 0 ){
                if( this._configProps != null ) {
                    this._buildChart();
                } else {
                    this._box.innerHTML = "Chart configuration missing...";
                }
                
            } else {
                this._box.innerHTML = "No data available...";
            }   
        },
        
        _buildChart: function() {
            if (this._plotly == null) return;
            
            var self    = this;
            var marginLeft          = ( self._configProps.marginLeft != null )      ? self._configProps.marginLeft : 50;
            var marginRight         = ( self._configProps.marginRight != null )     ? ( self._configProps.marginRight + 20 ) : 70;
            var marginTop           = ( self._configProps.marginTop != null )       ? ( self._configProps.marginTop + 15 ) : 35;
            var marginBottom        = ( self._configProps.marginBottom != null )    ? ( self._configProps.marginBottom + 40 ) : 90;
            var leftAxisRange       = ( self._configProps.leftAxisRange )   ? ( self._configProps.leftAxisRange ) : null;
            var leftAxisAutoRange   = ( leftAxisRange == null );               
            var leftAxisRangeMode  = ( self._configProps.leftAxisRangeMode ) ? ( self._configProps.leftAxisRangeMode ) : "normal";
            var rightAxisRange      = ( self._configProps.rightAxisRange )  ? ( self._configProps.rightAxisRange ) : null;
            var rightAxisAutoRange  = ( rightAxisRange == null );
            var rightAxisRangeMode  = ( self._configProps.rightAxisRangeMode ) ? ( self._configProps.rightAxisRangeMode ) : "normal";
            var gridColor           = "rgba(64,64,64,0.1)";
            var hoverdistance = self._configProps.hoverdistance != null ? self._configProps.hoverdistance : 10;

            var layout = {
                barmode: "overlay",
                bargap: 0.6,
                hoverdistance : hoverdistance,
                dragmode: "select",
                selectdirection :"h",
                shapes:     self._getAnnotations(),
                showlegend: self._configProps.showlegend,
                legend:     self._getLegendConfig(),
                autosize:   true,
                title:      self._configProps.title,
                xaxis:      self._getDimensionAxis(),
                yaxis: {
                    zerolinecolor: gridColor,
                    showgrid:   true, 
                    gridcolor:  gridColor,
                    zeroline:   true, 
                    showline:   true, 
                    fixedrange: true,
                    autorange:  leftAxisAutoRange,
                    range:      leftAxisRange,
                    rangemode:  leftAxisRangeMode,
                    type:       'linear', 
                    overlaying: null, 
                    side:       'left', 
                    title:      self._configProps.leftAxisTitle, 
                    titlefont:  self._configProps.leftAxisTitlefont || self._configProps.axisTitlefont,
                    tickfont: { 
                        family: 'Arial', 
                        size:   10, 
                        color: '#333333' 
                    }
  	            },
            	 yaxis2: {	
	                showgrid:   false,
	                gridcolor:  gridColor,
	                zeroline:   true, 
	                showline:   true,
	                fixedrange: true,
	                autorange:  rightAxisAutoRange,
                    range:      rightAxisRange,
                    rangemode:  rightAxisRangeMode,
	                type:       'linear', 
	                overlaying: 'y', 
	                side:       'right', 
	                title:      self._configProps.rightAxisTitle, 
                    titlefont:  self._configProps.rightAxisTitlefont || self._configProps.axisTitlefont,
	                tickfont: { 
	                    family: 'Arial', 
	                    size:   10, 
	                    color: '#333333' 
	               }
  	            },
   	            margin: {
                    l: marginLeft,
                    r: marginRight,
                    b: marginBottom,
                    t: marginTop,
                    pad: 5
                }
            };
            
            var traces = self._configSeries();
            
            self._plotly.newPlot(self._box, traces, layout, { displayModeBar: false });
            var renderer = self.renderer;
            var refData = self["_data"];
            
            self._box.on('plotly_selected', function( eventdata ){
                if(eventdata && eventdata.points && refData){
                    var selection = [];
                    for (var i=0; i<eventdata.points.length; i++){
                        selection.push(refData[eventdata.points[i].pointIndex])
                    }
                    renderer.updateSelection(selection);
                    self._lastEventTime = (new Date()).getTime();
                }
            });
            
            self._box.on('plotly_deselect', function( eventdata ){
                renderer.updateSelection([]);
                self._lastEventTime = (new Date()).getTime();
            });
            
            self._box.on('plotly_hover', function( eventdata ){
                if (self.tile != null) {
                    if (self._disableHoverEvt == true){
                        self._disableHoverEvt = false;
                        return;
                    }
                    self._updateHoverUnhoverEvent([{
                        "__TYPE__" : "onTSHover",
                        "__EVENT__" :{
                            pointIndex : eventdata.points[0].pointIndex,
                            item: refData[eventdata.points[0].pointIndex],
                            xvals:eventdata.xvals
                        }
                    }])
                }
            });
            
            self._box.on('plotly_unhover', function( eventdata ){
                if (self.tile != null) {
                    self._updateHoverUnhoverEvent([{
                        "__TYPE__" : "onTSUnhover",
                        "__EVENT__" :{
                            pointIndex : eventdata.points[0].pointIndex,
                            item: refData[eventdata.points[0].pointIndex],
                            xvals:eventdata.xvals
                        }
                    }]);
                }
            });
            
            self._box.on('plotly_relayout',
                function(eventdata){ 
                    if (self._disableRelayoutEvt == true){
                        self._disableRelayoutEvt = false;
                        return;
                    }
                    if (self.tile != null) {
                    	self.tile.updateUIEvent([{
                            "__TYPE__" : "onTSRangeChange",
                            "__EVENT__" : {
                                "tile" : {
                                    "name" : self.tile.modelName,
                                    "title" : self.tile.modelTitle
                                },
                                "rangeData": eventdata,
                                "data" : {
                                    "start": eventdata['xaxis.range[0]'],
                                    "end" : eventdata['xaxis.range[1]']
                                },
                                "item" : refData[0]
                            }
                        }]);
                        self._lastEventTime = (new Date()).getTime();
                    }
                
                }
            );
            
        },
        
        _updateHoverUnhoverEvent: function(evt){
            if (this.tile != null) {
                var self = this;
                self._lastHoverUnhoverEvent = evt;
                var now = (new Date()).getTime();
                if (self._lastEventTime && (now - self._lastEventTime < 100)){
                    if (self._hoverUnhoverEventTimeout == null){
            	        self._hoverUnhoverEventTimeout = window.setTimeout(function() {
            	            self.tile.updateUIEvent(self._lastHoverUnhoverEvent);
            	            self._hoverUnhoverEventTimeout = null;
            	        }, 100)
                    }
                }else {
                    self.tile.updateUIEvent(evt);
                }
            }
        },
        
        _getAnnotations: function(){
            var self = this;
            var shapes = [];
            
            if( self._configProps.annotations && self._configProps.annotations.length > 0 ){
                for (var i = 0, len = self._configProps.annotations.length; i < len; ++i) {
                    var obj = self._configProps.annotations[i];
                    var type        = '';
                    var label       = obj.label;
                    var axis        = obj.axis;
                    var value       = obj.value;
                    var range       = obj.range;
                    var color       = obj.color;
                    var fillColor   = obj.fillColor;
                    var width       = obj.width;
                    var lineStyle   = obj.lineStyle;
                    var layer       = 'below';
                    
                    if(obj.label == 'mask') layer = 'above';
                    
                    var xref     = 'paper';
                    var x0          = 0;
                    var x1          = 1;
                    var yref     = 'paper'
                    var y0          = 0;
                    var y1          = 1;
                    
                    
                    if( obj.type == "line" ) {
                        type = 'line';
                        if( axis == 'left' || axis == 'right'){
                            if( axis == 'right' ){
                                yref = 'y2';           
                            } else {
                                yref = 'y';
                            }
                            
                            y0 = value;
                            y1 = value;
                            
                        } else {
                            xref = 'x';
                            xref = 'x';
                            x0 = value;
                            x1 = value;
                        }
                        
                    } else if ( obj.type == "rectangle"){
                        type = 'rect';
                        if( axis == 'left' || axis == 'right'){
                            if( axis == 'right' ){
                                yref = 'y2';           
                            } else {
                                yref = 'y';
                            }
                            y0 = range[0];
                            y1 = range[1];
                            if( value != null ){
                                x1 = value;    
                            }
                            
                        } else {
                            xref = 'x';
                            x0 = range[0];
                            x1 = range[1];
                            if( value != null ){
                                y1 = value;    
                            }
                        }
                        
                    }
                    
                    var shape = {
                        layer:      layer,
                        type:       type,
                        xref:       xref,
                        yref:       yref,
                        x0:         x0,
                        y0:         y0,
                        x1:         x1,
                        y1:         y1,
                        fillcolor:  fillColor,
                        line: {
                            width:  width,
                            color:  color,
                            dash:   lineStyle
                        }
                    };
                                    
                    shapes.push(shape);
                }
            
            }
            return shapes;
        },
        
        _configSeries: function(){
            var self    = this;
            var traces  = [];
            
            if( self._configProps.series && self._configProps.series.length > 0 ){
               for (var i = 0, len = self._configProps.series.length; i < len; ++i) {
                   
                    var type    = "scatter";
                    var mode    = null;
                    var line    = null;
                    var style   = "line";
                    var symbol  = "circle";
                    var axis    = "y";
                    var fill    = null;
                    var marker  = null;
                    var hoverinfo = "all";
                    
                    if( self._configProps.series[i].symbol && self._configProps.series[i].symbol != null ){
                        symbol = self._configProps.series[i].symbol;   
                    }
            
                    if( self._configProps.series[i].lineType && self._configProps.series[i].lineType != null ){
                        style = self._configProps.series[i].lineType;   
                    } else {
                        style = "line";   
                    }
                    
                    
                   
                    switch( self._configProps.series[i].type ){
                        case "line":
                            type    = 'scatter';
                            mode    = 'lines';
                            line    = { color: self._configProps.series[i].color, width: self._configProps.series[i].width, dash: style, shape: 'spline' };
                            if (self._configProps.series[i].showMarker == true){
                                marker = {color:self._configProps.series[i].color, size:6, opacity:0.5, symbol: "circle-open"};
                                mode = "lines+markers"
                            }else
                                marker = {};
                            fill    = null;
                            break;
                        case "bar":
                            type    = 'bar';
                            mode    = null;
                            line    = {};
                            marker  = { color: self._configProps.series[i].fillColor };
                            fill    = 'tozeroy';
                            break;
                        case "scatter":
                            type = null;
                            mode = 'markers';
                            line    = {};
                            marker  = { symbol: self._configProps.series[i].symbol, size: self._configProps.series[i].width, color: self._configProps.series[i].color };
                            fill    = null;
                            break;
                        case "area":
                            type = 'scatter';
                            line    = { color: self._configProps.series[i].color, width: self._configProps.series[i].width, dash: style, shape: 'spline' };
                            if (self._configProps.series[i].showMarker == true){
                                marker = {color:self._configProps.series[i].color, size:6, opacity:0.5,symbol: "circle-open"};
                                mode = "markers"
                            }else
                                marker = {};
                            fill    = 'tozeroy';
                            break;
                        default:
                            type = 'scatter';
                            mode = null;
                            line    = {};
                            marker  = { color: self._configProps.series[i].color, size: self._configProps.series[i].width  };
                            fill    = null;
                            break;
                    }
                    
                    if( self._configProps.series[i].axis == 'right'){
                        axis = "y2";   
                    } else {
                        axis =  "y";
                    }
                    
                    var isVisible = true;
                    if( self._configProps.series[i].visible != undefined && self._configProps.series[i].visible != null ){
                        isVisible = ( self._configProps.series[i].visible );
                    }
                    
                    var opacity = 1;
                    if( self._configProps.series[i].opacity != undefined && self._configProps.series[i].opacity != null ){
                        opacity = ( self._configProps.series[i].opacity );
                    }
                   
                    var trace = {
                        type:       type,
                        mode:       mode,
                        name:       self._configProps.series[i].label,
                        visible:    isVisible,
                        color:      self._configProps.series[i].color,
                        fill:       fill,
                        fillcolor:  self._configProps.series[i].fillColor,
                        opacity:    opacity,
                        x:          self._getValues( self._getDimensionField(), self._configProps.dimension.dataType ),
                        y:          self._getValues( self._configProps.series[i].fieldName ),
                        yaxis:      axis,
                        line:       line,
                        marker:     marker,
                        hoverinfo:  self._configProps.series[i].hoverinfo || hoverinfo
                    };
                    
                    traces.push(trace);
               }
               return traces;
            }
        },
        
        _getValues: function( field, type ){
            var self = this;
            var arrOut = [];
            if( type == undefined || type == null ){
                type = "line";   
            }
            
            for (var i = 0, len = self.renderer.result.length; i < len; ++i) {
                if( type == "epoch"){
                    arrOut.push(self.renderer.result[i][field] * 1000);
                }else if( type == "iso"){
                    arrOut.push(new Date(self.renderer.result[i][field]).getTime());
                }else {
                    arrOut.push(self.renderer.result[i][field])
                }
            }
            return arrOut;
        },
        
        _getDimensionField: function() { 
            return this._configProps.dimension.fieldName; 
            
        },
        
        _getDimensionAxis: function(){
            var self            = this;
            var title           = (self._configProps.dimension.title)           ? self._configProps.dimension.title : "";
            var type            = (self._configProps.dimension.type)            ? self._configProps.dimension.type : "date";
            var field           = (self._configProps.dimension.fieldName)       ? self._configProps.dimension.fieldName : "";
            var format          = (self._configProps.format)                    ? self._configProps.format : "%x";
            var tickAngle       = (self._configProps.tickAngle)                 ? self._configProps.tickAngle : 0;
            var showcursor      = (self._configProps.showcursor)                ? self._configProps.showcursor : false;
            var rangeslider     = (self._configProps.rangeslider)               ? self._configProps.rangeslider : false;
            var rangebuttons    = (self._configProps.rangebuttons)              ? self._configProps.rangebuttons : false;
            var gridColor       = "rgba(64,64,64,0.1)";
              return {
                    showspikes:     showcursor,
                    spikethickness: 1,
                    spikedash:      'line',
                    spikecolor:     '#333333',
                    spikemode:      'across',
                    spikesnap:      'data',
                    showgrid:       true,
                    gridcolor:      gridColor,
                    zeroline:       true,
                    showline:       true,
                    rangeslider:    showRangeSlider(),
                    rangeselector:  showRangeSelector(),
                    type:           type,
                    title:          title,
                    titlefont:      self._configProps.dimension.titlefont || self._configProps.axisTitlefont,
                    tickformat:     format,
                    tickangle:      tickAngle,
                    tickfont:       {
                                        family: 'Arial',
                                        size: 10,
                                        color: '#333333'
                                    }
                };
                
                function showRangeSelector(){
                    
                    var rangeselector = null;
                
                    if( rangebuttons && ( self._configProps.buttons !== null && self._configProps.buttons.length > 0 ) ){
                        rangeselector = { buttons: self._configProps.buttons };
                    }
                
                    return rangeselector;
                
                }
                
                function showRangeSlider(){
                    var sliderObject = null;
                    if( rangeslider ) {
                        sliderObject = {
                            thickness: .1,
                            bgcolor: '#f8f8f8',
                            bordrcolor: '#eeeeee'
                        }
                    } 
                    return sliderObject;
                }
        },
        
        _getLegendConfig: function(){
            var self        = this;
            var legendX     = (( self._box.clientWidth   - 220)  / self._box.clientWidth  );
            var legendY     = (( self._box.clientHeight  - 20)   / self._box.clientHeight );
            var legend      = null;
            
            if( self._configProps.showlegend ) {
                legend = {
                    x: legendX,
                    y: legendY,
                    orientation: 'v',
                    traceorder: 'normal',
                    font: {
                      family: 'Arial',
                      size: 10,
                      color: '#333333'
                    },
                    bgcolor: 'rgba(255,255,255,.6)',
                    bordercolor: 'rgba(255,255,255,.1)',
                    borderwidth: 1
                  }   
            }
            
            return legend;
        }
        ]]>
        </CodeText>
        <CodeText segment="#postCreate">
          <![CDATA[            var self = this;
            
            self._loadRequiredLibs(lang.hitch(self, "doRefresh"));]]>
        </CodeText>
        <CodeText segment="#doRefresh">
          <![CDATA[            
            var self = this;
            
            if (this._useDummyData()) {
                this._getDummyData(function(data) {
                    self.renderer.result = data;
                    execute();
                });
            } else {
                execute();
            }
            
            function execute() {
                if( self.renderer && self.renderer.result ) self["_data"] = self.renderer.result;   
                self._initChart();
            }
            ]]>
        </CodeText>
        <CodeText segment="#updateWidthAndHeight">
          <![CDATA[            if (this.vtWidth == w && this.vtHeight == h)
                return;
            this.vtWidth = w;
            this.vtHeight = h;
            var self = this;
            if (self._plotly)
                self._plotly.relayout(self._box, {});
            ]]>
        </CodeText>
        <CodeText segment="#onTileMaxsize">
          <![CDATA[            if (this.tile != null) {
            	this.tile.updateUIEvent([{
                    "__TYPE__" : "onMaxSize",
                    "__EVENT__" : {
                        "properties" : this.initialConfig.properties,
                        "tile" : {
                            "name" : this.tile.modelName,
                            "title" : this.tile.modelTitle
                        }
                    }
                }]);
            }]]>
        </CodeText>
        <CodeText segment="#onTileMinisize">
          <![CDATA[            if (this.tile != null) {
            	this.tile.updateUIEvent([{
                    "__TYPE__" : "onRegSize",
                    "__EVENT__" : {
                        "properties" : this.initialConfig.properties,
                        "tile" : {
                            "name" : this.tile.modelName,
                            "title" : this.tile.modelTitle
                        }
                    }
                }]);
            }]]>
        </CodeText>
        <CodeText segment="#onSwitchIn">
          <![CDATA[            this._active = true;

            if (this.tile != null) {
            	this.tile.updateUIEvent([{
                    "__TYPE__" : "onSwitchIn",
                    "__EVENT__" : {
                        "properties" : this.initialConfig.properties,
                        "tile" : {
                            "name" : this.tile.modelName,
                            "title" : this.tile.modelTitle
                        }
                    }
                }]);
            }]]>
        </CodeText>
        <CodeText segment="#onSwitchOut">
          <![CDATA[            this._active = false;
            
            if (this.tile != null) {
            	this.tile.updateUIEvent([{
                    "__TYPE__" : "onSwitchOut",
                    "__EVENT__" : {
                        "properties" : this.initialConfig.properties,
                        "tile" : {
                            "name" : this.tile.modelName,
                            "title" : this.tile.modelTitle
                        }
                    }
                }]);
            }]]>
        </CodeText>
        <CodeText segment="#constructor">
          <![CDATA[            
            
            
]]>
        </CodeText>
        <CodeText segment="#buildRendering">
          <![CDATA[            
            
            
            var configStr = this.initialConfig.properties.model;
            if( configStr && configStr != null && configStr != "" ){
                
                try{
                this._configProps = JSON.parse(configStr);
                } catch (e){
                    console.warn("Error: buildRendering().configProps deserialization ::: " + e);
                
                }
            }
]]>
        </CodeText>
        <CodeText segment="#onNotify">
          <![CDATA[            var self = this;
            
            if( evt.eventdata && evt.eventdata != null && self._box != null ){
                
                if( evt.eventdata != null && self._plotly != null ){
                    self._disableRelayoutEvt = true;    
                    self._plotly.relayout(self._box, evt.eventdata);
                }
                return;   
            }
            if( evt.hoverdata  && self._box != null ){
                
                if( evt.hoverdata != null && self._plotly != null && self._data){
                    var xval = evt.hoverdata.xvals[0];
                    self._disableHoverEvt = true;
                    self._plotly.Fx.hover(self._box, {xval:xval});
                }
                return;   
            }
            if( evt.unhoverdata && self._box != null ){
                if( evt.unhoverdata != null && self._plotly != null){
                    self._plotly.Fx.unhover(self._box);
                }
                return;   
            }
            if(evt.selection && self._box != null ){
                if( evt.selection != null && self._plotly != null && self._data){
                    var selectedpoints = [];
                    if(lang.isFunction(evt.selection)){
                        array.forEach(self._data, function(item, index) {
                            if(evt.selection(item))
                                selectedpoints.push(index);
                        });
                    }else if (lang.isArray(evt.selection) && evt.selection.length > 0){
                        if (lang.isObject(evt.selection[0])){
                            for (var i=0; i<evt.selection.length; i++){
                                array.forEach(self._data, function(item, index) {
                                    if(item == evt.selection[i])
                                        selectedpoints.push(index);
                                });
                            }
                        }else{
                            selectedpoints = lang.clone(evt.selection);
                        }
                    }
                    if (selectedpoints.length == 0)
                        self._plotly.restyle(self._box, {selectedpoints:null});
                    else
                        self._plotly.restyle(self._box, {selectedpoints:[selectedpoints]});
                }
                return;   
            }

            var needBuildChart = false
            
            if( evt.title && evt.title != null ){ 
                self._configProps.title = evt.title;
                needBuildChart = true;
            }
                
            if( evt.leftAxisTitle && evt.leftAxisTitle != null ){ 
                self._configProps.leftAxisTitle = evt.leftAxisTitle;
                needBuildChart = true;
            }
            
            if( evt.rightAxisTitle && evt.rightAxisTitle != null ){
                self._configProps.rightAxisTitle = evt.rightAxisTitle;
                needBuildChart = true;
            }
            
            if( evt.leftAxisRange && evt.leftAxisRange != null ){ 
                self._configProps.leftAxisRange = evt.leftAxisRange;
                needBuildChart = true;
            } else if ( evt.leftAxisAutoRange ){
                self._configProps.leftAxisRange = null;
                needBuildChart = true;
            }
            
            if( evt.rightAxisRange && evt.rightAxisRange != null ){
                self._configProps.rightAxisRange = evt.rightAxisRange;
                needBuildChart = true;
            } else if (evt.rightAxisAutoRange) {
                self._configProps.rightAxisRange = null;
                needBuildChart = true;
            }
                
            if( evt.showlegend && evt.showlegend != null ){
                self._configProps.showlegend = evt.showlegend;
                needBuildChart = true;
            }
            
            if( evt.dimension && evt.dimension != null ){
                self._configProps.dimension = evt.dimension;
                needBuildChart = true;
            }
                
            if( evt.format && evt.format != null ){
                self._configProps.format = evt.format;
                needBuildChart = true;
            }
                
            if( evt.showcursor && evt.showcursor != null ){
                self._configProps.showcursor = evt.showcursor;
                needBuildChart = true;
            }
            
            if (evt.hoverdistance && evt.hoverdistance != null) {
                self._configProps.hoverdistance = evt.hoverdistance;
                needBuildChart = true;
            }
                
            if( evt.rangeslider && evt.rangeslider != null ){
                self._configProps.rangeslider = evt.rangeslider;
                needBuildChart = true;
            }
            
            if( evt.rangebuttons && evt.rangebuttons != null ){
                self._configProps.rangebuttons = evt.rangebuttons;
                needBuildChart = true;
            }
                
            if( evt.series && evt.series != null){
                if (lang.isArray(evt.series)) {
                    self._configProps.series = evt.series;
                } else if (lang.isObject(evt.series)) {
                    self._configProps.series = self._configProps.series || [];
                    var seriesMap = {};
                    self._configProps.series.forEach(function (item) {
                        seriesMap[item.fieldName] = item;
                    });
                    
                    for (var pro in evt.series) {
                        if (seriesMap[pro]) {
                            lang.mixin(seriesMap[pro], evt.series[pro]);
                        } else {
                            evt.series[pro].fieldName = pro;
                            self._configProps.series.push(evt.series[pro]);
                        }
                    }
                }
                needBuildChart = true;
            }
                
            if( evt.annotations && evt.annotations != null && evt.annotations.length > 0 ){
                self._configProps.annotations = evt.annotations;
                needBuildChart = true;
            }
            
            if (needBuildChart == true && self._box != null ) {   
                self._buildChart();
            }
            ]]>
        </CodeText>
        <CodeText segment="#postMixInProperties">
          <![CDATA[            
            var array = new Uint32Array(1);
                window.crypto.getRandomValues(array);
                this._uuid = array;
            ]]>
        </CodeText>
        <HtmlText>
          <![CDATA[<div style="width:100%;height:100%;">
    <style>
        .timeSeriesChartBox {
            padding: 0px;    
        }
    </style>
    <div class="timeSeriesChartBox" data-dojo-attach-point="_box"
        style="width:100%;height:100%;">
    </div>
</div>
]]>
        </HtmlText>
        <DocText segment="#detail">
          <![CDATA[    <div>
        On Win/linux:
            Click to select, double click to unselect.
            Ctr + Click to zoom in, Ctr + double click to zoom out.
            Shit + Click to pan
    </div>
    <div>
        On Mac:
            Click to select, double click to unselect.
            Commond + Click to zoom in, Commond + double click to zoom out.
            Shit + Click to pan.
    </div>]]>
        </DocText>
      </Widget>
    </Widgets>
    <Functions>
      <Function name="TSNotifyConvertion" args="evt,defaultCfg" private="false">
        <CodeText>
          <![CDATA[function converFormat(format){
    format = format.replace(/yyyy/g,"%Y");
    format = format.replace(/MM/g,"%m");
    format = format.replace(/dd/g,"%d");
    format = format.replace(/hh/g,"%I");
    format = format.replace(/mm/g,"%M");
    format = format.replace(/a/g,"%p");
    return format;
}

function toRGBA(color, fillAlpha){
    var t = {};
    var bits = (color.length == 4) ? 4 : 8,
	mask = (1 << bits) - 1;
    color = Number("0x" + color.substr(1));
    array.forEach(["b", "g", "r"], function(x){
		var c = color & mask;
		color >>= bits;
		t[x] = bits == 4 ? 17 * c : c;
	});
	if (fillAlpha)
    	t.a = Number(fillAlpha);
    else
        t.a = 1;
    return "rgba("+t.r+","+t.g+","+t.b+","+t.a+")";
}

var chart = evt.chart;
evt.dimension = lang.clone(defaultCfg.dimension);
if(chart.axis){
    if (chart.axis.dimension){ 
        if(chart.axis.dimension.label)
            evt.dimension.title = chart.axis.dimension.label;
        if(chart.axis.dimension.config && chart.axis.dimension.config.labelFormat)
            evt.format = converFormat(chart.axis.dimension.config.labelFormat);
    }
    if (chart.axis.primary){
        if(chart.axis.primary.label)
            evt.leftAxisTitle = chart.axis.primary.label;
    }
    if (chart.axis.secondary){
        if(chart.axis.secondary.label)
            evt.rightAxisTitle = chart.axis.secondary.label;
    }
}
if (chart.axisConfig){
    if(chart.axisConfig.valueAxisRangeFromValue && chart.axisConfig.valueAxisRangeToValue) {
        evt.leftAxisRange = [chart.axisConfig.valueAxisRangeFromValue, chart.axisConfig.valueAxisRangeToValue]
    } else {
        delete evt.leftAxisRange;
        evt.leftAxisAutoRange = true;
    }
    if(chart.axisConfig.secValueAxisRangeFromValue && chart.axisConfig.secValueAxisRangeToValue) {
        evt.rightAxisRange = [chart.axisConfig.secValueAxisRangeFromValue, chart.axisConfig.secValueAxisRangeToValue]
    } else {
        delete evt.rightAxisRange;
        evt.rightAxisAutoRange = true;
    }
}

var defaultSeries = defaultCfg.series;
if (chart.series && chart.labels && chart.series.visible && chart.series.config){
    evt.series = [];
    for (var i=0; i<defaultSeries.length;i++){
        var dconf = defaultSeries[i]
        var field = dconf.fieldName;
        if(chart.series.visible[field] === true){
            var conf = chart.series.config[field]
            var nconf = lang.clone(dconf);
            nconf.label = chart.labels[field];
            
            var type = conf.seriesType;
            if (type == "line"){
                nconf.type = "line";
                nconf.color = conf.color;
                if (conf.width)
                    nconf.width = Number(conf.width);
                if (conf.fillAlpha)
                    nconf.opacity = Number(conf.fillAlpha);
            }else if (type == "column"){
                nconf.type = "bar";
                nconf.color = conf.color;
                if (conf.width)
                    nconf.width = Number(conf.width);
                nconf.fillColor = toRGBA(conf.color, conf.fillAlpha);
            }else if (type == "area"){
                nconf.type = "area";
                nconf.color = conf.color;
                if (conf.width)
                    nconf.width = Number(conf.width);
                nconf.fillColor = toRGBA(conf.color, conf.fillAlpha);
            }
            evt.series.push(nconf);
        }
    }
}]]>
        </CodeText>
      </Function>
    </Functions>
    <Services>
    </Services>
    <Resources>
      <Resource uuid="583e9b23-572d-4d15-80a3-c1c3827a162b" name="__SampleModelForTest" type="text/plain" size="2516" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="57d4a07e-00c1-4721-86b4-8cc3a15ed92e" name="__SimpleConfigModel" type="text/plain" size="502" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="7b6232e6-bd28-440a-8c37-07926e2a417d" name="incidentData" type="application/json" size="205838" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
    </Resources>
    <Plugins>
    </Plugins>
  </ModelInfo>
</DashboardPluginModel>