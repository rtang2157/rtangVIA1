<DashboardPluginModel description=" " name="VIA - Common" is_init="false">
  <ModelInfo validated="true">
    <Properties>
    </Properties>
    <Widgets>
      <Widget name="Action Bar" private="false">
        <PropertyText>
          <![CDATA[[{
    "name" : "model",
    "label" : "Model",
    "type" : "json"
}]]]>
        </PropertyText>
        <CodeText segment="#constructor">
          <![CDATA[
            if (this.initialConfig.properties != null && this.initialConfig.properties.model != null && this.initialConfig.properties.model.trim() != "") {
                this._model = JSON.parse(this.initialConfig.properties.model);
            }
]]>
        </CodeText>
        <CodeText segment="#postCreate">
          <![CDATA[
            if (this._model == null && this._useDummyModel()) {
                var self = this;
                this._getDummyModel(function(t) {
                    self._model = JSON.parse(t);
                    if (self._model.menubar != null) {
                        self._createMenuBar(self._model.menubar);
                    }
                    if (self._model.toolbar != null) {
                        self._createToolBar(self._model.toolbar);
                    }
                    if (self._model.sidebar != null) {
                        self._createSideBar(self._model.sidebar);
                    }
                });
            }
            else {
                if (this._model.menubar != null) {
                    this._createMenuBar(this._model.menubar);
                }
                if (this._model.toolbar != null) {
                    this._createToolBar(this._model.toolbar);
                }
                if (this._model.sidebar != null) {
                    this._createSideBar(this._model.sidebar);
                }
            }

            this.doRefresh();]]>
        </CodeText>
        <CodeText segment="#methods">
          <![CDATA[
        _createMenuBar : function(defs) {
            this._menubarItems = {};
            var div = domConstruct.create("div", {
                style : "width:100%;height:auto;text-align:left;"
            });
            this.domNode.appendChild(div);
            
            var self = this;
            parseMenuBarDefs(this._menubarItems, [], null, defs, function(value) {
                var item = self._menubarItems[value];
                if (item != null) {
                    self._onSelect("menubarSelect", item, value);
                }
            }, function(menubar) {
                self._menubar = menubar;
                self._menubar.placeAt(div);
                self._menubar.startup();
            });
        },

        _createToolBar : function(defs, callback) {
            this._toolbarItems = {};
            var div = domConstruct.create("div", {
                style : "width:100%;height:auto;text-align:left;"
            });
            this.domNode.appendChild(div);

            var self = this;
            parseToolBarDefs(this._toolbarItems, defs, function(value) {
                var item = self._toolbarItems[value];
                if (item != null) {
                    self._onSelect("toolbarSelect", item, value);
                }
            }, function(toolbar) {
                self._toolbar = toolbar;
                self._toolbar.placeAt(div);
                self._toolbar.startup();
                
                if (self._menubarItems != null) {
                    // has menubar
                    domStyle.set(self._toolbar.domNode, {
                        "border" : "1px solid #b5bcc7",
                        "border-top" : "none",
                    });
                }
                else {
                    // toolbar only
                    domStyle.set(self._toolbar.domNode, {
                        "border" : "1px solid #b5bcc7",
                    });
                }
                var node = self._toolbar.domNode.parentElement;
                for (var i=0; i<6; i++) {
                    if (node == null) break;
                    domStyle.set(node, {
                        "width"  : "100%",
                        "height" : "100%",
                    });
                    node = node.parentElement;
                }
            });
        },

        _createSideBar : function(defs) {
            this._sidebaritems = {};
            var div = domConstruct.create("div", {
                style : "width:100%;height:auto;text-align:left;"
            });
            this.domNode.appendChild(div);
            
            var self = this;
            parseSideBarDefs(this._sidebaritems, [], null, defs, function(value) {
                var item = self._sidebaritems[value];
                if (item != null) {
                    self._onSelect("sidebarSelect", item, value);
                }
            }, function(sidebar) {
                self._sidebar = sidebar;
                self._sidebar.placeAt(div);
                self._sidebar.startup();
                domStyle.set(self._sidebar.domNode, {
                    "width" : "100%",
                    "background-color" : "#efefef",
                    "background-repeat": "repeat-x",
                    "background-image": "linear-gradient(rgba(255, 255, 255, 0.7) 0%, rgba(255, 255, 255, 0) 100%)",
                });
            });
        },

        _onSelect : function(type, item, value) {
            var selection = [];
            if (item.config != null) {
                var config = item.config || {};
                switch (config.action) {
                    case "#doUploadFile":
                        var self = this;
                        doUploadFile(config.mimeTypes, config.content, function(file) {
                            selection.push({
                                "type"  : type,
                                "value" : value,
                                "data"  : JSON.stringify(file)
                            });
                            self._updateSelection(selection);
                        });
                        break;
                }
            }
            else {
                // just pass value string
                selection.push({
                    "type"  : type,
                    "value" : value,
                    "data"  : null
                })
                this._updateSelection(selection);
            }
        },

        _updateSelection : function(selection) {
            if (this.renderer.tile != null) {
                // use this.renderer.tile._onSelectionChange() to direct selection via Selection port
                this.renderer.tile._onSelectionChange(selection);
                
                // use this.renderer.tile._doubleClickOnSelection() to direct selection via Drilldown port
            	this.renderer.tile._doubleClickOnSelection(selection);
            }
        },

        _useDummyModel : function() {
            if (this.controller.initialConfig.appId == "dbp") {
                // in Dashboard Plugin app... so either modeling preview or summary preview
                return true;
            }
            if (this.controller.initialConfig.appId == "ax" && this.controller.mode == "edit.model") {
                // in dashboard builder modeling context
                return true;
            }
            return false;
        },

        _getDummyModel : function(callback) {
            var uri = this.properties._model.substring(0, this.properties._model.lastIndexOf("/"));
            doREST("get", uri + "/SAMPLE", null, null, callback);
        },]]>
        </CodeText>
        <CodeText segment="#functions">
          <![CDATA[    
    function parseMenuBarDefs(menubarItems, path, menu, defs, onSelect, onComplete)
    {
        require(["dijit/MenuBar",
                 "dijit/PopupMenuBarItem",
                 "dijit/PopupMenuItem",
                 "dijit/Menu",
                 "dijit/MenuItem",
                 "dijit/MenuSeparator",
                 "dijit/DropDownMenu",
                 "dojo/domReady!"],
                 function(MenuBar,
                          PopupMenuBarItem,
                          PopupMenuItem,
                          Menu,
                          MenuItem,
                          MenuSeparator,
                          DropDownMenu) {
            if (menu == null) {
                menu = new MenuBar({});
            }
            for (var i=0; i<defs.length; i++) {
                var def = defs[i];
                var itemPath = path.slice(0).concat(def.value);
                if (def.items != null) {
                    if (path.length == 0) {
                        // dropdown menu
                        var dropdownMenu = new DropDownMenu({});
                        parseMenuBarDefs(menubarItems, itemPath, dropdownMenu, def.items, onSelect, null);
                        var popupItem = new PopupMenuBarItem({
                            label: def.label,
                            popup: dropdownMenu
                        });
                        menu.addChild(popupItem);
                        //menubarItems[itemPath.join("/")] = popupItem;
                    }
                    else {
                        // nested menu
                        var dropdownMenu = new Menu({});
                        parseMenuBarDefs(menubarItems, itemPath, dropdownMenu, def.items, onSelect, null);
                        var popupItem = new PopupMenuItem({
                            label: def.label,
                            popup: dropdownMenu
                        });
                        menu.addChild(popupItem);
                        //menubarItems[itemPath.join("/")] = popupItem;
                    }
                }
                else {
                    // menu item
                    var menuItem = new MenuItem({
                        label : def.label,
                        iconClass: def.icon,
                        onClick : lang.partial(onSelect, itemPath.join("/")),
                    });
                    menu.addChild(menuItem);
                    def.widget = menuItem;
                    menubarItems[itemPath.join("/")] = def;
                }
            }
            if (onComplete != null) {
                onComplete(menu);
            }
        });
    }
    
    function parseToolBarDefs(toolbarItems, defs, onSelect, onComplete)
    {
        require(["dijit/form/Button", "dijit/Toolbar", "dijit/ToolbarSeparator", "dojo/domReady!"], function(Button, Toolbar, ToolbarSeparator) {
            var toolbar = new Toolbar({
                "class" : "via-action-bar-toolbar",
            });
            for (var i=0; i<defs.length; i++) {
                var def = defs[i];
                if (def.label != null) {
                    if (def.value != null) {
                        // toolbar item
                        var config = {
                            name : def.value,
                            label : def.label,
                            showLabel : def.icon == null,
                            iconClass: def.icon,
                            onClick : lang.partial(function(value) {
                                onSelect(value);
                            }, def.value),
                        };
                        if (def.title != null) {
                            config.title = def.title;
                        }
                        var button = new Button(config);
                        button.startup();
                        toolbar.addChild(button);
                        def.widget = button;
                        toolbarItems[def.value] = def;
                    }
                    else {
                        // label using disabled button
                        var config = {
                            label : def.label,
                            "class" : "via-action-bar-toolbar-button-as-label",
                            "disabled" : true
                        };
                        if (def.title != null) {
                            config.title = def.title;
                        }
                        var button = new Button(config);
                        button.startup();
                        toolbar.addChild(button);
                    }
                }
                else {
                    toolbar.addChild(new ToolbarSeparator());
                }
            }
            onComplete(toolbar);
        });
    }
    
    function parseSideBarDefs(sidebarItems, path, menu, defs, onSelect, onComplete)
    {
        require(["dijit/PopupMenuBarItem",
                 "dijit/PopupMenuItem",
                 "dijit/Menu",
                 "dijit/MenuItem",
                 "dijit/MenuSeparator",
                 "dijit/DropDownMenu",
                 "dojo/domReady!"],
                 function(PopupMenuBarItem,
                          PopupMenuItem,
                          Menu,
                          MenuItem,
                          MenuSeparator,
                          DropDownMenu) {
            if (menu == null) {
                menu = new Menu({});
            }
            for (var i=0; i<defs.length; i++) {
                var def = defs[i];
                var itemPath = path.slice(0).concat(def.value);
                if (def.items != null) {
                    // nested menu
                    var dropdownMenu = new Menu({});
                    parseSideBarDefs(sidebarItems, itemPath, dropdownMenu, def.items, onSelect, null);
                    var popupItem = new PopupMenuItem({
                        label: def.label,
                        popup: dropdownMenu
                    });
                    menu.addChild(popupItem);
                    //sidebarItems[itemPath.join("/")] = popupItem;
                }
                else {
                    // menu item
                    var menuItem = new MenuItem({
                        label : def.label,
                        iconClass: def.icon,
                        onClick : lang.partial(onSelect, itemPath.join("/")),
                    });
                    menu.addChild(menuItem);
                    def.widget = menuItem;
                    sidebarItems[itemPath.join("/")] = def;
                }
            }
            if (onComplete != null) {
                onComplete(menu);
            }
        });
    }

    function doUploadFile(mimeTypes, content, callback)
    {
        require(["af/controls/FileUploadHelper", "dojo/domReady!"], function(FileUploadHelper) {
            var helper = new FileUploadHelper();
            var widget = helper.getUploader({
                showLabel: false,
                autoWidth : true,
                label: "",
                "class": "clear-dijit-style",
                onChangeHandler: function(file) {
                    // file = {"index":0,"name":"DatabaseResources-hello.zip","size":134330,"type":"application/x-zip-compressed","uploadType":"html5"}
                    console.debug("onChangeHandler");
                    window._vtUploadedFile = file;
                },
                uploadCompleteHandler: function(data) {
                    // data = {uid:"743f8540-2991-478a-8e2d-45743c4a3a7a"}
                    console.debug("uploadCompleteHandler");
                    if (window._vtUploadedFile != null) {
                        if (mimeTypes == null || mimeTypes == "" || mimeTypes.indexOf(window._vtUploadedFile.type) != -1) {
                            window._vtUploadedFile.uid = data.uid;
                            if (content == true) {
                                // grab file content... ascii ONLY
                                GET("/vitria-oi/rest/app/dojoclient/user/vtbaadmin/foo.txt", {op:"download", uid:data.uid}, function(t) {
                                    window._vtUploadedFile.status = "OK";
                                    window._vtUploadedFile.content = t;
                                    callback(window._vtUploadedFile);
                                    delete window._vtUploadedFile;
                                });
                            }
                            else {
                                window._vtUploadedFile.status = "OK";
                                callback(window._vtUploadedFile);
                                delete window._vtUploadedFile;
                            }
                        }
                        else {
                            window._vtUploadedFile.status = "ERROR";
                            window._vtUploadedFile.error = "Invalid import file format: " + window._vtUploadedFile.type;
                            console.error(window._vtUploadedFile.error);
                            callback(window._vtUploadedFile);
                            delete window._vtUploadedFile;
                        }
                    }
                }
            });
            widget.startup();
            widget.domNode.childNodes[0].click();
        });
    }
    ]]>
        </CodeText>
        <CodeText segment="#doRefresh">
          <![CDATA[
            if (this.renderer.result != null) {
                for (var i=0; i<this.renderer.result.length; i++) {
                    var record = this.renderer.result[i];
                    var value = record["value"];
                    var disable = record["disable"];
                    if (value != null) {
                        if (disable == true || disable == false) {
                            // pay attention ONLY to true or false... ignore other values
                            if (this._menubarItems != null) {
                                var menubarItem = this._menubarItems[value];
                                if (menubarItem != null && menubarItem.widget != null) {
                                    menubarItem.widget.set("disabled", disable == true);
                                }
                            }
                            if (this._toolbarItems != null) {
                                var toolbarItem = this._toolbarItems[value];
                                if (toolbarItem != null && toolbarItem.widget != null) {
                                    toolbarItem.widget.set("disabled", disable == true);
                                }
                            }
                            if (this._sidebaritems != null) {
                                var sidebaritem = this._sidebaritems[value];
                                if (sidebaritem != null && sidebaritem.widget != null) {
                                    sidebaritem.widget.set("disabled", disable == true);
                                }
                            }
                        }
                    }
                }
            }
]]>
        </CodeText>
        <HtmlText>
          <![CDATA[<div style="width:100%;height:100%;">
</div>
]]>
        </HtmlText>
        <DocText segment="#summary">
          <![CDATA[<p>
MenuBar and ToolBar. Each will take 27px height individually,
but if both are defined, a 1px border between is removed so will only need 53px.
</p>
<p>
Has builtin support for file upload. Browser security prohibits non-UI initiated execution from file upload.
</p>
]]>
        </DocText>
        <DocText segment="#detail">
          <![CDATA[Sample model and corresponding rendering
<table style="width:100%;" cellspacing="5">
    <tr valign="top">
        <td style="font-family:courier;width:100%;">
            <pre>
{
  "menu" : [{
    "label" : "Upload",
    "value" : "upload",
      "items" : [{
        "label" : "Use Local",
        "value" : "#doUploadFile",
        "config" : {
          "mimeTypes" : ["text/plain"],
          "content" : false
        }
      }, {
        "label" : "Use Plugin",
        "value" : "plugin"
      }, {
        "label" : "Use Notify",
        "value" : "notify"
      }, {
        "label" : "Test",
        "value" : "test",
        "items" : []
      }]
  }],
  "toolbar": [{
    "label" : "Combo",
    "value" : "combo"
  }, {
    "label" : "Always On",
    "value" : "always"
  }, {
    "label" : "Upload File",
    "value" : "#doUploadFile"
  }]
}</pre>
        </td>
        <td>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASUAAADcCAIAAAC57yBFAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAABMfSURBVHhe7d1tcFTXeQfwu7y44JjWJICkkoodm0AjoBg7UlctFBU6bWLoSDbI0ZrUFn7BJINTIExGW08QeMqsJpHBnSatBzJY7cTeDSK2NMHE9RQswK5WC6RVnfLBxIzAuFqZ6bh103ywxW6fc55zX/WyK+nuQbv6/+bO6t5z33bF/vc592rvJZBMJmfPnm0AQP5NUz8BIP/s+vaPyf/ipoJQs+g31BhA4XDlrap6LbdOcsnuMwf+4g/UBEDhQH8SQJ9CzVsGoAChvgHog/oGoA/qG4A+qG8A+uSet8SrFYFXe9UE+ehkXf2RhJrwSr29w7XwWHh3BFA0UN8A9PEjb70t9Tvibx8J1FfQ0PKuajXdiH9XtLtmidqoGuvevsFtoiSKliNdPA1QfHyqb6fDby/sb7+UObAr8oyrk5l4dW3YaDVn7Yh/RG29Ldv2hA5cysjGzuc7xPLvHil73ogdpsYq42W55ujUxwVAQfGrPxmtu7+Ufiypi1Ue6rJL3I2+y85Zp+OXqJqtbGq/1LREzp+/sFb+TN3oNR5+smEuja5s3LlOtgEUHZ/yti44X425/WffeTVG2Qp+QY2ZXceKwLY9nbKl78PT8mfO1McFQEHJPW/BBe6yc+MDjop0uk8dhTkDRn47WKnGuNYJH53crrqOlzKHW7m+eTcOUJRyz1vp/JXGy0fkARi5Ee84ZDxcFeIpw4j8hzyD/24yYuyq4b6iIGpapONkikbf7QifX9dQ4aqDiS5V30or7q9VG+9tez6HWqc+LgAKyhj6k0uezBxYGd7G5xXXhr8QyzywUs0y1kUNeX7ymd7Y4SetEJLQA2dixp4yMetQ9MD3xRHa3PubHj7N2+laFosavX0Us7n3v7DTkI1Hgjt3qZUBiowf17/1tlBIDsss6ZHsPvOd+nvVBEDh8Ov8JABk50feVja1ayxuAIWrUOubOvwEKCjoTwLog/oGoA/qG4A+qG8A+qC+AehTqPdX9tHa8tvUmBQIBNQYgN9cefvuY4Vxf2Ufffvomb/+WrWakJA3yB/0J71URzuTUdMA/kHejLSkQuYwUjvAuKm80RiPTEH8i3BGS82QPJMAEyHyNsXfUjclyhs/WmT0BOc4wERk7U8mWgKBFscdgFLxOtd07sSadXFx6akf6Hn5tDFP2Pj3Qu38COCjaXhXfSoNSqLSSRw8K37WCMBETOR8iShYzK40ohx6mkZnb8RRNa2tmG1Wg7vY+oKTRoYmTS0B4JPxny9JxbeHQ90is5nuULhNpICyU52I9VNLf8wIl+WQjERLWdiQa3RHI9WcUbEVQ264P5aopo3Ym6WW2kiLb31S9onkqXKUN4vY8Zj0fG+2qf6YfN7+ENv9Xo+aIP3H6l3TLqPOzMK7IyI25yYWoAXFK5zIvqaWidQ3S6gp0xSioHTFO2sbasTNJksbmqJGoi9bMFJ9CSPa1CDWCDXGajvjXSm5lWiNvAdKaUOH2LD40SEXMkqDzpuj+IMzRqz6ZmVMLSENbRlWqv2h22uMrl+zK/Xtd93emlTzCt3Gf7iiXpewp8owqvb8+li9/JeBnIw/b5SCbqPa28frDJdxU3XE6OzrU60j6euz76lnRsnZZrK7k7RZv4nidv4HwSc6+gcH+1/ZWlJSMm/evLlzt7T3p9P9xxrueM784O5p/UyrGE8de+h29tCxFM+y9PzoUaPtyrcq1WTJ5h+/+ezeVrmYWK21tVWtKrc0VuLpqlHBEA1yrKeVnssxtW3etD3T8YTtvdpt9qsw21rPenZEeHOeRt5vKtu+wJK1PxkM8h0iTc44UF2TKHfm4VqUe5hMFL1ROTcuap3g3aFIW3XE3G53VDX6h7qRqWv/uv4rX/rshb+7b8c9ne+/39/f/7PvnHzi5fNGyZoHNzSf4/qUPNe8f02VMdD+zcaqN/9PeLOq8Ufu2pU8t3fj5j8qUVPSovKNJ46fHeCJvcnyK2LFZ429z7WrNp+caDyutr33j59zPqvkc3c10meAmvVVuVvRZr6IZ0/wq7CXW2PslWuOnb1de1/gIPJGb2OeGI4oO/YhUyreEjG4t+c+IR8KlhqlNQ3W0ZWoSNlPmTg2nmgLc2dUtnXJ7IlzKa6NyN37bWBwIHEy8+X77hxc8fh7721bKbuUn//8V+j3kk7PX71pw/mr4his52zzvtWibtEqIvmkcvevdpuVzGTPVRaUi1veijH6sXHzmgU0Vrl6/5DlcuJZybERw9i/e7Pc9pa2jXvPUm1RM1NXk85ZlH2qZvTMzadeXr5xuOWGPDva3InGuz6jfLVd1UTei9pXz9m9xn75S+J9Xe0To2DL3p+kItYdMnuJZeIUCZetUJPVXG10yzbRxVRtoiKpYy4nq7tJRJJCTfLMCk3ZK4i2hOyoir1Rmzi0i8iG7UYTHeVl7aaOzfX09etvLi+dSzH78KdP3R0MBhcuXLjiqZ/RW4jmlqzeZPzkrQGqXPv2UXWjhs3x08a6OyRXHclFZbmr9vlp46JFaszt6tUTaoyeu8y+MHC8gV/CHXc38nznciPY2Pber5T45pFeSLP63Yjtnr+GAueW0/Gb2W8UHH1Eu9luHK5NEac9nDhddqu9grfNmu5oCNGobKQdDZPn8fjg9Qt/u2PVckrba/t2Zg72XLly7dq13r//sqodC/7wwczxs+0UN/7gJpW7/1c6ZayzPucZFa4T7aKA2HrONW/YtFqUDVEG5A9ij41BefkG13p9IiI8SsXHLCZ2q/zhXEnUMPmT+sSZF38pX8QvX+T5no07x5WhLY7FeMQwNqjNSrFN/LrBNP7zJUXjjTfe2XHvCvnboCn+8fMff/11nssV7rHHKG6iutEhysE5Dcetj+0qT8Gq2vKisXXxQbPuURlZ30y9NH+qWkl5ldF80Nz5wPGDzdR742dFmt+Se02+5Wp1rpR8aetrGzavcT0Z0SZHStZs3uBYTraNVdXq/a9tfUk+DXrlc+ZYvwdQkDfDOLts1TLxB4DP/tlju059K3T33eXl3dU/jRgXrnKhogq3wWg2q1vlrlOVWxfPEdZnTu3yHr8t2BT7+FRmvZw/Z87i45suf2wtQ2lW5UB0VXlsTCp3fWztfM7irZWnzG3T9jbsyxwUzeuTRy9zq9pd5a7LR+kzQMxq3ndKlpwFm3bve423c271qX1GUrzSBZueV8sd/J2j+6ynaqHflBqzWa/Dsa+kfPGLtxrm8wBboKenZ9asWTT20sX/nprXm9b97swZppkzZ9522230qKZnzJg2bdqHr3xt6bVd/7NbHPvQQSSvOLmcP/ibB8svx3yqo5A3qG9ZXDg0d+njX/pnGTaACUJ9O1O7VJUyLmtD65s4M2qWtUla36BAoL4B6IO8DT0JAJAvyBuAPsiboD58APIMeQPQJ+v5yUSL+Hqk/WWrVLyurI+vdxsjsWbYea1NbaxffCWL9tASlGO5Gevyo/r20TOLBq9Nmy7MmDGDHmbOnCnHZnDjtGkBeVYS5yfBB5rzFm+wg2Lmps/P/IwV5W3LfXfKM/8iaYT/HkC4EX8PAB9NpD8pLpdh9kUzFCJv00iCQddX/cXWHLcrMdc3N9jSYrapmXJ5alSzs9+7AeCWG3/eJnr/Enn3hWBQTY3AutS0P5gY5sq3SCLI9z5xXKIHMHn5cr4klPP9SxzXv6mL29SM4SW6IrWxRtF1lRscQu0tVOP/Vd8AeTD+vImLS8d8/5Javs0Wy3oMaN5iYUTiqnKAwpE1b3m9f8kIzJzl425cALdQ1rzl9f4lXnzfEtEv5WnqKHaah4Z5uHMJgGbZ+5NUxPy7f8koShteULcp2W40mMdjtJOotw2gYBXM9ThUMF1/B/QJ/v4GOvlyfjJv7L/wBcQfGvwOG4Bmkztv9o26zNt5ARSyyZ03gOKCvAHog7wB6IO8AeiDvAHog7wB6IO8AeiDvAHokzVv4ovHzgtHnZdhj438sojzO8zubzx7WDPtHYqnQsb+NWiASUJ3fVNf9x8D8R0T+UWuVF9CXj6HL5pAwZpI3uxvN9olR9WgkapQNBqNVA9THu1NyZk0Ka5XDZfRVri+0WNZuFNczdryQ0dZpGaUOygc48/b+O5fUiMusPHeayTRUhY25Hri6hsKkLiwJ2reL0+ilv5YrbictemJmmhnvEtuIdUVN/iWCgCFwJf+ZO73LyGhRsridmfixOXc0SaZLPFfdZthGpG4ClXeqgFxgwIz/ryJGjTm+5cI4sJSw3kY57xFQ063UKDAiSvBETcoNFnzlo/7l4jqR4dxXWrSuYustwiSZODiiBsUmqx5y8/9S+R9EiLqjiSOXSTawmaXdFQicOEw4gYFJnt/Mk/3LxGJU6M0Ls+vuFYTd1+W5yd5ES8KnHn3SYCCUaj/nzDVT1/+0wHcvwR08uX8pGbiL3LVidgLEw4bgGaFmDfxjRN8ywQKUSHmDaBQIW8A+iBvAPq4zk+qtqnn0d+fh/OToIErb39ZXzB/D/DL37SfoUfkDfRw9SdvpqfcQLbcd6d89QB5585bZsoNTHzZczhqNoBPXHkbTE+5gaOmXv8QciZSB77J0p+8eCiw5HOeoeXikMWGGfrjX89xyTwP9Jw9LdYwaBW4USFy4Jcs/ckV38z84kMauncaxs6TPN60Yshiwwz0NjWMtKfxVgzki/MDnkZrcOJqxlQTgK9y7U9Sz4vCoyZT8acXBJaLoeXnaoHUiUe4JfD0K6nBdOLw8vBpI7LFXuCWDYyemKf905sZerR4Mjb6JMD45Hq+hPMmxxM//L3wshOZi/2Ztr+KPNIYH8gYA69ub7q3m1ou9ncv2972b5nQo72xGiPa1t+0zLGRWzJY7ikdpsoxK0404hznEQC/ZDl+swZ662V4/HzX943oqlVivKI+tvb1vutU/cRsXjL0yAdNFeYqsuUWD5bkBxnPLBqckDTIt7H3J8VbMfL4wkAVDavCZ4zE9ZTxW3/ecThTLVoWBl68YK9Cb2gev4UD+5f3Re9x6EA4XZ6MDdsIMEHj6E8axp/GOq5lzqmhY9180fjFb/Bkd7q27p8GRAstaK1yCwdCT8zTaA0AOo2lP0lvUBq/p2bbG+GTF8X4jc66NeUt76SNd34QiHSmzCVDJfPUWznt2MKtGrr6hulGWgPhr2h5vqg1bCPABOXan7xpdw5DD/XEfvFAoCYYePBp45mepiVpY8lT3UufLqOWmmD1zZ+IlsHPBZcakW8EW/7d3MLkHJysdCFmkCeu7yv/Sc0U+r4yH5ud6jrzsLx/yfTp0/lrytb3lYnz+8qEludHgPHJtT9ZfEM6I753YvEEafRJgPHJtT9ZrIMThcqimgB8lev5yaIc0kZOuUL8wC9Ttz/JAxc19fqHkDMRNvAN7qcgrjeVV3Lj+m7IO1d9A4C8sutbRUXFoPSp9Mknn/AIN6bTaVqGqPWKAhcuqmBcyrisob5B/qC+AeiTU96cH/BFpohfGkxCrrzxO896tMiZrpaiMfSl8aT1COAjb32z3mpOdAzDhzHWwUwRsF7R0Bdl/R4A/DVMf5LfcxZ+RxY99WpN6ncB4CvX+cl0Os1nI/m0pPPkZHGfnyR8NpJPSzpPThJezFqFRwDGQeRt9uzZFKdly5bdlDhjFm7ksBG1XlHgIJHpEmfMwo00lyKnVkDeYGJU3ihIXN84XRwzK2xWcSNqvaIgsyZQojhdHDMrbLK8ifqmVkDeYGLsvFF9E71GM3IWbuSwEbVeUZBZEzhXnDELN/ICagXkDSbGlTd65HRxzIo7bIzjRDhdHDNP2AgvyasAjJvKG41ZeeNHiwyaQMvwY9GwgsQ4Y4wnud25MMBEuPJGj5QoK2PFHTbGKZKxEqyM8Yi1gHMEYNwCyWRy1qxZNLZ8+XIrV07cIpYt0vpmjdCjk9XuHAGYCFfe6NEZME/YipszYJ6wEeQNfCHyxudLOG/MytgUCRuzQuVJF8IGflF/yR36DmPW8UzRc75S9VuQPJMAE+H65sSw7y1uL3rq1TqM1A4wbsNcH8DU9NSjXj+SBnkwzPUBAJAnI+ZNfchPPer1A+QB6huAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgD7IG4A+yBuAPsgbgC6G8f9GHA2CdMkrGAAAAABJRU5ErkJggg=="></img>
        </td>
    </tr>
</table>
]]>
        </DocText>
        <SchemaText>
          <![CDATA[var schema = [];
schema.push({ name:"type",  label:"Type",  type:"string", _isDimension:true,  _isMeasure:false });
schema.push({ name:"value", label:"Value", type:"string", _isDimension:true,  _isMeasure:false });
schema.push({ name:"data",  label:"Data",  type:"string", _isDimension:false, _isMeasure:false });
return schema;
]]>
        </SchemaText>
      </Widget>
      <Widget name="Dimension Filter" private="false">
        <PropertyText>
          <![CDATA[[{
    "name" : "model",
    "label" : "Model",
    "type" : "json"
},
{
    "name" : "minimizedMode",
    "label" : "Minimized Mode",
    "type" : "boolean",
    "value" : false
},
{
    "name" : "saveCookie",
    "label" : "Save Cookie",
    "type" : "boolean",
    "value" : true
},
{
    "name" : "cookiePath",
    "label" : "Cookie Path",
    "type" : "string"
},
{
    "name" : "clickToOpenHTML",
    "label" : "Expand HTML",
    "type" : "string",
    "value" : "Expand Filters"
},
{
    "name" : "clickForSummaryHTML",
    "label" : "Summary HTML",
    "type" : "string",
    "value" : ""
},
{
    "name" : "hideTileIfEmpty",
    "label" : "Hide Tile If Empty",
    "type" : "boolean",
    "value" : false
}]]]>
        </PropertyText>
        <CodeText segment="#buildRendering">
          <![CDATA[
            this._customWidgetClazz = {};
            this._popupValueAsString = {};
            this._customWidgetPaths = [
                "/app/dbp/user/via_common/dbpm/VIA - Common/Font Awesome Bar"
            ];

            this._controls = [];
            this._opened = false;
            this._notifyWidgets = {};
            this._scriptFuncs = {};

            this._cookieId = null;
            this._cookiePath = getCookiePath(this.controller, this.tile);
            this._saveCookie = this.initialConfig.properties.saveCookie != false;
            this._clickToOpenHTML = this.initialConfig.properties.clickToOpenHTML || "Expand Filters";
            this._clickForSummaryHTML = this.initialConfig.properties.clickForSummaryHTML || "";
            
            domClass.add(this.domNode, "common-plugin dimension-filter");
            
            if (this.initialConfig.properties != null && this.initialConfig.properties.model != null && this.initialConfig.properties.model.trim() != "") {
                this._empty = this.initialConfig.properties.model.trim() == "{}";
                this._model = JSON.parse(this.initialConfig.properties.model);
                this._migrateModel();
            }
            if (this.initialConfig.properties != null && this.initialConfig.properties.cookiePath != null && this.initialConfig.properties.cookiePath.trim() != "") {
                this._cookiePath = this.initialConfig.properties.cookiePath.trim();
                // set up topic to sync values across multiple filter instances
                this._syncTopicUUID = generateRandomUuid();
                this._syncTopicHandle = topic.subscribe(this._cookiePath, lang.hitch(this, "_syncWidgetAndValue"));
            }]]>
        </CodeText>
        <CodeText segment="#postCreate">
          <![CDATA[
            //alert(Plugin().getUserName());
            
            if (this.tile != null && this.tile._scriptEventRef != null) {
                this._name = "[" + this.tile.modelName + "][" + this.tile._scriptEventRef.path.join("][") + this.tile._scriptEventRef.name + "]";
            }
            
            var self = this;
            if (this._model != null) {
                this._setUpViews(function() {
                    self._populateCategories(null);
                    self._completeSetUp();
                });
            }
            else {
                this._showMessages([{
                    type : "error",
                    message : "Dimension Filter not configured."
                }]);
            }]]>
        </CodeText>
        <CodeText segment="#destroy">
          <![CDATA[            if (this._syncTopicHandle != null) {
                this._syncTopicHandle.remove();
                delete this._syncTopicHandle;
            }
            for (var i=0; i<this._controls.length; i++) {
                var ctrl = this._controls[i];
                for (var j=0; j<ctrl.dimensions.length; j++) {
                    var dim = ctrl.dimensions[j];
                    if (dim.widget && dim.widget.destroy) {
                        dim.widget.destroy();
                    }
                }
            }]]>
        </CodeText>
        <CodeText segment="#onSwitchIn">
          <![CDATA[            this._active = true;

            if (this.tile != null) {
            	this.tile.updateUIEvent([{
                    "__TYPE__" : "onSwitchIn",
                    "__EVENT__" : {
                        "properties" : this.initialConfig.properties,
                        "tile" : {
                            "name" : this.tile.modelName,
                            "title" : this.tile.modelTitle
                        }
                    }
                }]);
            }
            
            if (this._outputSelectionOnSwitchIn == true) {
                delete this._outputSelectionOnSwitchIn;
                
                var self = this;
                window.setTimeout(function() {
                    self._enableDimensionControls();
                    self._displayDimensionControls();
                    self._displayCategorySubcategory();
                    self._outputSelection(false, "switch");
                }, 20);
            }]]>
        </CodeText>
        <CodeText segment="#onSwitchOut">
          <![CDATA[            this._active = false;
            
            if (this.tile != null) {
            	this.tile.updateUIEvent([{
                    "__TYPE__" : "onSwitchOut",
                    "__EVENT__" : {
                        "properties" : this.initialConfig.properties,
                        "tile" : {
                            "name" : this.tile.modelName,
                            "title" : this.tile.modelTitle
                        }
                    }
                }]);
            }]]>
        </CodeText>
        <CodeText segment="#methods">
          <![CDATA[
        _areAllWidgetClazzLoaded : function() {
            var ok = true;
            for (var i=0; i<this._customWidgetPaths.length; i++) {
                var widgetPath = this._customWidgetPaths[i];
                if (this._customWidgetClazz[widgetPath] == null) {
                    console.debug("Custom widget load pending for " + widgetPath);
                    ok = false;
                }
            }
            return ok;
        },

        _areAllWidgetsCreated : function() {
            var ok = true;
            for (var i=0; i<this._controls.length; i++) {
                var control = this._controls[i];
                for (var j=0; j<control.dimensions.length; j++) {
                    var dimension = control.dimensions[j];
                    if (dimension.widget == null) {
                        console.debug(this._name + " pending on " + control.name + "." + dimension.name);
                        ok = false;
                    }
                }
            }
            return ok;
        },

        _clearAllValues : function() {
            for (var i=0; i<this._controls.length; i++) {
                var control = this._controls[i];
                control.values = {};
                control.lastSetValues = {};
            }
        },

        _applyValueChanges : function(values, retryCount) {
            var self = this;
            if (values == null) return;
            if (!this._areAllWidgetClazzLoaded() && !this._areAllWidgetsCreated() && retryCount > 0) {
                window.setTimeout(function() {
                    self._applyValueChanges(values, retryCount-1);
                }, 100);
                return;
            }
            var ALWAYS_RESET = true;
            var valueChangeList = [];
            // UI-344
            this._hasFilter = false;
            for (var i=0; i<this._controls.length; i++) {
                var control = this._controls[i];
                if (control.lastSetValues == null) control.lastSetValues = {};
                for (var j=0; j<control.dimensions.length; j++) {
                    var dimension = control.dimensions[j];
                    var value = values[control.name+"."+dimension.name];
                    if (value != null) {
                        value = parseValue(dimension, value);
                        valueChangeList.push({
                            control   : control,
                            dimension : dimension,
                            index     : j,
                            value     : value,
                        });
                        control.lastSetValues[dimension.name] = value;
                        // UI-344
                        if (control.toggleHighlight && value.length > 0) {
                            this._hasFilter = true;
                        }
                    }
                    else if (ALWAYS_RESET) {
                        valueChangeList.push({
                            control   : control,
                            dimension : dimension,
                            index     : j,
                            value     : null,
                        });
                    }
                }
                DEBUG(this._name + " " + control.name + "/lastSetValues=" + JSON.stringify(control.lastSetValues));
            }
            // UI-344
            var highlightEl = this.tile.domNode.querySelector(".click-to-open-link");
            if (highlightEl) {
                if (this._hasFilter == true) {
                    domClass.add(highlightEl, "highlight");
                }
                else {
                    domClass.remove(highlightEl, "highlight");
                }
            }
            if (valueChangeList.length > 0) {
                self._INIT_ = true;
                applyChangeList(this, 0, valueChangeList, function() {
                    for (var i=0; i<self._controls.length; i++) {
                        var control = self._controls[i];
                        delete control.lastSetValues;
                        if (self._saveCookie) {
                            setCookie(self._cookiePath, control.name, control.values);
                        }
                    }
                    if (self._active == false) {
                        // widget is alive but switched out
                        // mark so that when switched back in, outputSelection
                        self._outputSelectionOnSwitchIn = true;
                    }
                    else {
                    	self._outputSelection(false, "notify");
                    }
                    delete self._INIT_;
                });
            }
        },

        _showMessages : function(items) {
            this._messageTable = domConstruct.create("table", {
                "class" : "message-table",
                "style" : "width:100%;",
            });
            for (var i=0; i<items.length; i++) {
                var item = items[i];
                var tr = domConstruct.create("tr", {
                    "class" : "message-row",
                });
                this._messageTable.appendChild(tr);
                var td;
                switch (item.type) {
                    case "error":
                        td = domConstruct.create("td", {
                            "class" : "error-td",
                            "style" : "width:80px;",
                        })
                        td.innerHTML = "Error";
                        tr.appendChild(td);
                        break;
                    case "warning":
                        td = domConstruct.create("td", {
                            "class" : "message-td",
                            "style" : "width:80px;",
                        })
                        td.innerHTML = "Warning";
                        tr.appendChild(td);
                        break;
                }
                td = domConstruct.create("td", {
                    "class" : "message-td",
                    "style" : "width:100%;white-space:normal;",
                })
                td.innerHTML = item.message;
                tr.appendChild(td);
            }
            this.domNode.appendChild(this._messageTable);
        },

        _setUpViews : function(callback) {
            this._setupInProgress = true;
            
            if (this._messageTable != null) {
                this.domNode.removeChild(this._messageTable);
                delete this._messageTable;
            }
            if (this._clickToOpenDiv != null) {
                this.domNode.removeChild(this._clickToOpenDiv);
                delete this._clickToOpenDiv;
            }
            if (this._okCancelDiv != null) {
                this.domNode.removeChild(this._okCancelDiv);
                delete this._okCancelDiv;
            }
            if (this._mainDiv != null) {
                this.domNode.removeChild(this._mainDiv);
                delete this._mainDiv;
            }
                
            this._listOfDimensionsChanged = [];
            if (this.initialConfig.properties.minimizedMode == true) {
                this._setUpClickToOpenControl();
                this._setUpOkCancelControl();
                this._mainDiv = domConstruct.create("div", {
                    "class" : "main-div-minimized via-scroller",
                    "style" : "overflow:hidden;visibility:hidden;" + (this._model["div-style"] || ""),
                });
                this.domNode.appendChild(this._mainDiv);
            }
            else {
                this._mainDiv = domConstruct.create("div", {
                    "class" : "main-div-inline",
                    "style" : "overflow:auto;visibility:visible;" + (this._model["div-style"] || ""),
                });
                this.domNode.appendChild(this._mainDiv);
            }
            this._applyTypeMixins();
            if (this._model.categories != null) {
                for (var i=0; i<this._model.categories.length; i++) {
                    var category = this._model.categories[i];
                    if (category.subcategories != null) {
                        for (var j=0; j<category.subcategories.length; j++) {
                            var subcategory = category.subcategories[j];
                            for (var k=0; k<subcategory.dimensions.length; k++) {
                                var dimension = subcategory.dimensions[k];
                                if (dimension.type == "widget" && dimension["widget-path"] != null) {
                                    if (this._customWidgetPaths.indexOf(dimension["widget-path"]) == -1) {
                                        this._customWidgetPaths.push(dimension["widget-path"]);
                                    }
                                }
                                else if (dimension.type == "popup" && dimension.dialog != null && dimension.dialog.widget != null && dimension.dialog.widget.path != null) {
                                    if (this._customWidgetPaths.indexOf(dimension.dialog.widget.path) == -1) {
                                        this._customWidgetPaths.push(dimension.dialog.widget.path);
                                    }
                                }
                            }
                        }
                    }
                    else {
                        for (var k=0; k<category.dimensions.length; k++) {
                            var dimension = category.dimensions[k];
                            if (dimension.type == "widget" && dimension["widget-path"] != null) {
                                if (this._customWidgetPaths.indexOf(dimension["widget-path"]) == -1) {
                                    this._customWidgetPaths.push(dimension["widget-path"]);
                                }
                            }
                            else if (dimension.type == "popup" && dimension.dialog != null && dimension.dialog.widget != null && dimension.dialog.widget.path != null) {
                                if (this._customWidgetPaths.indexOf(dimension.dialog.widget.path) == -1) {
                                    this._customWidgetPaths.push(dimension.dialog.widget.path);
                                }
                            }
                        }
                    }
                }
            }
            var widgetPaths = this._customWidgetPaths.slice(0);
            this._preloadCustomWidgets(widgetPaths, callback);
        },

        _applyTypeMixins : function() {
            if (this._model["type-mixins"] != null && this._model.categories != null) {
                for (var i=0; i<this._model.categories.length; i++) {
                    var category = this._model.categories[i];
                    if (category.subcategories != null) {
                        for (var j=0; j<category.subcategories.length; j++) {
                            var subcategory = category.subcategories[j];
                            for (var k=0; k<subcategory.dimensions.length; k++) {
                                var dimension = subcategory.dimensions[k];
                                var mixin = this._model["type-mixins"][dimension.type];
                                if (mixin != null) {
                                    delete dimension.type;
                                    subcategory.dimensions[k] = AppUtil.mixinDeep(lang.clone(mixin), dimension);
                                    this._applyTypeMixinParams(subcategory.dimensions[k]);
                                }
                            }
                        }
                    }
                    else {
                        for (var k=0; k<category.dimensions.length; k++) {
                            var dimension = category.dimensions[k];
                            var mixin = this._model["type-mixins"][dimension.type];
                            if (mixin != null) {
                                delete dimension.type;
                                category.dimensions[k] = AppUtil.mixinDeep(lang.clone(mixin), dimension);
                                this._applyTypeMixinParams(category.dimensions[k]);
                            }
                        }
                    }
                }
            }
        },

        _applyTypeMixinParams : function(dimension) {
            if (dimension["type-params"] != null) {
                for (var path in dimension["type-params"]) {
                    var toks = path.split("/");
                    var elem = dimension;
                    while (toks.length > 1 && elem != null) {
                        elem = elem[toks.shift()];
                    }
                    if (elem != null) {
                        elem[toks.shift()] = dimension["type-params"][path];
                    }
                }
            }
        },

        _preloadCustomWidgets : function(widgetPaths, callback) {
            if (widgetPaths.length == 0) {
                callback();
            }
            else {
                var widgetPath = widgetPaths.shift();
                if (this._customWidgetClazz[widgetPath] != null) {
                    this._preloadCustomWidgets(widgetPaths, callback);
                }
                else {
                    var self = this;
                    loadCustomWidgetClass(widgetPath, function(CustomWidgetClazz) {
                        if (CustomWidgetClazz != null) {
                            if (CustomWidgetClazz.prototype["$getValueAsString"] != null) {
                                self._popupValueAsString[widgetPath] = CustomWidgetClazz.prototype["$getValueAsString"];
                            }
                            self._customWidgetClazz[widgetPath] = CustomWidgetClazz;
                            self._preloadCustomWidgets(widgetPaths, callback);
                        }
                    });
                }
            }
        },
        
        _populateCategories : function(initialDynamicValues) {
            this._controls = [];
            if (this._model.categories != null) {
                for (var i=0; i<this._model.categories.length; i++) {
                    var category = this._model.categories[i];

                    var table = domConstruct.create("table", {
                        "class" : "category-table",
                        "border" : "0",
                        "cellspacing" : "0px",
                        "cellpadding" : "5px",
                        "style" : "width:calc(100% - 10px );" + (category["table-style"] || ""),
                    });
                    this._mainDiv.appendChild(table);
                    
                    if (category.label != null) {
                        addTextRow(table, category.label, "category-label", (category["label-style"] || ""));
                    }

                    if (category.subcategories != null) {
                        for (var j=0; j<category.subcategories.length; j++) {
                            var subcategory = category.subcategories[j];
                            
                            var key = category.name + "." + subcategory.name;
                            var control = {
                                name : key,
                                label : category.label + " / " + (subcategory.label || subcategory.name),
                                layout : subcategory.layout || category.layout || "horizontal",
                                dimensions : [],
                                autoSubmit : (subcategory.submit || category.submit) != "manual",
                                faSubmit : subcategory["fa-submit"] || category["fa-submit"],
                                faLabel : subcategory["fa-label"] || category["fa-label"],
                                faStyle : subcategory["fa-style"] || category["fa-style"],
                                labelPosition : subcategory["label-position"] || category["label-position"],
                                asDrilldownEvent : subcategory["as-drilldown-event"],
                                toggleHighlight : !(subcategory.toggleHighlight == false || category.toggleHighlight == false),
                            };
                            if (category["display"] != null && j == 0) {
                                control["category-node"] = table;
                                control["category-display"] = category["display"];
                            }
                            control.values = this._loadValues(control);
                            if (control.values == null) {
                                control.values = {};
                            }
                            if (control.defaults == null) {
                                control.defaults = {};
                            }
                            this._controls.push(control);
                            
                            var nameStyle = (category["name-style"] || "") + (subcategory["name-style"] || "");
                            var valueStyle = (category["value-style"] || "") + (subcategory["value-style"] || "");
                            
                            var td = addNameValueRow(table, subcategory.label || subcategory.name, null, "subcategory-control-name", nameStyle, "subcategory-control-value", valueStyle);

                            if (subcategory["display"] != null) {
                                control["subcategory-node"] = td.parentNode;
                                control["subcategory-display"] = subcategory["display"];
                            }

                            domClass.add(td, "dimension-filter-subcategory-"+control.name);
                            this._populateDimensions(control, td, subcategory.dimensions, initialDynamicValues);
                        }
                    }
                    else if (category.dimensions != null) {
                        var control = {
                            name : category.name,
                            label : category.label,
                            layout : category.layout || "horizontal",
                            dimensions : [],
                            autoSubmit : category.submit != "manual",
                            faSubmit : category["fa-submit"],
                            faLabel : category["fa-label"],
                            faStyle : category["fa-style"],
                            labelPosition : category["label-position"],
                            asDrilldownEvent : category["as-drilldown-event"],
                            toggleHighlight : !(category.toggleHighlight == false),
                        };
                        if (category["display"] != null) {
                            control["category-node"] = table;
                            control["category-display"] = category["display"];
                        }
                        control.values = this._loadValues(control);
                        if (control.values == null) {
                            control.values = {};
                        }
                        if (control.defaults == null) {
                            control.defaults = {};
                        }
                        this._controls.push(control);

                        var nameStyle = (category["name-style"] || "");
                        var valueStyle = (category["value-style"] || "");

                        var td = addNameValueRow(table, "", null, "category-control-name", nameStyle, "category-control-value", valueStyle);

                        domClass.add(td, "dimension-filter-category-"+control.name);
                        this._populateDimensions(control, td, category.dimensions, initialDynamicValues);
                    }
                }
            }
        },

        _populateDimensions : function(control, parent, dimensions, initialDynamicValues) {
            for (var j=0; j<dimensions.length; j++) {
                var dimension = dimensions[j];
                
                if (initialDynamicValues != null) {
                    var initialDynamicValue = initialDynamicValues[control.name+"."+dimension.name];
                    if (initialDynamicValue != null) {
                        control.values[dimension.name] = initialDynamicValue;
                    }
                }

                var table = null;
                if (control.table != null) {
                    table = control.table;
                }
                else {
                    var span = domConstruct.create("span", {
                        "style" : "padding:3px;" + (dimension["span-style"] || ""),
                    });
                    parent.appendChild(span);
                    
                    table = domConstruct.create("table", {
                        "class" : "dimension-table-"+control.name+"-"+dimension.name,
                        "style" : "display:inline-block;" + (dimension["table-style"] || "")
                    });
                    span.appendChild(table);
                }
                
                var tr2 = null;
                if (dimension.label != null) {
                    var labelPosition = dimension["label-position"] || control.labelPosition;
                    if (labelPosition == null || labelPosition == "top") {
                        var tr1 = domConstruct.create("tr");
                        table.appendChild(tr1);
                        
                        var td1 = domConstruct.create("td", {
                            "style" : "white-space:nowrap;"
                        });
                        tr1.appendChild(td1);
                        
                        td1.innerHTML = dimension.label;
                    }
                    else if (labelPosition == "left") {
                        tr2 = domConstruct.create("tr");
                        table.appendChild(tr2);

                        var td1 = domConstruct.create("td", {
                            "style" : "white-space:nowrap;padding-right:3px;width:1%;"
                        });
                        tr2.appendChild(td1);
                        
                        td1.innerHTML = dimension.label + ":";
                    }
                }
                if (tr2 == null) {
                    tr2 = domConstruct.create("tr");
                    table.appendChild(tr2);
                }
                var td2 = domConstruct.create("td");
                tr2.appendChild(td2);
                
                var dim = lang.clone(dimension);
                dim.parent = td2;
                dim.labelTD = td1;
                
                control.dimensions.push(dim);
            }
            if (!control.autoSubmit) {
                // if not auto submit, add "Apply" button
                var span = domConstruct.create("span", {
                    "style" : "padding:3px;" + (dimension["span-style"] || ""),
                });
                parent.appendChild(span);
                
                var table = domConstruct.create("table", {
                    "style" : "display:inline-block;" + (dimension["table-style"] || "")
                });
                span.appendChild(table);

                var tr2 = domConstruct.create("tr");
                table.appendChild(tr2);

                var td2 = domConstruct.create("td");
                tr2.appendChild(td2);

                var self = this;
                if (control.faSubmit != null) {
                    if (control.faLabel != null && control.faStyle == null) {
                        control.faStyle = "height:44px;";
                    }
                    control.faApply = this._createFontAwesomeButton(td2, "apply-fa", control.faSubmit, control.faLabel, control.faStyle, function(evt) {
                        self._outputSelection(true, "user", control.asDrilldownEvent);
                    });
                }
                else {
                    control.btnApply = FormUtil.createButton(td2, "Apply", null, null, function() {
                        self._outputSelection(true, "user", control.asDrilldownEvent);
                    });
                    domClass.add(control.btnApply.domNode, "apply-button");
                }
            }
            for (var j=0; j<control.dimensions.length; j++) {
                this._updateDimensionControl(control, j, null, null);
            }
        },

        _addDimensionChanged : function(dimensionChanged) {
            if (this._INIT_ == true) return;
            
            if (this._listOfDimensionsChanged != null) {
                var index = this._listOfDimensionsChanged.indexOf(dimensionChanged);
                if (index != -1) {
                    this._listOfDimensionsChanged.splice(index, 1);
                }
                this._listOfDimensionsChanged.push(dimensionChanged);
                if (this._propagateDimensionChangesTimeout != null) {
                    window.clearTimeout(this._propagateDimensionChangesTimeout);
                    delete this._propagateDimensionChangesTimeout;
                }
                this._propagateDimensionChangesTimeout = window.setTimeout(lang.hitch(this, "_propagateDimensionChanges"), 50);
            }
        },

        _propagateDimensionChanges : function() {
            if (this._listOfDimensionsChanged == null || this._listOfDimensionsChanged.length == 0) {
                this._enableDimensionControls();
                this._displayDimensionControls();
                this._displayCategorySubcategory();
                delete this._listOfDimensionsChanged;
            }
            else {
                var dimensionChanged = this._listOfDimensionsChanged.shift();
                var dependents = this._getDependentDimensions(dimensionChanged);
                this._updateDependentDimensions(dependents, dimensionChanged, false);
                this._propagateDimensionChanges();
            }
        },

        _hideTileIfEmpty : function() {
            if (this.controller && this.controller.appController && this.controller.mode != this.controller.appController._EDIT_MODEL) {
                if (this.initialConfig.properties.hideTileIfEmpty == true) {
                    var tileNode = findTileNode(this.domNode);
                    if (tileNode != null) {
                        // found it
                        domStyle.set(tileNode, "display", this._empty ? "none" : "");
                        this.renderer.tile.dashboardLayout.updateWidthAndHeight(this.renderer.tile.dashboardLayout.vtWidth, this.renderer.tile.dashboardLayout.vtHeight, false);
                    }
                }
            }
        },

        _completeSetUp : function() {
            var self = this;
            this._hideTileIfEmpty();
            if (this._empty) {
                delete self._setupInProgress;
                if (self._setupCompleteCallback != null) {
                    var callback = self._setupCompleteCallback;
                    delete self._setupCompleteCallback;
                    window.setTimeout(callback, 50);
                }
                return;
            }

            this._enableDimensionControls();
            this._displayDimensionControls();
            this._displayCategorySubcategory();
            
            if (this._model["tile-node-style"] != null || this._model["maximized-tile-node-style"] != null) {
                // need to find node with "groupBorder tile tileWidgetContainer smallTile" class
                // should be NO MORE than 10 levels up
                var node = this.domNode;
                for (var i=0; i<10; i++) {
                    if (node == null) break;
                    if (domClass.contains(node, "groupBorder") && domClass.contains(node, "tile") && domClass.contains(node, "tileWidgetContainer") && domClass.contains(node, "smallTile")) {
                        // found it
                        this._tileNode = node;
                        var hasBackgroundSettings = false;
                        for (var key in this._model["tile-node-style"]) {
                            switch (key) {
                                case "background":
                                case "background-color":
                                case "background-image":
                                    hasBackgroundSettings = true;
                                    break;
                            }
                        }
                        if (hasBackgroundSettings) {
                            domStyle.set(this._tileNode, "background", "none");
                        }
                        domStyle.set(this._tileNode, this._model["tile-node-style"]);
                        this.renderer.tile.dashboardLayout.updateWidthAndHeight(this.renderer.tile.dashboardLayout.vtWidth, this.renderer.tile.dashboardLayout.vtHeight, false);
                        break;
                    }
                    node = node.parentNode;
                }
            }

            if (this.tile != null) {
            	this.tile.updateUIEvent([{
                    "__TYPE__" : "uiComponentReady",
                    "__EVENT__" : {
                        "properties" : this.initialConfig.properties,
                        "tile" : {
                            "name" : this.tile.modelName,
                            "title" : this.tile.modelTitle
                        }
                    }
                }]);
            }
            
            window.setTimeout(function() {
                self._enableDimensionControls();
                self._displayDimensionControls();
                self._displayCategorySubcategory();
                self._outputSelection(false, "init");
                
                delete self._setupInProgress;
                if (self._setupCompleteCallback != null) {
                    var callback = self._setupCompleteCallback;
                    delete self._setupCompleteCallback;
                    window.setTimeout(callback, 50);
                }
            }, 10);
        },

        _doNotifyWidgets : function(changedDimension) {
            if (this._widgetNotifyEvents != null) {
                for (var i=0; i<this._controls.length; i++) {
                    var control = this._controls[i];
                    for (var j=0; j<control.dimensions.length; j++) {
                        var dimension = control.dimensions[j];
                        var dimName = control.name + "." + dimension.name;
                        if (changedDimension == null || changedDimension == dimName) {
                            var dimEvt = this._widgetNotifyEvents[dimName];
                            if (dimEvt != null && dimension.widget != null) {
                                dimension.widget.onNotify(dimEvt);
                            }
                        }
                    }
                }
            }
        },

        _setUpClickToOpenControl : function() {
            var self = this;

            this._clickToOpenDiv = domConstruct.create("div", {
                "class" : "click-to-open-div",
                "style" : ""
            });
            this.domNode.appendChild(this._clickToOpenDiv);
            
            if (!this._empty) {
                function isHTML(str)
                {
                    str = str.trim();
                    return str.charAt(0) == "<" && str.charAt(str.length-1) == ">";
                }
                if (isHTML(this._clickToOpenHTML)) {
                    this._clickToOpen = domConstruct.create("span", {
                        "class" : "click-to-open-link",
                    });
                }
                else {
                    this._clickToOpen = domConstruct.create("div", {
                        "class" : "click-to-open-link",
                    });
                }
                this._clickToOpen.innerHTML = this._clickToOpenHTML;
                this._clickToOpenDiv.appendChild(this._clickToOpen);
                
                if (this.tile != null) {
                    on(this._clickToOpen, "click", lang.hitch(this, "_doOpenFilterPanel"));
                }
                
                if (this._clickForSummaryHTML != "") {
                    if (isHTML(this._clickForSummaryHTML)) {
                        this._clickForSummary = domConstruct.create("span", {
                            "class" : "click-for-summary-link",
                        });
                    }
                    else {
                        this._clickForSummary = domConstruct.create("div", {
                            "class" : "click-for-summary-link",
                        });
                    }
                    this._clickForSummary.innerHTML = this._clickForSummaryHTML;
                    this._clickToOpenDiv.appendChild(this._clickForSummary);
                    
                    on(this._clickForSummary, "click", lang.hitch(this, "_onClickShowSummary"));
                }
            }
        },

        _setUpOkCancelControl : function() {
            var self = this;

            this._okCancelDiv = domConstruct.create("div", {
                "class" : "ok-cancel-div",
                "style" : ""
            });
            this.domNode.appendChild(this._okCancelDiv);
            
            this._okSpan = domConstruct.create("span");
            this._okCancelDiv.appendChild(this._okSpan);
            FormUtil.createButton(this._okSpan, "Apply", null, null, function() {
                self._doCloseFilterPanel(true);
                setTimeout(function() {
                    self._outputSelection(true, "user");
                    self._enableDimensionControls();
                    self._displayDimensionControls();
                    self._displayCategorySubcategory();
                }, 10);
            });
            
            this._cancelSpan = domConstruct.create("span");
            this._okCancelDiv.appendChild(this._cancelSpan);
            FormUtil.createButton(this._cancelSpan, "Cancel", null, null, function() {
                self._doCloseFilterPanel(false);
                self._enableDimensionControls();
                self._displayDimensionControls();
                self._displayCategorySubcategory();
            });
            
            domStyle.set(this._okCancelDiv, "display", "none");
        },

        _doOpenFilterPanel : function() {
            if (this.tile != null && this.tile.maxStatus == false) {
                this._oldControlValues = {};
            	this._oldWidgetValues = {};
            	this._oldWidgetOptions = {};
                for (var i=0; i<this._controls.length; i++) {
                    var control = this._controls[i];
                    for (var j=0; j<control.dimensions.length; j++) {
                    	var dimension = control.dimensions[j];
                    	this._oldControlValues[control.name+"."+dimension.name] = control.values[dimension.name];
                    	if (dimension.widget != null) {
                    		this._oldWidgetValues[control.name+"."+dimension.name] = dimension.widget.get("value");
                    	}
                    	if (dimension._options != null) {
                    		this._oldWidgetOptions[control.name+"."+dimension.name] = dimension._options;
                    	}
                    }
                }
                if (this._tempSelection != null) {
                    // UI-116: if _tempSelection is _not_ null, we have temp changes inherited from external control
                    this._syncWidgetAndValue(null, lang.clone(this._tempSelection), false);
                }
                domStyle.set(this._mainDiv, {
                    "overflow" : "auto",
                    "visibility" : "visible",
                });
                domStyle.set(this._clickToOpenDiv, "display", "none");
                domStyle.set(this._okCancelDiv, "display", "");
                this.tile._onMaxTile();
                this._enableDimensionControls();
                this._displayDimensionControls();
                this._displayCategorySubcategory();
                this._opened = true;
                
                // on maximize, check for custom styling
                // else background might be translucent and stuff behind will show thru
                if (this._tileNode != null && this._model["maximized-tile-node-style"] != null) {
                    domStyle.set(this._tileNode, this._model["maximized-tile-node-style"]);
                    this.renderer.tile.dashboardLayout.updateWidthAndHeight(this.renderer.tile.dashboardLayout.vtWidth, this.renderer.tile.dashboardLayout.vtHeight, false);
                }
            }
        },
        
        _doCloseFilterPanel : function(ok) {
        	if (!ok && this._oldWidgetValues != null) {
                for (var i=0; i<this._controls.length; i++) {
                    var control = this._controls[i];
                    for (var j=0; j<control.dimensions.length; j++) {
                    	var dimension = control.dimensions[j];
                    	if (this._oldControlValues[control.name+"."+dimension.name] != null) {
                    	    // on cancel... reset values on widget and control back to what is was
                    		control.values[dimension.name] = this._oldControlValues[control.name+"."+dimension.name];
                    	}
                    	if (dimension.widget != null && this._oldWidgetOptions[control.name+"."+dimension.name] != null) {
                    	    dimension._options = this._oldWidgetOptions[control.name+"."+dimension.name];
                    	    switch (dimension.type) {
                	        	case "enumeration":
                	        	    dimension.widget.removeOption(dimension.widget.getOptions());
                	        	    dimension.widget.addOption(lang.clone(dimension._options));
                	        	    //dimension.widget.set("value", this._oldWidgetValues[control.name+"."+dimension.name], false);
                	        		break;
                	        	case "choice":
                	        	    var options = [];
                	        	    for (var k=0; k<dimension._options.length; k++) {
                	        	        // UI-324
                	        	        var choice = dimension._options[k];
                                        if (choice.isGroupLabel == true) {
                                            options.push({
                                                id           : generateRandomUuid(),
                                                label        : choice.label,
                                                isGroupLabel : true,
                                            });
                                        }
                                        else {
                    	        	        options.push({
                    	        	            id    : choice.value,
                    	        	            label : choice.label,
                    	        	        });
                                        }
                	        	    }
                	        	    dimension.widget.updateOptions(options);
                	        	    //dimension.widget.set("value", this._oldWidgetValues[control.name+"."+dimension.name], false);
                	        		break;
                    	    }
                    	}
                    	if (dimension.widget != null && this._oldWidgetValues[control.name+"."+dimension.name] != null) {
                    	    // on cancel... reset values on widget and control back to what is was
                    		dimension.widget.set("value", this._oldWidgetValues[control.name+"."+dimension.name], false);
                            if (dimension.type == 'choice' && dimension.widget._dispatchEvt) {
                                dimension.widget._dispatchEvt(true);
                            }
                    	}
                    }
                }
        	}
        	// UI-116: delete temp selection if we apply
        	if (ok) delete this._tempSelection;
        	delete this._oldControlValues;
        	delete this._oldWidgetValues;
        	delete this._oldWidgetOptions;
        	domStyle.set(this._mainDiv, {
                "overflow" : "hidden",
                "visibility" : "hidden",
            });
        	this.domNode.scrollTop = 0;
            domStyle.set(this._clickToOpenDiv, "display", "");
            domStyle.set(this._okCancelDiv, "display", "none");
            if (this.tile != null) {
                this.tile._onMaxTile();
            }
            this._opened = false;
            
            // on restore to regular size, if we have styled background, re-apply
            if (this._tileNode != null && this._model["tile-node-style"] != null) {
                domStyle.set(this._tileNode, this._model["tile-node-style"]);
                this.renderer.tile.dashboardLayout.updateWidthAndHeight(this.renderer.tile.dashboardLayout.vtWidth, this.renderer.tile.dashboardLayout.vtHeight, false);
            }
            
            // UI-236: clear values from hidden category and subcategory on OK so that those filter values
            //         don't show in summary AND are not in output
            if (ok) {
                this._controls.filter(function(control){
                    if (control["category-node"] != null && control["category-display"] != null) {
                        var show = doEvalConditional(this._scriptFuncs, control.name + ":category-display", control["category-display"], this._getSelection(false));
                        return !show;
                    }
                    else if (control["subcategory-node"] != null && control["subcategory-display"] != null) {
                        var show = doEvalConditional(this._scriptFuncs, control.name + ":subcategory-display", control["subcategory-display"], this._getSelection(false));
                        return !show;
                    }
                }, this).forEach(function(control){
                    control.dimensions.forEach(function(dimension){
                        if (dimension.value)
                            dimension.value = null;
                        if (control.values[dimension.name])
                            control.values[dimension.name] = null;
                    });
                });
                this._hasFilter = false;
                var self = this;
                array.forEach(this._controls, function(control){
                    Object.keys(control.values).forEach(function(key){
                        if (control.toggleHighlight && control.values[key] != null && control.values[key].length > 0) {
                            self._hasFilter = true;
                        }
                    });
                });
            }
            // UI-344
            var highlightEl = this.tile.domNode.querySelector(".click-to-open-link");
            if (highlightEl) {
                if (this._hasFilter == true) {
                    domClass.add(highlightEl, "highlight");
                }
                else {
                    domClass.remove(highlightEl, "highlight");
                }
            }
        },
        
        _onClickShowSummary : function() {
            var self = this;
            var NOT_SET = false;
            require(["af/controls/MaximizableAppDialog", "af/controls/ButtonMode", "dojo/domReady!"], function(PopupDialogClazz, ButtonMode) {
                var controlDivs = [];
                var dimensionCount = 0;
                for (var i=0; i<self._controls.length; i++) {
                    var control = self._controls[i];
                    var controlDiv = null;
                    var dimensionTable = null;
                    for (var j=0; j<control.dimensions.length; j++) {
                        var dimension = control.dimensions[j];
                        var value = control.values[dimension.name] || dimension.value;
                        var valueStyle = "";
                        if (value != null && value != "" && value.length != 0) {
                            if (dimension._getValueAsString != null && typeof dimension._getValueAsString == "function") {
                                value = dimension._getValueAsString(value, dimension);
                            }
                            else if (Array.isArray(value)) {
                                if (dimension._options != null) {
                                    var labels = [];
                                    for (var k=0; k<value.length; k++) {
                                        var label = null;
                                        for (var o=0; o<dimension._options.length; o++) {
                                            if (dimension._options[o]["value"] == value[k]) {
                                                label = dimension._options[o]["label"];
                                                break;
                                            }
                                        }
                                        if (label == null) {
                                            label = value[k];
                                        }
                                        labels.push(label);
                                    }
                                    value = labels;
                                }
                                value = value.slice(0);
                                value.sort();
                                var uniq = value.filter(function(item, index){
                                	return value.indexOf(item) >= index;
                                });
                                value = uniq.join(", ");
                            }
                            else if (typeof value == "string") {
                                if (dimension._options != null) {
                                    for (var o=0; o<dimension._options.length; o++) {
                                        if (dimension._options[o]["value"] == value) {
                                            value = dimension._options[o]["label"];
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        else {
                            value = "(not set)";
                            valueStyle = "color:gray;font-style:italic;"
                        }
                        if (NOT_SET || value != "(not set)") {
                            if (controlDiv == null && dimensionTable == null) {
                                controlDiv = domConstruct.create("div", {
                                    style : "width:calc(100% - 10px);padding:5px;"
                                });
                                controlDivs.push(controlDiv);
                                var controlTitle = domConstruct.create("div", {
                                    style : "font-size:18px;font-weight:bold;"
                                });
                                controlTitle.innerHTML = control.label;
                                controlDiv.appendChild(controlTitle);
                                dimensionTable = domConstruct.create("table", {
                                    style : "padding-top:5px;padding-left:20px;"
                                });
                                controlDiv.appendChild(dimensionTable);
                            }
                            var dimensionRow = domConstruct.create("tr", {
                            });
                            dimensionTable.appendChild(dimensionRow);
                            var dimensionLabel = domConstruct.create("td", {
                                style : "width:1%;white-space:nowrap;padding:5px;text-align:right;vertical-align:top;font-style:italic;"
                            });
                            dimensionLabel.innerHTML = dimension.label + ":";
                            dimensionRow.appendChild(dimensionLabel);
                            var dimensionValue = domConstruct.create("td", {
                                style : "width:99%;padding:5px;vertical-align:top;" + valueStyle
                            });
                            dimensionValue.innerHTML = value;
                            dimensionRow.appendChild(dimensionValue);
                            dimensionCount++;
                        }
                    }
                }
                if (controlDivs.length > 0) {
                    var W = 800;
                    var H = 65 + (controlDivs.length * 40) + (dimensionCount * 30);
                    if (H < 300) {
                        H = 300;
                    }
                    else if (H > 600) {
                        H = 600;
                    }
                    var dialog = new PopupDialogClazz({
                        title    : "Filter Summary",
                        vtWidth  : W,
                        vtHeight : H,
                    });
                    dialog.showTitle = true;
                    dialog.buttonMode = ButtonMode.YES;
                    dialog.set("okLabel", I18N.getString("af.frame", "Close"));
                    dialog.setOkButtonEnable(true);
                    dialog.okHandler = function() {
                        this.hide();
                    };
                    dialog.show();
                    
                    domClass.add(dialog.containerNode, "via-scroller dimension-filter-summary-div");
                    domStyle.set(dialog.containerNode, {
                        "height"     : "100%",
                        "overflow-y" : "auto"
                    });
                    for (var i=0; i<controlDivs.length; i++) {
                        dialog.containerNode.appendChild(controlDivs[i]);
                    }
                }
            });
        },
        
        _getDimensionDefault : function(control, dimension) {
            var defaultValue = null;
            if (control.defaults[dimension.name] != null && String(control.defaults[dimension.name]) != "") {
            	defaultValue = control.defaults[dimension.name];
            }
            if (defaultValue == null) {
                defaultValue = dimension["default"];
            }
        	switch (getDimensionDataType(dimension)) {
	        	case "boolean":
	        		return defaultValue == true
	        	
                case "string":
                case "text":
	        		return defaultValue || "";

	        	case "enumeration":
	        	    if (defaultValue != null && Array.isArray(defaultValue)) {
	        	        if (defaultValue.length == 1) {
	        	            defaultValue = defaultValue[0];
	        	        }
	        	        else {
	        	            defaultValue = null;
	        	        }
	        	    }
	        		return defaultValue || [];

	        	case "choice":
	        		return defaultValue || [];

                case "date":
                case "time":
                case "datetime":
	        	case "timestamp":
	        	    // see https://www.w3schools.com/js/js_dates.asp for more detail
        			var value = null;
        			if (defaultValue != null && defaultValue != "") {
        			    value = parseDateValue(defaultValue);
        			}
        			return value;
                case "timeinterval":
                    var value = null;
                    if (defaultValue != null && defaultValue != "") {
                        value = parseTimeInterval(defaultValue);
                    }
                    return value;
                case "timeinterval/absolute":
                    var value = null;
                    if (defaultValue != null && defaultValue != "") {
                        value = parseAbsoluteTimeInterval(defaultValue);
                    }
                    return value;
                case "timeinterval/relative":
                    var value = null;
                    if (defaultValue != null && defaultValue != "") {
                        value = parseRelativeTimeInterval(defaultValue);
                    }
                    return value;
                case "timeinterval/timeslice":
                    var value = null;
                    if (defaultValue != null && defaultValue != "") {
                        value = parseTimeSliceInterval(defaultValue);
                    }
                    return value;
        	}
        	return defaultValue;
        },

        _getDimensionOptions : function(control, dimension, callback) {
            function asOptionArray(list) {
                if (list != null && list.length > 0) {
                    var option = list[0];
                    if (typeof option == "string") {
                        // assume all same... array of string
                        var options = [];
                        array.forEach(list, function(item, index) {
                            options.push({ value:item, label:item });
                        });
                        return options;
                    }
                    // assume we are OK
                    return list;
                }
            }
            function mergeOptionValues(enums, sep)
            {
                var labels = {};
                var merged = [];
                for (var i=0; i<enums.length; i++) {
                    var label = enums[i]["label"];
                    var option = labels[label];
                    if (option == null) {
                        option = lang.clone(enums[i]);
                        labels[label] = option;
                        merged.push(option);
                    }
                    else {
                        if (typeof option.value == "string") {
                            option.value = [option.value];
                        }
                        option.value.push(enums[i]["value"]);
                    }
                }
                for (var i=0; i<merged.length; i++) {
                    var value = merged[i]["value"];
                    if (Array.isArray(value)) {
                        value.sort();
                        merged[i]["value"] = value.join(sep);
                    }
                }
                return merged;
            }
		    var self = this;
        	switch (dimension.type) {
	        	case "enumeration":
	        	case "choice":
	        		if (dimension.query != null) {
	        		    if (this._model.connection.url.indexOf("sql://") == 0) {
	        		        if (this.controller._scriptManager != null) {
	                            this.controller._scriptManager._axFlow.getConnInfo(this._model.connection.url, function(connInfo) {
	                                getOptionsFromSQL(self._scriptFuncs, connInfo, control, dimension, this._getSelection(false), function(enums) {
	                                    if (dimension.type == "enumeration" && dimension["none"] != false && dimension["fontAwesomeBar"] != true) {
	                                        enums = [{value:"#none#", label:"- Select -"}].concat(enums);
	                                    }
                                        if (dimension.allowDuplicateLabels != true) {
                                            enums = mergeOptionValues(enums, self.OPTION_VALUE_SEP);
                                        }
	                                    callback(enums);
	                                });
	                            });
	        		        }
	        		        else {
	        		            var enums = [];
                                if (dimension.type == "enumeration" && dimension["none"] != false && dimension["fontAwesomeBar"] != true) {
                                    enums = [{value:"#none#", label:"- Select -"}].concat(enums);
                                }
	        		            callback(enums);
	        		        }
	        		    }
	        		    else {
	                        getOptionsFromSQL(self._scriptFuncs, this._model.connection, control, dimension, this._getSelection(false), function(enums) {
                                if (dimension.type == "enumeration" && dimension["none"] != false && dimension["fontAwesomeBar"] != true) {
                                    enums = [{value:"#none#", label:"- Select -"}].concat(enums);
                                }
                                if (dimension.allowDuplicateLabels != true) {
                                    enums = mergeOptionValues(enums, self.OPTION_VALUE_SEP);
                                }
	                            callback(enums);
	                        });
	        		    }
	        		}
	        		else if (dimension.service != null) {
                        getOptionsFromService(self._scriptFuncs, control, dimension, this._getSelection(false), self.OPTION_VALUE_SEP, function(enums) {
                            if (dimension.type == "enumeration" && dimension["none"] != false && dimension["fontAwesomeBar"] != true) {
                                enums = [{value:"#none#", label:"- Select -"}].concat(enums);
                            }
                            if (dimension.allowDuplicateLabels != true) {
                                enums = mergeOptionValues(enums, self.OPTION_VALUE_SEP);
                            }
                            callback(enums);
                        });
	        		}
	        		else if (dimension.store != null) {
	        		    // LocalStore... schema required to be value/label
	        		}
	        		else if (dimension.enums != null) {
		        		window.setTimeout(function() {
		        		    var enums = asOptionArray(dimension.enums);
                            if (dimension.type == "enumeration" && dimension["none"] != false) {
                                enums = [{value:"#none#", label:"- Select -"}].concat(enums);
                            }
		        			callback(enums);
		        		}, 1);
	        		}
	        		break;
	        	default:
	        		window.setTimeout(function() {
		        		callback(null);
	        		}, 1);
	        		break;
        	}
        },
        
        _getDimensionValue : function(control, dimension, options) {
            var value = control.values[dimension.name];
            if (value != null) {
                // if NOT null, check that it is STILL valid
                switch (getDimensionDataType(dimension)) {
                    case "boolean":
                        if (value != true && value != false) {
                            value = null;
                        }
                        break;
                    case "string":
                    case "text":
                        if (typeof value != "string") {
                            value = null;
                        }
                        break;
                    case "enumeration":
                        if (value != null && Array.isArray(value)) {
                            if (value.length == 1) {
                                value = value[0];
                            }
                            else {
                                value = null;
                            }
                        }
                        // validate IFF we have options to validate against... else accept as-is
                        if (value != null && options != null) {
                            var optValue = isValidOption(options, value, this.OPTION_VALUE_SEP);
                            if (optValue != null) {
                                value = optValue;
                            }
                            else {
                                value = null;
                            }
                        }
                        break;
                    case "choice":
                        // validate IFF we have options to validate against... else accept as-is
                        if (options != null) {
                            if (typeof value == "string") {
                                value = value.split(",");
                            }
                            // else assume value should be array
                            var goodValues = [];
                            for (var i=0; i<value.length; i++) {
                                var optValue = isValidOption(options, value[i], this.OPTION_VALUE_SEP);
                                if (optValue != null) {
                                    goodValues.push(optValue);
                                }
                            }
                            value = goodValues;
                        }
                        break;
                    case "date":
                    case "time":
                    case "datetime":
                    case "timestamp":
                        // if value is string, try parsing to Date
                        if (typeof value == "string") {
                            value = parseDateValue(value);
                        }
                        // expect to be a Date object
                        if (!(value instanceof Date)) {
                            value = null;
                        }
                        break;
                    case "timeinterval":
                    case "timeinterval/absolute":
                        // string of form "2017-07-20T01:00:00.000-07:00/2017-07-20T02:00:00.000-07:00"
                        if (typeof value != "string") {
                            value = null;
                        }
                        else if (value.indexOf("predefined:") != 0 && value.indexOf("absolute:") != 0) {
                            var toks = value.split("/");
                            if (toks.length != 2) {
                                value = null;
                            }
                        }
                        break;
                    case "timeinterval/relative":
                        // string of form "P#U/2017-07-20T02:00:00.000-07:00"
                        // string of form "2017-07-20T02:00:00.000-07:00/P#U"
                        if (typeof value != "string") {
                            value = null;
                        }
                        else {
                            var toks = value.split("/");
                            if (toks.length != 2) {
                                value = null;
                            }
                            else if ((toks[0]).charAt(0) != "P" && (toks[1]).charAt(0) != "P") {
                                value = null;
                            }
                        }
                        break;
                    case "timeinterval/timeslice":
                        // string of form "S#U/2017-07-20T02:00:00.000-07:00"
                        if (typeof value != "string") {
                            value = null;
                        }
                        else {
                            var toks = value.split("/");
                            if (toks.length != 2) {
                                value = null;
                            }
                            else if ((toks[0]).charAt(0) != "S") {
                                value = null;
                            }
                        }
                        break;
                }
            }
            return value;
        },

        _createDimensionControl : function(control, dimension, options, value, callback) {
            
        	dimension.span = domConstruct.create("span");
            dimension.parent.appendChild(dimension.span);
            
        	var widget = null;
        	switch (dimension.type) {
	        	case "boolean":
	        	    widget = FormUtil.createCheckBox(dimension.name || dimension.label, dimension.span, value, dimension.tooltip, callback);
	        	    if (value != null) {
	        	        this._addDimensionChanged(control.name + "." + dimension.name);
	        	    }
	        		break;
                case "string":
                    var style = (dimension.style || "");
                    widget = FormUtil.createTextBox(dimension.name || dimension.label, dimension.span, value, style, dimension.tooltip, false, callback);
                    if (dimension.placeholder != null) {
                        widget.set("placeholder", dimension.placeholder);
                    }
                    domClass.add(widget.domNode, "string-control");
	        	    if (value != null && value != "") {
	        	        this._addDimensionChanged(control.name + "." + dimension.name);
	        	    }
                    break;
                case "text":
                    var style = (dimension.style || "");
                	widget = FormUtil.createTextArea(dimension.name || dimension.label, dimension.span, value, style, true, dimension.tooltip, callback);
                    if (dimension.placeholder != null) {
                        widget.set("placeholder", dimension.placeholder);
                    }
                    domClass.add(widget.domNode, "string-control");
	        	    if (value != null && value != "") {
	        	        this._addDimensionChanged(control.name + "." + dimension.name);
	        	    }
                    break;
	        	case "enumeration":
	        	    if (dimension["fa-control"] == true) {
    	        		var style = (dimension["fa-style"] || "");
    	                widget = this._createFontAwesomeBar(dimension.name || dimension.label, dimension.span, options, value, style, dimension.tooltip, dimension, callback);
    	                if (widget != null) {
        	                domClass.add(widget.domNode, "enumeration-fa-bar-control");
        	                if (options.length == 0 || (options.length == 1 && options[0]["value"] == "#none#")) {
            	                domClass.add(widget.domNode, "is-empty");
        	                }
    	                }
	        	    }
	        	    else {
    	        	    if (dimension["none"] != false) {
    	                    if (value == null || value == "") value = "#none#";
    	        	    }
    	        		var style = (dimension["style"] || "");
    	                widget = FormUtil.createSingleSelect(dimension.name || dimension.label, dimension.span, options, value, style, dimension.tooltip, callback);
    	                domClass.add(widget.domNode, "enumeration-control");
	        	    }
	        	    if (value != null && value != "") {
	        	        this._addDimensionChanged(control.name + "." + dimension.name);
	        	    }
	        		break;
	        	case "choice":
	        	    if (dimension["fa-control"] == true) {
    	        		var style = (dimension["fa-style"] || "");
    	                widget = this._createFontAwesomeBar(dimension.name || dimension.label, dimension.span, options, value, style, dimension.tooltip, dimension, callback);
    	                if (widget != null) {
        	                domClass.add(widget.domNode, "choice-fa-bar-control");
        	                if (options.length == 0) {
            	                domClass.add(widget.domNode, "is-empty");
        	                }
    	                }
	        	    }
	        	    else {
    	        		var style = (dimension["style"] || "");
    	        		if (value != null && Array.isArray(value)) {
    	        		    value = value.join(",");
    	        		}
    	                widget = FormUtil_createMultiSelect(dimension.name || dimension.label, dimension.span, options, value, style, dimension.tooltip, callback);
                        domClass.add(widget.domNode, "choice-control");
                        aspect.after(widget, "openDropDown", function(o){
                            if (widget.dropDown) {
                                domClass.add(widget.dropDown.domNode.parentNode, "via-scroller");
                            }
                        }, true);
	        	    }
	        	    if (value != null && value.length > 0) {
	        	        this._addDimensionChanged(control.name + "." + dimension.name);
	        	    }
	        		break;
                case "date":
                    var style = (dimension.style || "");
                    widget = FormUtil.createDateTextBox(dimension.name || dimension.label, dimension.span, value, style, dimension.tooltip, callback);
                    domClass.add(widget.domNode, "date-control");
	        	    if (value != null) {
	        	        this._addDimensionChanged(control.name + "." + dimension.name);
	        	    }
                    break;
                case "time":
                    var style = (dimension.style || "");
                    widget = FormUtil.createTimeTextBox(dimension.name || dimension.label, dimension.span, value, style, dimension.tooltip, callback);
                    domClass.add(widget.domNode, "time-control");
	        	    if (value != null) {
	        	        this._addDimensionChanged(control.name + "." + dimension.name);
	        	    }
                    break;
                case "datetime":
	        	case "timestamp":
	        		var style = (dimension.style || "");
	        		widget = FormUtil.createDateTimeTextBox(dimension.name || dimension.label, dimension.span, value, style, dimension.tooltip, callback);
                    domClass.add(widget.domNode, "date-time-control");
	        		// don't know why the code in InternalDateTimeTextBox.html set this to 125px
                    domStyle.set(widget.datetimebox, "width", "auto");
	        		domStyle.set(widget.picker, "width", "auto");
	        		// also adjust height
	        		domStyle.set(widget.datetimeBoxDiv, {
	        			"padding-top" : "1px",
	        			"padding-bottom" : "1px",
	        		});
	        	    if (value != null) {
	        	        this._addDimensionChanged(control.name + "." + dimension.name);
	        	    }
	        		break;
	        	case "timeinterval":
	        	case "timeinterval/absolute":
	        	case "timeinterval/relative":
	        	case "timeinterval/timeslice":
	        	    var colon = value.indexOf(":");
	        	    var slash = value.indexOf("/");
	        	    if (value != null && (colon != -1 || slash != -1) && dimension.asLocalTime) {
	        	        // the date/time widget expects GMT time and uses the numeric values so set the controls
	        	        // if we want the control to show the equivalent of local time, we need to adjust the UTC value
	        	        // by the appropriate offset
        	            switch (getDimensionDataType(dimension)) {
            	        	case "timeinterval":
                        		var predefined = colon != -1 ? value.substring(0, colon) == "predefined" : false;
                        		var absolute = colon != -1 ? value.substring(0, colon) == "absolute" : false;
                        		if (!predefined && !absolute) {
                                    var tmp = value.split("/");
                        			if (tmp.length == 2) {
                        				// old format... assume FROM/TO
                                        value = "absolute:" + adjustForLocalTime(tmp[0]) + "/" + adjustForLocalTime(tmp[1]);
                                    }
                                    else {
                                        value = null;
                                    }
                        		}
                        		else if (predefined && slash == -1) {
                        			// predefined:XXX
                    				value = "predefined:" + value.substring(colon+1);
                        		}
                        		else if (absolute && slash != -1) {
                        			// absolute:###/###
                    				value = "absolute:" + adjustForLocalTime(value.substring(colon+1, slash)) + "/" + adjustForLocalTime(value.substring(slash+1));
                        		}
                                else {
                                    value = null;
                                }
            	        	    break;
            	        	case "timeinterval/absolute":
                                var tmp = value.split("/");
                                if (tmp.length == 2) {
                                    value = adjustForLocalTime(tmp[0]) + "/" + adjustForLocalTime(tmp[1]);
                                }
                                else {
                                    value = null;
                                }
            	        	    break;
            	        	case "timeinterval/relative":
                                var tmp = value.split("/");
                                if (tmp.length == 2) {
                	        	    if ((tmp[0]).charAt(0) == "P") {
                                        value = tmp[0] + "/" + adjustForLocalTime(tmp[1]);
                	        	    }
                	        	    else if ((tmp[1]).charAt(0) == "P") {
                                        value = adjustForLocalTime(tmp[0]) + "/" + tmp[1];
                	        	    }
                                    else {
                                        value = null;
                                    }
                                }
                                else {
                                    value = null;
                                }
            	        	    break;
            	        	case "timeinterval/timeslice":
                                var tmp = value.split("/");
                                if (tmp.length == 2) {
                	        	    if ((tmp[0]).charAt(0) == "S") {
                                        value = tmp[0] + "/" + adjustForLocalTime(tmp[1]);
                	        	    }
                                    else {
                                        value = null;
                                    }
                                }
                                else {
                                    value = null;
                                }
            	        	    break;
        	            }
	        	    }
                    var style = (dimension.style || "");
                    widget = createTimeIntervalTextBox(dimension.name || dimension.label, dimension.span, value, style, dimension.tooltip, dimension, callback);
                    domClass.add(widget.domNode, "time-interval-control");
	        	    if (value != null) {
	        	        this._addDimensionChanged(control.name + "." + dimension.name);
	        	    }
	        	    break;
	        	case "popup":
	        	    var getSelectionCallback = lang.hitch(this, "_getSelection");
	        	    widget = this._createPopupDialog(this._customWidgetClazz, this._popupValueAsString, control, dimension, getSelectionCallback, value, callback);
	        	    if (value != null) {
	        	        this._addDimensionChanged(control.name + "." + dimension.name);
	        	    }
	        	    break;
	        	case "widget":
	        	    var CustomWidgetClazz = this._customWidgetClazz[dimension["widget-path"]];
	        	    if (CustomWidgetClazz != null) {
                        var widgetConfig = dimension["widget-config"] || {};
                        widgetConfig.value = value;
                        dimension.prevValue = value;
                        widgetConfig.onChange = function(newValue) {
                            if (newValue !== dimension.prevValue) {
                                callback({name: dimension.name, value: newValue, prev: dimension.prevValue});
                                dimension.prevValue = newValue;
                            }
                        };
                        var div = domConstruct.create("div");
                        dimension.span.appendChild(div);
                        widget = new CustomWidgetClazz(widgetConfig, div);
                        widget.startup();
                        domClass.add(widget.domNode, "custom-widget-control");
                        if (dimension["widget-class"] != null) {
                            domClass.add(widget.domNode, dimension["widget-class"]);
                        }
    	        	    if (value != null) {
    	        	        this._addDimensionChanged(control.name + "." + dimension.name);
    	        	    }
	        	    }
	        	    else {
	        	        console.debug("######################");
	        	        console.debug("###################### Widget class not loaded: " + dimension["widget-path"] + " for " + control.name + "." + dimension.name);
	        	        console.debug("######################");
	        	        //console.trace();
	        	    }
	        	    break;
        	}
        	if (widget != null) {
                domClass.add(widget.domNode, "dimension-control");
                domClass.add(widget.domNode, "dimension-filter-item-"+dimension.name);
                domAttr.set(widget.domNode, "data-dimension-filter-item", control.name+"."+dimension.name);
        	    widget.set("disabled", dimension.disabled == true);
        	}
            else {
    	        console.debug("######################");
    	        console.debug("###################### Widget not created: " + control.name + "." + dimension.name);
    	        console.debug("######################");
                //console.trace();
            }
            return widget;
        },
        
        _isDependentOn : function(dimension, dimensionChanged) {
            if (dimension.dependent == null) return false;
            if (dimension.dependent == true) return true;
            if (Array.isArray(dimension.dependent) && dimension.dependent.indexOf(dimensionChanged) != -1) return true;
            return false;
        },

        _updateDimensionControl : function(control, index, dimensionChanged, callback) {
            var dimension = control.dimensions[index];
            if (dimensionChanged != null) {
                if (this._isDependentOn(dimension, dimensionChanged)) {
                    if (control.lastSetValues == null) {
                        control.lastSetValues = {};
                    }
                    control.lastSetValues[dimension.name] = control.values[dimension.name];
                    // backward compat
                    delete control.values[dimension.name];
                }
            }

            var self = this;
            dimension._queryId = Date.now();
            this._getDimensionOptions(control, dimension, lang.partial(function(qid, options) {
                if (qid == dimension._queryId) {
                    if (options != null) {
                        dimension._options = lang.clone(options);
                    }
                    if (dimension.widget != null) {
                        if (dimension.widget.destroy != null && typeof dimension.widget.destroy == "function") {
                            try {
                                dimension.widget.destroy();
                            }
                            catch (e) {
                                console.error(e);
                            }
                        }
                        dimension.widget = null;
                    }
                    AppUtil.removeAllChildrenOf(dimension.parent);
                    var value = null;
                    if (control.lastSetValues != null && control.lastSetValues[dimension.name] != null) {
                        value = control.lastSetValues[dimension.name];
                        if (value != null && options != null) {
                            if (typeof value == "string") {
                                // enum
                                var optValue = isValidOption(options, value, self.OPTION_VALUE_SEP);
                                if (optValue != null) {
                                    control.values[dimension.name] = optValue;
                                    value = optValue;
                                }
                            }
                            else if (Array.isArray(value)) {
                                // choices
                                var updatedValue = [];
                                control.values[dimension.name] = [];
                                for (var i=0; i<value.length; i++) {
                                    var optValue = isValidOption(options, value[i], self.OPTION_VALUE_SEP);
                                    if (optValue != null) {
                                        (control.values[dimension.name]).push(optValue);
                                        updatedValue.push(optValue);
                                    }
                                }
                                value = updatedValue;
                            }
                        }
                        else if (value != null) {
                            // restore value
                            control.values[dimension.name] = value;
                        }
                    }
                    if (value == null) {
                        value = self._getDimensionValue(control, dimension, options);
                        if (value == null) {
                            value = self._getDimensionDefault(control, dimension);
                            if (value != null && options != null) {
                                if (typeof value == "string") {
                                    // enum
                                    var optValue = isValidOption(options, value, self.OPTION_VALUE_SEP);
                                    if (optValue != null) {
                                        control.values[dimension.name] = optValue;
                                        value = control.values[dimension.name];
                                    }
                                }
                                else if (Array.isArray(value)) {
                                    // choices
                                    control.values[dimension.name] = [];
                                    for (var i=0; i<value.length; i++) {
                                        var optValue = isValidOption(options, value[i], self.OPTION_VALUE_SEP);
                                        if (optValue != null) {
                                            (control.values[dimension.name]).push(optValue);
                                        }
                                    }
                                    value = control.values[dimension.name];
                                }
                            }
                            else if (value != null) {
                                control.values[dimension.name] = value;
                            }
                        }
                    }
                    dimension.widget = self._createDimensionControl(control, dimension, options, value, lang.partial(lang.hitch(self, "_onChangeDimensionControl"), control, dimension, index));
                    self._enableDimensionControl(control, dimension);
                    self._displayDimensionControl(control, dimension);
                    self._displayCategorySubcategory();
                    self._doNotifyWidgets(control.name+"."+dimension.name);
                }
                if (callback != null) {
                    callback();
                }
            }, dimension._queryId));
        },
        
        _onChangeDimensionControl : function(control, dimension, index, selected) {
            if (this._INIT_ == true) return;
            
            if (selected != null) {
                switch (getDimensionDataType(dimension)) {
                    case "boolean":
                        if (selected.value != dimension.value) {
                            control.values[dimension.name] = selected.value;
                        }
                        else {
                            delete control.values[dimension.name];
                        }
                        break;
                    case "string":
                    case "text":
                        if (selected.value != dimension.value) {
                            control.values[dimension.name] = selected.value;
                        }
                        else {
                            delete control.values[dimension.name];
                        }
                        break;
                    case "enumeration":
                        if (selected.value != "" && selected.value != "#none#") {
                            if (selected.value.indexOf(this.OPTION_VALUE_SEP) != -1) {
                                control.values[dimension.name] = selected.value.split(this.OPTION_VALUE_SEP);
                            }
                            else {
                                control.values[dimension.name] = selected.value;
                            }
                        }
                        else {
                            delete control.values[dimension.name];
                        }
                        break;
                    case "choice":
                        control.values[dimension.name] = [];
                        for (var i=0; i<selected.value.length; i++) {
                            var value = selected.value[i];
                            if (value.indexOf(this.OPTION_VALUE_SEP) != -1) {
                                value = value.split(this.OPTION_VALUE_SEP);
                                for (var j=0; j<value.length; j++) {
                                    (control.values[dimension.name]).push(value[j]);
                                }
                            }
                            else {
                                (control.values[dimension.name]).push(value);
                            }
                        }
                        break;
                    case "date":
                    case "time":
                    case "datetime":
                    case "timestamp":
                        control.values[dimension.name] = selected.value;
                        break;
                    case "timeinterval":
                    case "timeinterval/absolute":
                        // looks like selected.value is a string of form "2017-07-20T01:00:00.000-07:00/2017-07-20T02:00:00.000-07:00"
                        control.values[dimension.name] = selected.value;
                        break;
                    case "timeinterval/relative":
                        // duration/time
                        // time/duration
                        control.values[dimension.name] = selected.value;
                        break;
                    case "timeinterval/timeslice":
                        // slice/time
                        control.values[dimension.name] = selected.value;
                        break;
                    default:
                        control.values[dimension.name] = selected.value;
                        break;
                }
                // remember last explicitly set value... for when options change, we can restore, if still applicable
                if (control.lastSetValues == null) {
                    control.lastSetValues = {};
                }
                control.lastSetValues[dimension.name] = control.values[dimension.name];
            }
            var dimensionChanged = control.name + "." + dimension.name;
            var dependents = this._getDependentDimensions(dimensionChanged);
            this._updateDependentDimensions(dependents, dimensionChanged, (this.initialConfig.properties.minimizedMode != true || !this._opened) && control.autoSubmit);
            
            if (this.initialConfig.properties.minimizedMode != true) {
                // UI-116: propagate changes, marked as "tempChange" IFF we are NOT running as minimized filters
                // minimized filters are modal and subject to ok/cancel so we don't want to propagate temp changes
                this._outputSelection(true, 'tempChange');
            }
        },

        _getDependentDimensions : function(changedDimension) {
            var dependents = [];
            for (var i=0; i<this._controls.length; i++) {
                var ctrl = this._controls[i];
                for (var j=0; j<ctrl.dimensions.length; j++) {
                    var dim = ctrl.dimensions[j];
                    if (dim.dependent == true) {
                        var dimName = ctrl.name + "." + dim.name;
                        if (dependents.indexOf(dimName) == -1) {
                            dependents.push(dimName);
                        }
                    }
                    else if (Array.isArray(dim.dependent)) {
                        for (var k=0; k<dim.dependent.length; k++) {
                            var depDim = dim.dependent[k];
                            if (depDim == changedDimension || dependents.indexOf(depDim) != -1) {
                                var dimName = ctrl.name + "." + dim.name;
                                var index = dependents.indexOf(dimName);
                                if (index == -1) {
                                    dependents.push(dimName);
                                }
                                else if (index < (dependents.length-1)) {
                                    // if in dependents but not last, move to end
                                    dependents.splice(index, 1, dimName);
                                }
                            }
                        }
                    }
                }
            }
            return dependents;
        },

        _updateDependentDimensions : function(dependents, dimensionChanged, submit) {
            if (dependents.length == 0) {
                this._enableApplyButtons();
                if (submit) {
                    this._outputSelection(true, "user");
                }
            }
            else {
                this._disableApplyButtons();
                var dependent = dependents.shift();
                for (var i=0; i<this._controls.length; i++) {
                    var ctrl = this._controls[i];
                    var dependentDimension = null;
                    for (var j = 0; j < ctrl.dimensions.length; j++) {
                        if (ctrl.name + "." + ctrl.dimensions[j].name == dimensionChanged) {
                            dependentDimension = ctrl.dimensions[j];
                            break;
                        }
                    }
                    
                    for (var j=0; j<ctrl.dimensions.length; j++) {
                        var dim = ctrl.dimensions[j];
                        var dimName = ctrl.name + "." + dim.name;
                        if (dimName == dependent) {
                            var self = this;
                            this._updateDimensionControl(ctrl, j, dimensionChanged, function() {
                                if (dependentDimension != null && self._isDependentOn(dim, dimensionChanged) && isPopupDimension(dim)) {
                                    var around = self._getDimensionDisplayNode(dependentDimension);
                                    if (dependentDimension.widget.getSelection) {
                                        var selection = dependentDimension.widget.getSelection();
                                        if (selection && selection.div) {
                                            around = selection.div;
                                        }
                                    }
                                    self._showPopupFontAwesomeBar(dim.widget, dependentDimension.widget,around, function(){
                                        self._updateDependentDimensions(dependents, dimensionChanged, submit);
                                    });
                                } else {
                                    self._updateDependentDimensions(dependents, dimensionChanged, submit);
                                }
                            });
                            dependent = null;
                            break;
                        }
                    }
                    if (dependent == null) break;
                }
                if (dependent != null) {
                    this._updateDependentDimensions(dependents, dimensionChanged, submit);
                }
            }
        },
        
        _displayCategorySubcategory : function() {
            for (var i=0; i<this._controls.length; i++) {
                var control = this._controls[i];
                if (control["category-node"] != null && control["category-display"] != null) {
                    var ok = doEvalConditional(this._scriptFuncs, control.name + ":category-display", control["category-display"], this._getSelection(false));
                    if (ok !== undefined) {
                    	var display = ok == true;
                    	domStyle.set(control["category-node"], "display", display ? "" : "none");
                    }
                    else {
                    	// if cannot be evaluated, do not display... HIDE
                    	domStyle.set(control["category-node"], "display", "none");
                    }
                }
                else if (control["subcategory-node"] != null && control["subcategory-display"] != null) {
                    var ok = doEvalConditional(this._scriptFuncs, control.name + ":subcategory-display", control["subcategory-display"], this._getSelection(false));
                    if (ok !== undefined) {
                    	var display = ok == true;
                    	domStyle.set(control["subcategory-node"], "display", display ? "" : "none");
                    }
                    else {
                    	// if cannot be evaluated, do not display... HIDE
                    	domStyle.set(control["subcategory-node"], "display", "none");
                    }
                }
            }
        },

        _disableApplyButtons : function() {
            for (var i=0; i<this._controls.length; i++) {
                var ctrl = this._controls[i];
                if (ctrl.btnApply != null) {
                    ctrl.btnApply.set("disabled", true);
                	domStyle.set(ctrl.btnApply.domNode, "opacity", 0.4);
                }
                else if (ctrl.faApply) {
                	domStyle.set(ctrl.faApply.domNode, {
                	    "opacity" : 0.4,
                	    "pointer-events" : "none"
                	});
                }
            }
        },
        
        _enableApplyButtons : function() {
            for (var i=0; i<this._controls.length; i++) {
                var ctrl = this._controls[i];
                if (ctrl.btnApply != null) {
                    ctrl.btnApply.set("disabled", false);
                	domStyle.set(ctrl.btnApply.domNode, "opacity", 1.0);
                }
                else if (ctrl.faApply) {
                	domStyle.set(ctrl.faApply.domNode, {
                	    "opacity" : 1.0,
                	    "pointer-events" : "auto"
                	});
                }
            }
        },

        _enableDimensionControls : function() {
            for (var i=0; i<this._controls.length; i++) {
                var control = this._controls[i];
                for (var j=0; j<control.dimensions.length; j++) {
                    this._enableDimensionControl(control, control.dimensions[j]);
                }
            }
        },

        _enableDimensionControl : function(control, dimension) {
            if (dimension.widget != null) {
                // UI-385 - in addition to checking for no options
                //          also disable if there is ONLY ONE option and it is "#none#"
                if (dimension._options != null && (dimension._options.length == 0 || (dimension._options.length == 1 && dimension._options[0].value == "#none#"))) {
                    // has _options... enums or choices... but no options... disable
                    dimension.disabled = true;
            		dimension.widget.set("disabled", dimension.disabled);
                	//domStyle.set(this._getDimensionEnableNode(dimension), "opacity", 0.4);
                	domClass.add(this._getDimensionEnableNode(dimension), "dimension-disabled");
                }
                else if (dimension["enable"] != null) {
                    var ok = doEvalConditional(this._scriptFuncs, control.name + "." + dimension.name + ":enable", dimension["enable"], this._getSelection(false));
                    if (ok !== undefined) {
                    	dimension.disabled = ok == false;
                		dimension.widget.set("disabled", dimension.disabled);
                    	//domStyle.set(this._getDimensionEnableNode(dimension), "opacity", dimension.disabled ? 0.4 : 1.0);
                		if (dimension.disabled) {
                        	domClass.add(this._getDimensionEnableNode(dimension), "dimension-disabled");
                		}
                		else {
                        	domClass.remove(this._getDimensionEnableNode(dimension), "dimension-disabled");
                		}
                    }
                    else {
                    	// if cannot be evaluated, do not enable... DISABLE
                        dimension.disabled = true;
                		dimension.widget.set("disabled", dimension.disabled);
                    	//domStyle.set(this._getDimensionEnableNode(dimension), "opacity", 0.4);
                    	domClass.add(this._getDimensionEnableNode(dimension), "dimension-disabled");
                    }
                }
                else {
            		dimension.widget.set("disabled", false);
                	//domStyle.set(this._getDimensionEnableNode(dimension), "opacity", 1.0);
                	domClass.remove(this._getDimensionEnableNode(dimension), "dimension-disabled");
                }
            }
        },
        
        _displayDimensionControls : function() {
            for (var i=0; i<this._controls.length; i++) {
                var control = this._controls[i];
                for (var j=0; j<control.dimensions.length; j++) {
                    this._displayDimensionControl(control, control.dimensions[j]);
                }
            }
        },

        _displayDimensionControl : function(control, dimension) {
            if (dimension.widget != null) {
                if (dimension._options != null && dimension._options.length == 0 && dimension.hideEmpty == true) {
                    // has _options... enums or choices... but no options... disable
                	domStyle.set(this._getDimensionDisplayNode(dimension), "display", "none");
                }
                else if (dimension["display"] != null) {
                    var ok = doEvalConditional(this._scriptFuncs, control.name + "." + dimension.name + ":display", dimension["display"], this._getSelection(false));
                    if (ok !== undefined) {
                    	var display = ok == true;
                    	//domStyle.set(this._getDimensionDisplayNode(dimension), "display", display ? "inline-block" : "none");
                    	domStyle.set(this._getDimensionDisplayNode(dimension), "display", display ? "" : "none");
                    }
                    else {
                    	// if cannot be evaluated, do not display... HIDE
                    	domStyle.set(this._getDimensionDisplayNode(dimension), "display", "none");
                    }
                }
                else {
                	//domStyle.set(this._getDimensionDisplayNode(dimension), "display", "inline-block");
                	domStyle.set(this._getDimensionDisplayNode(dimension), "display", "");
                }
            }
        },

        _outputSelection : function(notify, event, asDrilldownEvent) {
            if (this._empty || this._controls.length == 0) {
                DEBUG("No output if model is empty");
                return;
            }
            
            for (var i=0; i<this._controls.length; i++) {
                var control = this._controls[i];
                for (var j=0; j<control.dimensions.length; j++) {
                    var dimension = control.dimensions[j];
                    var dimValue = this._getDimensionValue(control, dimension, null);
                    if (dimension["initialize"] != null && (dimValue == null || dimValue == "") && /* dimDefault == null && */ dimension["default"] != null) {
                        var ok = doEvalConditional(this._scriptFuncs, control.name + "." + dimension.name + ":initialize", dimension["initialize"], this._getSelection(false));
                        if (ok !== undefined) {
                            if (ok == true) {
                                control.values[dimension.name] = this._getDimensionDefault(control, dimension);
                            }
                        }
                    }
                }
            }
            
        	var selection = this._getSelection(true);
            DEBUG(this._name + " output=" + JSON.stringify(selection));

            // UI-116: don't output on tempChange event
            if (event != null && event != "tempChange") {
                if (this.tile != null) {
                    // use this.tile.updateUIEvent() to dispatch directives thru UI Event port
                	this.tile.updateUIEvent([{
                        "__TYPE__" : "change",
                        "__EVENT__" : {
                            "type" : event,
                            "data" : selection,
                        }
                    }]);
                }
            }

            // use this.tile._onSelectionChange() for intermediate changes
            // this.tile._onSelectionChange(selection);

            // UI-116: don't output on tempChange event
            if (this.tile != null && event != "tempChange") {
                // use this.tile._doubleClickOnSelection() to direct selection via Drilldown port
                if (asDrilldownEvent == true) {
                    this.tile.drillDownOnSelection(this.renderer.model, selection);
                }
                else {
                	this.tile._doubleClickOnSelection(selection);
                }
            }
            
            // if cookiePath set, propagate to other controls on page via topic
            if (this._syncTopicHandle != null && notify != false) {
                if (this._saveCookie) {
                    // if save cookie is enable, the recipient can get values from cookie
                    // legacy... no need to pass on wire
                    topic.publish(this._cookiePath, this._syncTopicUUID, null);
                }
                else {
                    var values = {};
                    for (var i=0; i<this._controls.length; i++) {
                        var control = this._controls[i];
                        values[control.name] = control.values;
                    }
                    topic.publish(this._cookiePath, this._syncTopicUUID, values, event == "tempChange");
                }
            }
        },

        _getSelection : function(save) {
        	var selection = [];
        	var self = this;
            for (var i=0; i<this._controls.length; i++) {
                var control = this._controls[i];
                for (var j=(control.dimensions.length-1); j>=0; j--) {
                    var dimension = control.dimensions[j];
                    var dimensionValue = this._getDimensionValue(control, dimension, null);
                    if (dimensionValue == null) {
                    	dimensionValue = this._getDimensionDefault(control, dimension);
                    }
                    if (dimensionValue != null) {
                        var record = null;
                        var dimensionType = dimension.type;
                        var dataType = dimension.type;
                        if (dimension["data-type"] != null) {
                            dimensionType = dimension["data-type"];
                            dataType = dimension.type + ":" + dimensionType;
                        }
                        switch (dimensionType) {
                            case "date":
                                var dt = parseDateValue(dimensionValue);
                                var utc = Date.UTC(dt.getFullYear(), dt.getMonth(), dt.getDate(), dt.getHours(), dt.getMinutes(), dt.getSeconds());
                                var unixtime = Math.floor(utc / 1000);
                                unixtime = Math.floor(unixtime / (24 * 60 * 60)) * (24 * 60 * 60);
                                record = {
                                    name    : control.name + "." + dimension.name,
                                    type    : dataType,
                                    value   : String(unixtime),
                                };
                                break;
                            case "time":
                                var dt = parseDateValue(dimensionValue);
                                var secsFromMidnight = (dt.getHours() * 3600) + (dt.getMinutes() * 60) + dt.getSeconds();
                                record = {
                                    name    : control.name + "." + dimension.name,
                                    type    : dataType,
                                    value   : String(secsFromMidnight),
                                };
                                break;
                            case "datetime":
                            case "timestamp":
                                var unixtime = getUnixTime(parseDateValue(dimensionValue), dimension.asLocalTime);
                                record = {
                                    name    : control.name + "." + dimension.name,
                                    type    : dataType,
                                    value   : String(unixtime),
                                };
                                break;
                            case "timeinterval":
                            	if (Array.isArray(dimensionValue)) {
                            		// expects array of 2 array
                            		if (dimensionValue.length == 2) {
                                        var unixtimeFrom = getUnixTime(parseDateValue(dimensionValue[0]), dimension.asLocalTime);
                                        var unixtimeTo = getUnixTime(parseDateValue(dimensionValue[1]), dimension.asLocalTime);
                                        record = {
                                            name    : control.name + "." + dimension.name,
                                            type    : dataType,
                                            value   : String(unixtimeFrom) + "/" + String(unixtimeTo),
                                        };
                            		}
                            	}
                            	else if (typeof dimensionValue == "string") {
                                    // OLD format
                                    // YYYYMMDD'T'HH:mm:ss/YYYYMMDD'T'HH:mm:ss
                                    // NEW format
                                    // predefined:XXX
                                    // absolute:YYYYMMDD'T'HH:mm:ss/YYYYMMDD'T'HH:mm:ss
                                    var colon = dimensionValue.indexOf(":");
                            		var predefined = colon != -1 ? dimensionValue.substring(0, colon) == "predefined" : false;
                            		var absolute = colon != -1 ? dimensionValue.substring(0, colon) == "absolute" : false;
                                    var slash = dimensionValue.indexOf("/");
                            		if (!predefined && !absolute) {
                            			var toks = dimensionValue.split("/");
                            			if (toks.length == 2) {
                            				// old format... assume FROM/TO
                                            var unixtimeFrom = getUnixTime(parseDateValue(toks[0]), dimension.asLocalTime);
                                            var unixtimeTo = getUnixTime(parseDateValue(toks[1]), dimension.asLocalTime);
                                            record = {
                                                name    : control.name + "." + dimension.name,
                                                type    : dataType,
                                                value   : String(unixtimeFrom) + "/" + String(unixtimeTo),
                                            };
                            			}
                            		}
                            		else if (predefined && slash == -1) {
                            			// predefined:XXX
                                        record = {
                                            name    : control.name + "." + dimension.name,
                                            type    : dataType,
                                            value   : "predefined:" + dimensionValue.substring(colon+1),
                                        };
                            		}
                            		else if (absolute && slash != -1) {
                            			// absolute:###/###
                                        var unixtimeFrom = getUnixTime(parseDateValue(dimensionValue.substring(colon+1, slash)), dimension.asLocalTime);
                                        var unixtimeTo = getUnixTime(parseDateValue(dimensionValue.substring(slash+1)), dimension.asLocalTime);
                                        record = {
                                            name    : control.name + "." + dimension.name,
                                            type    : dataType,
                                            value   : "absolute:" + unixtimeFrom + "/" + unixtimeTo,
                                        };
                            		}
                            	}
                                break;
                            case "timeinterval/absolute":
                                // YYYYMMDD'T'HH:mm:ss/YYYYMMDD'T'HH:mm:ss
                                if (dimensionValue.indexOf("/") != -1) {
                                    var toks = dimensionValue.split("/");
                                    if (toks.length == 2) {
                                        var unixtimeFrom = getUnixTime(parseDateValue(toks[0]), dimension.asLocalTime);
                                        var unixtimeTo = getUnixTime(parseDateValue(toks[1]), dimension.asLocalTime);
                                        record = {
                                            name    : control.name + "." + dimension.name,
                                            type    : dataType,
                                            value   : String(unixtimeFrom) + "/" + String(unixtimeTo),
                                        };
                                    }
                                }
                                break;
                            case "timeinterval/relative":
                                // P#U/YYYYMMDD'T'HH:mm:ss
                                // YYYYMMDD'T'HH:mm:ss/P#U
                                if (dimensionValue.indexOf("/") != -1) {
                                    var toks = dimensionValue.split("/");
                                    if (toks.length == 2) {
                                        if (toks[0].charAt(0) == "P") {
                                            // P#U/YYYYMMDD'T'HH:mm:ss
                                            var unixtime = getUnixTime(parseDateValue(toks[1]), dimension.asLocalTime);
                                            record = {
                                                name    : control.name + "." + dimension.name,
                                                type    : dataType,
                                                value   : toks[0] + "/" + String(unixtime),
                                            };
                                        }
                                        else if (toks[1].charAt(0) == "P") {
                                            // YYYYMMDD'T'HH:mm:ss/P#U
                                            var unixtime = getUnixTime(parseDateValue(toks[0]), dimension.asLocalTime);
                                            record = {
                                                name    : control.name + "." + dimension.name,
                                                type    : dataType,
                                                value   : String(unixtime) + "/" + toks[1],
                                            };
                                        }
                                    }
                                }
                                break;
                            case "timeinterval/timeslice":
                                // ONLY S1D/YYYYMMDD'T'HH:mm:ss
                                if (dimensionValue.indexOf("/") != -1) {
                                    var toks = dimensionValue.split("/");
                                    if (toks.length == 2) {
                                        if (toks[0].charAt(0) == "S") {
                                            var dt = parseDateValue(toks[1]);
                                            var unixtime = getUnixTime(parseDateValue(toks[1]), dimension.asLocalTime);
                                            record = {
                                                name    : control.name + "." + dimension.name,
                                                type    : dataType,
                                                value   : toks[0] + "/" + String(unixtime),
                                            };
                                        }
                                    }
                                }
                                break;
                            case "enumeration":
                                if (dimension.asArray) {
                                    if (Array.isArray(dimensionValue)) {
                                        if (dimensionValue.length > 0) {
                                            record = {
                                                name    : control.name + "." + dimension.name,
                                                type    : dataType,
                                                value   : [stripFragmentHash(dimensionValue[0])],
                                            };
                                        }
                                        else if (dimensionValue.length == 0) {
                                            record = {
                                                name    : control.name + "." + dimension.name,
                                                type    : dataType,
                                                value   : [],
                                            };
                                        }
                                    }
                                    else {
                                        if (dimensionValue.indexOf(this.OPTION_VALUE_SEP) != -1) {
                                            dimensionValue = dimensionValue.split(this.OPTION_VALUE_SEP)[0];
                                        }
                                        else {
                                            dimensionValue = [stripFragmentHash(dimensionValue)];
                                        }
                                        record = {
                                            name    : control.name + "." + dimension.name,
                                            type    : dataType,
                                            value   : dimensionValue,
                                        };
                                    }
                                }
                                else {
                                    if (Array.isArray(dimensionValue)) {
                                        if (dimensionValue.length > 0) {
                                            record = {
                                                name    : control.name + "." + dimension.name,
                                                type    : dataType,
                                                value   : stripFragmentHash(dimensionValue[0]),
                                            };
                                        }
                                        else {
                                            record = {
                                                name    : control.name + "." + dimension.name,
                                                type    : dataType,
                                                value   : "",
                                            };
                                        }
                                    }
                                    else {
                                        if (dimensionValue.indexOf(this.OPTION_VALUE_SEP) != -1) {
                                            dimensionValue = dimensionValue.split(this.OPTION_VALUE_SEP)[0];
                                        }
                                        record = {
                                            name    : control.name + "." + dimension.name,
                                            type    : dataType,
                                            value   : stripFragmentHash(dimensionValue),
                                        };
                                    }
                                }
                                break;
                            case "choice":
                                // for choice, output needs to be an array of string
                                // if user has never interacted, the default value may be an array of string or a comma-separated string
                                // if comma-separated, convert to array of strings
                                if (typeof dimensionValue == "string") {
                                    if (dimensionValue == "") {
                                        dimensionValue = [];
                                    }
                                    else {
                                        dimensionValue = dimensionValue.split(",");
                                    }
                                }
                                else if (Array.isArray(dimensionValue)) {
                                    var values = [];
                                    dimensionValue.forEach(function(dimVal) {
                                        if (dimVal.indexOf(self.OPTION_VALUE_SEP) != -1) {
                                            dimVal.split(self.OPTION_VALUE_SEP).forEach(function(val) {
                                                val = stripFragmentHash(val);
                                                if (values.indexOf(val) == -1) {
                                                    values.push(val);
                                                }
                                            });
                                        }
                                        else {
                                            dimVal = stripFragmentHash(dimVal);
                                            if (values.indexOf(dimVal) == -1) {
                                                values.push(dimVal);
                                            }
                                        }
                                    });
                                    dimensionValue = values;
                                }
                                record = {
                                    name    : control.name + "." + dimension.name,
                                    type    : dataType,
                                    value   : dimensionValue,
                                };
                                break;
                            case "widget":
                            case "popup":
                                record = {
                                    name    : control.name + "." + dimension.name,
                                    type    : dataType,
                                    value   : dimensionValue,
                                };
                                break;
                            default:
                                if (Array.isArray(dimensionValue)) {
                                    record = {
                                        name    : control.name + "." + dimension.name,
                                        type    : dataType,
                                        value   : dimensionValue,
                                    };
                                }
                                else {
                                    record = {
                                        name    : control.name + "." + dimension.name,
                                        type    : dataType,
                                        value   : String(dimensionValue),
                                    };
                                }
                                break;
                        }
                        if (record != null) {
                            if (dimension.timezoneOffset == true) {
                                record.timezoneOffset = (new Date()).getTimezoneOffset();
                            }
                            selection.push(record);
                        }
                    }
                }
                if (save) {
                    this._saveValues(control);
                }
            }
            return selection;
        },

        _syncWidgetAndValue : function(uuid, values, isTempChange) {
            // this is a broadcast so we need to IGNORE if broadcast was from me
            // if UUID is me, ignore
            if (uuid == this._syncTopicUUID) return;

            // UI-116: if isTempChange event, just store in _tempSelection... DO NOT process
            if (isTempChange) {
                // since tempSelection is HANDLED on expanding the filter, this ONLY applies to minimized filters
                // other filters that may received this event can ignore... OR more likely handle differently... TBD
                if (this.initialConfig.properties.minimizedMode == true) {
                    this._tempSelection = values;
                }
                return;
            }

            for (var i=0; i<this._controls.length; i++) {
                var control = this._controls[i];
                var remoteValues = values != null ? values[control.name] : this._loadValues(control);
                if (remoteValues != null) {
                    control.values = remoteValues;
                }
                if (control.values == null) {
                    control.values = {};
                }
                for (var j=0; j<control.dimensions.length; j++) {
                    var dimension = control.dimensions[j];
                    var value = control.values[dimension.name];
                    if (value == null) {
                        value = this._getDimensionDefault(control, dimension);
                    }
                    if (value != null) {
                        control.values[dimension.name] = value;
                        if (control.lastSetValues == null) {
                            control.lastSetValues = {};
                        }
                        control.lastSetValues[dimension.name] = control.values[dimension.name];
                        if (dimension.widget != null) {
                            switch (dimension.type) {
                                case "choice":
                                    if (Array.isArray(value)) {
                                        dimension.widget.set("value", value.join(","), false);
                                    }
                                    else {
                                        dimension.widget.set("value", value, false);
                                    }
                                    break;
                                default:
                                    dimension.widget.set("value", value, false);
                                    break;
                            }
                        }
                    }
                }
            }

            // UI-116: _syncWidgetAndValue() is called when expanding minimized filters... with uuid=null
            //         when it is called from there, we DO NOT output selection... so check the uuid is NOT null
            if (uuid != null) {
                if (this._active == false) {
                    // widget is alive but switched out
                    // mark so that when switched back in, outputSelection
                    this._outputSelectionOnSwitchIn = true;
                }
                else {
                	this._outputSelection(false, "sync");
                }
                // UI-116: if we output selection, we can delete any leftover temp selection
                delete this._tempSelection;
            }

            var changeList = [];
            for (var i=0; i<this._controls.length; i++) {
                var control = this._controls[i];
                for (var j=0; j<control.dimensions.length; j++) {
                    var dimension = control.dimensions[j];
                    changeList.push({
                        control   : control,
                        dimension : dimension,
                        index     : j,
                        value     : control.values[dimension.name],
                    });
                    if (control.lastSetValues == null) {
                        control.lastSetValues = {};
                    }
                    control.lastSetValues[dimension.name] = control.values[dimension.name];
                }
            }
            
            var self = this;
            self._INIT_ = true;
            applyChangeList(this, 0, changeList, function() {
                for (var i=0; i<self._controls.length; i++) {
                    var control = self._controls[i];
                    delete control.lastSetValues;
                }
                delete self._INIT_;
            });
        },

        _loadValues : function(control) {
            if (this._saveCookie) {
                // load from cookie
                return getCookie(this._cookiePath, control.name, null);
            }
            else {
                return {};
            }
        },
        
        _saveValues : function(control) {
            if (this._saveCookie) {
                // save to cookie
                setCookie(this._cookiePath, control.name, control.values);
            }
            else {
                // do nothing
            }
        },
        
        _migrateModel : function() {
            if (this._model.categories != null) {
                for (var i=0; i<this._model.categories.length; i++) {
                    var category = this._model.categories[i];
                    if (category.subcategories != null) {
                        for (var j=0; j<category.subcategories.length; j++) {
                            var subcategory = category.subcategories[j];
                            if (subcategory.dimensions != null) {
                                for (var k=0; k<subcategory.dimensions.length; k++) {
                                    migrateDimension(subcategory.dimensions[k]);
                                }
                            }
                        }
                    }
                    else if (category.dimensions != null) {
                        for (var k=0; k<category.dimensions.length; k++) {
                            migrateDimension(category.dimensions[k]);
                        }
                    }
                }
            }
        },

        _getDimensionEnableNode : function(dimension) {
            return dimension.span.parentNode.parentNode;
        },
        
        _getDimensionDisplayNode : function(dimension) {
            return dimension.span.parentNode.parentNode.parentNode.parentNode;
        },

        _createPopupDialog : function(customWidgetClazz, valueAsStringFuncs, control, dimension, getSelectionCallback, value, callback) {
    	    if (dimension.dialog != null) {
    	        if (dimension.dialog.widget != null && dimension.dialog.widget.path != null) {
    	            dimension._PopupDialogWidget = customWidgetClazz[dimension.dialog.widget.path];
        	        dimension._getValueAsString = valueAsStringFuncs[dimension.dialog.widget.path];
    	        }
    	        else {
        	        console.debug("######################");
        	        if (dimension.dialog.widget == null) {
            	        console.debug("###################### " + control.name + "." + dimension.name + ": dimension.dialog.widget is null");
        	        }
        	        if (dimension.dialog.widget.path == null) {
            	        console.debug("###################### " + control.name + "." + dimension.name + ": dimension.dialog.widget.path is null");
        	        }
        	        console.debug("######################");
    	        }
        	    if (dimension["fa-control"] != true && dimension.text != null) {
        	        // if no style specified, set to " "... cannot be empty string or null
        	        // for FormUtil.createTextBox will set width to 100% if style is empty string
                    var style = dimension.text["style"] || " ";
                    dimension._textbox = FormUtil.createTextBox(dimension.text.name || dimension.text.label, dimension.span, value, style, dimension.text.tooltip, true, null);
                    if (dimension.text.placeholder != null) {
                        dimension._textbox.set("placeholder", dimension.text.placeholder);
                    }
                    dimension._textbox.set("value", getDimensionValueAsString(dimension, value), false);
                    domClass.add(dimension._textbox.domNode, "popup-text-control");
                    domClass.add(dimension._textbox.domNode, "dimension-control");
        	    }
                if (dimension.dialog.type == null) {
                    dimension.dialog.type = "viewer";
                }
                switch (dimension.dialog.type) {
                    case "viewer":
                        dimension._PopupDialogClass = "af/controls/PopupViewerDialog";
                        break;
                    case "editor":
                        dimension._PopupDialogClass = "af/controls/PopupEditorDialog";
                        break;
                }
                dimension.value = value || [];
                if (dimension._PopupDialogClass != null && dimension.dialog.widget != null && dimension._PopupDialogWidget != null) {
                    if (dimension["fa-control"] == true) {
                        var widget = this._createFontAwesomeButton(dimension.span, "popup-button-fa", dimension["fa-class-button"], dimension["fa-label"], dimension["fa-style"],
                                                                   lang.partial(lang.hitch(this, "_showPopupDialog"), control, dimension, getSelectionCallback, callback));
                        dimension._faDiv = widget.domNode;
                        domAttr.set(dimension._faDiv, "title", getDimensionValueAsString(dimension, value));
                        return widget;
                    }
                    else {
                        var style = dimension["style"];
                        if (style != null && typeof style == "string") {
                            style = parseStyleString(style);
                        }
                        var widget = FormUtil.createButton(dimension.span, dimension.dialog.label || dimension.label, style, null,
                                                           lang.partial(lang.hitch(this, "_showPopupDialog"), control, dimension, getSelectionCallback, callback));
                        domClass.add(widget.domNode, "popup-button-control");
                        if (dimension.dialog.reset != null) {
                            dimension._resetBtn = FormUtil.createButton(dimension.span, dimension.dialog.reset, style, null,
                                                                        lang.partial(lang.hitch(this, "_resetPopupValue"), control, dimension, getSelectionCallback, callback));
                            domClass.add(dimension._resetBtn.domNode, "popup-reset-button");
                            domClass.add(dimension._resetBtn.domNode, "dimension-control");
                            domClass.add(dimension._resetBtn.domNode, "popup-button-control");
                        }
                        return widget;
                    }
                }
                else {
        	        console.debug("######################");
        	        if (dimension._PopupDialogClass == null) {
            	        console.debug("###################### " + control.name + "." + dimension.name + ": dimension._PopupDialogClass is null");
        	        }
        	        if (dimension._PopupDialogWidget == null) {
            	        console.debug("###################### " + control.name + "." + dimension.name + ": dimension._PopupDialogWidget is null");
        	        }
        	        if (dimension.dialog.widget == null) {
            	        console.debug("###################### " + control.name + "." + dimension.name + ": dimension.dialog.widget is null");
        	        }
        	        console.debug("######################");
                }
    	    }
    	    else {
    	        console.debug("######################");
                console.debug("###################### " + control.name + "." + dimension.name + ": dimension.dialog is null");
    	        console.debug("######################");
    	    }
    	    return null;
        },

        _resetPopupValue : function(control, dimension, getSelectionCallback, callback, evt) {
            dimension.value = null;
            if (dimension._textbox != null) {
                dimension._textbox.set("value", getDimensionValueAsString(dimension, null), false);
            }
            callback({ name:dimension.name, value:null, prev:dimension.value });
        },

        _showPopupDialog : function(control, dimension, getSelectionCallback, callback, evt) {
            var prevValue = dimension.value;
            loadDialogClass(dimension._PopupDialogClass, function(PopupDialogClazz) {
                var dialogConfig = {
                    title    : dimension.dialog.title,
                    vtWidth  : dimension.dialog.width,
                    vtHeight : dimension.dialog.height,
                    model    : dimension.value,
                };
                switch (dimension.dialog.type) {
                    case "viewer":
                        dialogConfig.viewerClass = dimension._PopupDialogWidget;
                        dialogConfig.viewerConfig = dimension.dialog.widget.config || {};
                        break;
                    case "editor":
                        dialogConfig.editorClass = dimension._PopupDialogWidget;
                        dialogConfig.editorConfig = dimension.dialog.widget.config || {};
                        var values = control != null ? lang.clone(control.values) : {};
                        if (getSelectionCallback) {
                            var selection = getSelectionCallback(false);
                            for (var i=0; i<selection.length; i++) {
                                values[selection[i]["name"]] = selection[i]["value"];
                            }
                        }
                        values["$.timezoneOffset"] = (new Date()).getTimezoneOffset();
                        dialogConfig.editorConfig.values = values;
                        dialogConfig.onClickOk = function(value) {
                            // alert("onClickOk");
                            dimension.value = value;
                            if (dimension._textbox != null) {
                                dimension._textbox.set("value", getDimensionValueAsString(dimension, value), false);
                            }
                            if (dimension._faDiv != null) {
                                domAttr.set(dimension._faDiv, "title", getDimensionValueAsString(dimension, value));
                            }
                            callback({ name:dimension.name, value:dimension.value, prev:prevValue });
                        };
                        break;
                }
                var dialog = new PopupDialogClazz(dialogConfig);
                domAttr.set(dialog.main, {"title":""});
                switch (dimension.dialog.type) {
                    case "viewer":
                        domStyle.set(dialog._widget.contentDiv.domNode, "overflow", "hidden");
                        domClass.add(dialog._widget.viewerTitleLabel, "popup-title-label");
                        if (dimension.dialog.description != null) {
                            dialog.set("viewerTitle", dimension.dialog.description);
                        }
                        else {
                            // hide title label if no description specified
                            domStyle.set(dialog._widget.viewerTitleLabel, {
                                "display"     : "none",
                                "height"      : "0px",
                                "line-height" : "0px"
                            });
                        }
                        break;
                    case "editor":
                        domStyle.set(dialog._widget.modelTd.domNode, "overflow", "hidden");
                        domClass.add(dialog._widget.editorTitleLabel, "popup-title-label");
                        if (dimension.dialog.description != null) {
                            dialog.set("editorTitle", dimension.dialog.description);
                        }
                        else {
                            // hide title label if no description specified
                            domStyle.set(dialog._widget.editorTitleLabel, {
                                "display"     : "none",
                                "height"      : "0px",
                                "line-height" : "0px"
                            });
                        }
                        break;
                }
                if (dimension.dialog.maximize == false) {
                    // there is no public interface to disable maximize button
                    // so we HIDE it explicitly -engkee
                    domStyle.set(dialog._dialog.resizeBtn, "display", "none");
                }
                domClass.add(dialog.domNode, "popup-dialog");
                dialog.show();
            });
        },

        _createFontAwesomeBar : function(name, parentNode, options, value, style, tooltip, dimension, callback) {
    	    var CustomWidgetClazz = this._customWidgetClazz["/app/dbp/user/via_common/dbpm/VIA - Common/Font Awesome Bar"];
    	    if (CustomWidgetClazz != null) {
                var widgetConfig = {
                    options : options,
                    faClass : dimension["fa-class"],
                };
                widgetConfig.value = value;
                dimension.prevValue = value;
                widgetConfig.onChange = function(newValue) {
                    if (newValue !== dimension.prevValue) {
                        callback({name: dimension.name, value: newValue, prev: dimension.prevValue});
                        dimension.prevValue = newValue;
                    }
                };
                var div = domConstruct.create("div");
                if (!isPopupDimension(dimension)) {
                    dimension.span.appendChild(div);
                } else {
                    if (dimension.labelTD) {
                        dimension.labelTD.innerHTML = "";
                    }
                }
                widget = new CustomWidgetClazz(widgetConfig, div);
                widget.startup();
                domClass.add(widget.domNode, "custom-widget-control");
                if (dimension["widget-class"] != null) {
                    domClass.add(widget.domNode, dimension["widget-class"]);
                }
                if (style != null && typeof style == "string" && style != "") {
                    style = parseStyleString(style);
                    if (style != null) {
                        domStyle.set(widget.domNode, style);
                    }
                }
                if (isPopupDimension(dimension)) {
                    domStyle.set(widget.domNode, {marginRight:"0px"});
                }
                return widget;
    	    }
    	    return null;
        },

        _createFontAwesomeButton : function(parentNode, buttonClassPrefix, faClass, buttonLabel, buttonStyle, callback) {
            var div = domConstruct.create("div", {
                "class" : buttonClassPrefix + "-div",
                "style" : buttonStyle || ""
            });
            parentNode.appendChild(div);
            
            var fa = domConstruct.create("i", {
                "class" : buttonClassPrefix + "-icon " + faClass,
            });
            div.appendChild(fa);

            var label = null;
            if (buttonLabel != null) {
                label = domConstruct.create("div", {
                    "class" : buttonClassPrefix + "-label"
                });
                label.innerHTML = buttonLabel;
                fa.appendChild(label);
            }
            
            this.own(on(div, "click", callback));
            
            return {
                domNode : div,
                faNode : fa,
                labelNode : label,
                "set" : function(name, value) {
                    switch (name) {
                        case "disabled":
                            if (value) {
                            	domStyle.set(this.domNode, {
                            	    "opacity" : 0.4,
                            	    "pointer-events" : "none"
                            	});
                            }
                            else {
                            	domStyle.set(this.domNode, {
                            	    "opacity" : 1.0,
                            	    "pointer-events" : "auto"
                            	});
                            }
                            break;
                    }
                }
            };
        },
        
        _showPopupFontAwesomeBar : function(widget, parentWidget,around, callback) {
            var items = widget.getItems();
            if (!items || items.length == 0) {
                if (callback) {
                    callback();
                }
                return;
            }
            
            require(["dijit/popup", "dojo/domReady!"], function(popup) {
                popup.open({
                    parent: parentWidget,
                    popup: widget,
                    around: around,
                    orient: ["below-centered"],
                    onExecute: function(){
                        popup.close(widget);
                        if (callback) {
                            callback();
                        }
                    },
                    onCancel: function(){
                        popup.close(dropDown);
                        if (callback) {
                            callback();
                        }
                    },
                    onClose: function(){
                        if (callback) {
                            callback();
                        }
                    }
                });
            });
        },
]]>
        </CodeText>
        <CodeText segment="#onNotify">
          <![CDATA[            function parseControlDimension(key)
            {
                var controlName = null;
                var dimensionName = null;
                var toks = key.split(".");
                if (toks.length == 2) {
                    // key is category.dimension
                    controlName = toks[0];
                    dimensionName = toks[1];
                }
                else if (toks.length == 3) {
                    // key is category.subcategory.dimension
                    controlName = toks[0] + "." + toks[1];
                    dimensionName = toks[2];
                }
                return {
                	control : controlName,
                	dimension : dimensionName,
                };
            }
            
            function updateDimensionTooltip(control, dimension, tooltip)
            {
                if (dimension.labelTD != null) {
                    var labelPosition = dimension["label-position"] || control.labelPosition;
                    if (labelPosition == null || labelPosition == "top") {
                    	if (tooltip != null && tooltip != "") {
                            dimension.labelTD.innerHTML = dimension.label + "*";
                            dimension.labelTD.title = tooltip;
                    	}
                    	else {
                            dimension.labelTD.innerHTML = dimension.label;
                            dimension.labelTD.title = "";
                    	}
                    }
                    else if (labelPosition == "left") {
                    	if (tooltip != null && tooltip != "") {
                            dimension.labelTD.innerHTML = dimension.label + "*:";
                            dimension.labelTD.title = tooltip;
                    	}
                    	else {
                            dimension.labelTD.innerHTML = dimension.label + ":";
                            dimension.labelTD.title = "";
                    	}
                    }
                }
            }
            
            if (this.tile != null && this.tile.maxStatus == true) {
                // UI-161: on notify... if we are currently opened (maximized) close first
                this._doCloseFilterPanel(false);
                this._enableDimensionControls();
                this._displayDimensionControls();
                this._displayCategorySubcategory();
            }

            if (evt.model != null) {
                // model change trumps everything else...
                this._controls = [];
                this._model = evt.model;
                this._empty = JSON.stringify(this._model) == "{}";
                this._migrateModel();
                
                DEBUG("create " + this._name);
                var self = this;
                if (this._setupInProgress == true) {
                    // still in progress of setup, either from postCreate or previous onNotify
                    this._setupCompleteCallback = lang.partial(function(values) {
                        self._setUpViews(function() {
                            self._populateCategories();
                            self._completeSetUp();
                            self._applyValueChanges(values, 500);
                        });
                    }, evt.values);
                }
                else {
                    this._setUpViews(function() {
                        self._populateCategories();
                        self._completeSetUp();
                        self._applyValueChanges(evt.values, 500);
                    });
                }
                return;
            }

            if (this._setupInProgress == true) {
                var self = this;
                window.setTimeout(function() {
                    self.onNotify(evt);
                }, 50);
                return;
            }

            var changed = false;
            
            if (evt.values != null) {
                // UI-266: if setting value... do complete overwrite... so clear ALL existing values
                this._clearAllValues();
                
                DEBUG(this._name + " values=" + JSON.stringify(evt.values));
                this._applyValueChanges(evt.values, 500);
            }
            
            if (evt.defaults != null) {
                for (var key in evt.defaults) {
                	var cd = parseControlDimension(key);
                    if (cd.control != null && cd.dimension != null) {
                        for (var i=0; i<this._controls.length; i++) {
                            var control = this._controls[i];
                            if (control.name == cd.control) {
                                for (var j=0; j<control.dimensions.length; j++) {
                                    var dimension = control.dimensions[j];
                                    if (dimension.name == cd.dimension) {
                                        // found it
                                    	var value = parseValue(dimension, evt.defaults[key]);
                                    	if (value != null && value != "") {
                                            control.defaults[dimension.name] = evt.defaults[key];
                                    	}
                                    	else {
                                    		delete control.defaults[dimension.name];
                                    	}
                                        updateDimensionTooltip(control, dimension, value);
                                        break;
                                    }
                                }
                                changed = true;
                            }
                        }
                    }
                }
            }

            if (evt.actions != null) {
                for (var i=0; i<evt.actions.length; i++) {
                    var action = evt.actions[i];
                    switch (action.command) {
                        case "disable":
                            if (action.value != null) {
                                if (action.name != null) {
                                    // disable/enable SPECIFIC control.dimension
                                    var dimension = getDimensionByName(this._controls, action.name);
                                    if (dimension != null) {
                                        // found it
                                        if (action.value == true) {
                                            // disable
                                            dimension.disabled = true;
                                        }
                                        else if (action.value == false) {
                                            // enabled
                                        	dimension.disabled = false;
                                        }
                                		dimension.widget.set("disabled", dimension.disabled);
                                    	domStyle.set(this._getDimensionEnableNode(dimension), "opacity", dimension.disabled ? 0.4 : 1.0);
                                    }
                                }
                                else {
                                    // disable/enable entire widget
                                    if (action.value == true) {
                                        // disable
                                        domStyle.set(this.domNode, {
                                            "opacity" : 0.4,
                                            "pointer-events" : "none",
                                        });
                                    }
                                    else if (action.value == false) {
                                        // enabled
                                        domStyle.set(this.domNode, {
                                            "opacity" : 1.0,
                                            "pointer-events" : "auto",
                                        });
                                    }
                                }
                            }
                            break;
                        case "display":
                            if (action.value != null) {
                                if (action.name != null) {
                                    // hide/show SPECIFIC control.dimension
                                    var dimension = getDimensionByName(this._controls, action.name);
                                    if (dimension != null) {
                                        // found it
                                        if (action.value == true) {
                                            // show
                                        	//domStyle.set(this._getDimensionDisplayNode(dimension), "display", "inline-block");
                                        	domStyle.set(this._getDimensionDisplayNode(dimension), "display", "");
                                        }
                                        else if (action.value == false) {
                                            // hide
                                        	domStyle.set(this._getDimensionDisplayNode(dimension), "display", "none");
                                        }
                                    }
                                }
                                else {
                                    // hide/show entire widget
                                    var tileNode = findTileNode(this.domNode);
                                    if (tileNode != null) {
                                        // found it
                                        if (action.value == true) {
                                            // show
                                            domStyle.set(tileNode, "display", "");
                                        }
                                        else if (action.value == false) {
                                            // hide
                                            domStyle.set(tileNode, "display", "none");
                                        }
                                        this.renderer.tile.dashboardLayout.updateWidthAndHeight(this.renderer.tile.dashboardLayout.vtWidth, this.renderer.tile.dashboardLayout.vtHeight, false);
                                    }
                                }
                            }
                            break;
                    }
                }
            }
            
            if (evt.widgets != null) {
                this._widgetNotifyEvents = evt.widgets;
                this._doNotifyWidgets(null);
            }

            if (changed) {
                if (this._active == false) {
                    // widget is alive but switched out
                    // mark so that when switched back in, outputSelection
                    this._outputSelectionOnSwitchIn = true;
                }
                else {
                	this._outputSelection(true, "notify");
                }
            }]]>
        </CodeText>
        <CodeText segment="#functions">
          <![CDATA[    function addTextRow(table, htmlText, clazz, style)
    {
        var tr = domConstruct.create("tr");
        table.appendChild(tr);
        var td = domConstruct.create("td", {
            "colspan" : 2,
            "class" : clazz,
            "style" : style,
        });
        td.innerHTML = htmlText;
        tr.appendChild(td);
    }

    function addNameValueRow(table, nameText, valueText, nameClazz, nameStyle, valueClazz, valueStyle)
    {
        tr = domConstruct.create("tr");
        table.appendChild(tr);
        td = domConstruct.create("td", {
            "class" : nameClazz,
            "style" : "width:1%;padding:1px;" + (nameStyle || "")
        });
        td.innerHTML = nameText;
        tr.appendChild(td);
        td = domConstruct.create("td", {
            "class" : valueClazz,
            "style" : "width:99%;padding:1px;" + (valueStyle || "")
        });
        if (valueText != null) {
            td.innerHTML = valueText;
        }
        tr.appendChild(td);
        return td;
    }

    function getOptionsFromSQL(scriptFuncs, connection, control, dimension, selection, callback)
    {
        if (dimension.query.condition != null) {
            var ok = doEvalConditional(scriptFuncs, control.name + "." + dimension.name + ":query.condition", dimension.query.condition, selection);
            if (ok !== undefined) {
            	if (ok == false) {
            	    callback([]);
            	    return;
            	}
            }
        }
        var params = {
            op       : "executeQuery",
            url      : connection.url,
            username : connection.username,
            password : connection.password,
            limit    : 0,
        };
        var method = "post";
        var uri = "/app/ax/user/*/*";
        var headers = {
        	// HAVE TO DO client side substitution as the server side code for PreparedStatement
        	// does not currently handle array
            // sql    : dimension.sql,
            // data   : hasParams ? JSON.stringify(paramValues) : null,
        	sql    : doValueSubstitution(dimension.query.sql, selection),
        	data   : null,
            dynIn  : null,
            schema : null,
        };
        var self = this;
        doREST(method, uri, params, headers, function(t) {
            var options = [];
            if (t != null && t != "") {
                var values = JSON.parse(t);
                var uniq = {};
                array.forEach(values, function(value, index) {
                    var val = value[dimension.query.field];
                    if (uniq[val] == null) {
                        uniq[val] = true;
                        options.push({ value:val, label:val });
                    }
                });
                if (dimension.query.sortByLabel != false) {
                    options.sort(function(a,b) {
                        return a.label.localeCompare(b.label);
                    });
                }
            }
            callback(options);
        });
    }
    
    function getOptionsFromService(scriptFuncs, control, dimension, selection, sep, callback)
    {
        if (dimension.service.condition != null) {
            var ok = doEvalConditional(scriptFuncs, control.name + "." + dimension.name + ":service.condition", dimension.service.condition, selection);
            if (ok !== undefined) {
            	if (ok == false) {
            	    callback([]);
            	    return;
            	}
            }
        }
        var values = lang.clone(control.values);
        for (var key in values) {
            var value = values[key];
            if (value != null && Array.isArray(value)) {
                values[key] = [];
                for (var i=0; i<value.length; i++) {
                    if ((value[i]).indexOf(sep) != -1) {
                        (value[i]).split(sep).forEach(function(val) {
                            (values[key]).push(val);
                        });
                    }
                    else {
                        (values[key]).push(value[i]);
                    }
                }
            }
            else if (value != null && value.indexOf(sep) != -1) {
                values[key] = value.split(sep);
            }
        }
        if (selection != null && selection.length > 0) {
            for (var i=0; i<selection.length; i++) {
                values[selection[i]["name"]] = selection[i]["value"];
            }
        }
        values["$.timezoneOffset"] = (new Date()).getTimezoneOffset();
        var method = dimension.service.method.toLowerCase();
        var uri = dimension.service.url;
        var params = dimension.service.params;
        var headers = {
        	values : JSON.stringify(values),
        };
        var self = this;
        doREST(method, uri, params, headers, function(t) {
            var options = [];
            if (t != null && t != "") {
                var response = JSON.parse(t);
                if (response.status == "OK") {
                    options = response.value;
                    array.forEach(options, function(option, index) {
                        if (typeof option == "string") {
                            options[index] = { value:option, label:option };
                        }
                        else if (typeof option == "number") {
                            options[index] = { value:String(option), label:String(option) };
                        }
                        else if (option.value != null) {
                            if (typeof option.value == "number") {
                                option.value = String(option.value);
                            }
                            if (option.value != null && option.label == null) {
                                option.label = option.value;
                            }
                        }
                    });
                    if (dimension.service.sortByLabel != false) {
                        options.sort(function(a,b) {
                            return a.label.localeCompare(b.label);
                        });
                    }
                }
            }
            callback(options);
        });
    }

    function matchOptionValue(values, optionValue)
    {
        for (var i=0; i<values.length; i++) {
            if (values[i] == optionValue) return true;
        }
        return false;
    }
    
    function isValidOption(options, value, sep)
    {
        var values = value.indexOf(sep) != -1 ? value.split(sep) : [value];
        for (var i=0; i<options.length; i++) {
            if (options[i]["isGroupLabel"] != true) {
                var option = options[i]["value"];
                if (option != null) {
                    if (option.indexOf(sep) != -1) {
                        var optionValues = option.split(sep);
                        for (var j=0; j<optionValues.length; j++) {
                            if (matchOptionValue(values, optionValues[j])) return option;
                            var hash = (optionValues[j]).indexOf("#");
                            if (hash != -1 && matchOptionValue(values, (optionValues[j]).substring(0, hash))) return option;
                        }
                    }
                    else {
                        if (matchOptionValue(values, option)) return option;
                        var hash = option.indexOf("#");
                        if (hash != -1 && matchOptionValue(values, option.substring(0, hash))) return option;
                    }
                }
            }
        }
        return null;
    }

    function doEvalConditional(scriptFuncs, key, textOrExpr, selection)
    {
        var ok = false;
        var start = Date.now();
        if (typeof textOrExpr == "string") {
            // use original Javascript expression evaluator
            ok = doScriptEval(scriptFuncs, key, textOrExpr, selection);
        }
        else {
            // use new expression construct evaluator
            // similar to what is used in ServiceConfig BUT without the SQL option
            ok = doExpressionEval(textOrExpr, selection);
        }
        var end = Date.now();
        if ((end-start) > 1) {
            DEBUG(key + ": " + (end-start) + " ms");
        }
        return ok;
    }
    
    function doScriptEval(scriptFuncs, key, text, selection)
    {
        var func = null;
        if (scriptFuncs != null) {
            func = scriptFuncs[key];
        }
        if (func == null) {
        	var expr = getFilterValueSubstitution(text, selection);
            var ok = expr.indexOf("${") == -1;
            if (ok) {
            	// make sure all variables has been replaced... else will cause JS exception
            	try {
                	func = new Function("helper", expr);
                    if (scriptFuncs != null) {
                    	scriptFuncs[key] = func;
                    }
            	}
            	catch (err) {
                    scriptFuncs[key] = "SCRIPT_ERROR";
            	    console.error("Script Error");
            	    console.error(expr);
            	    debugger;
            	}
            }
            else {
                // DONT'T flag this... what may be incomplete at one time may be become complete later
            }
        }
        if (func != null && typeof func == "function") {
        	var result = func(getScriptHelper(selection));
        	return result;
        }
        else {
            return undefined;
        }
    }

    function doExpressionEval(exprs, selection)
    {
        function doEvalExprNode(expr, filters)
        {
            function getFilterValue(filterName)
            {
                for (var i=0; i<filters.length; i++) {
                    if (filters[i]["name"] == filterName) {
                        return filters[i]["value"];
                    }
                }
                return null;
            }
            var value = getFilterValue(expr.name);
            if (value == null) {
                if (expr.value == null) {
                    return expr.not == true ? false : true;
                }
                else {
                    return false;
                }
            }
            else {
                if (expr.value == null) {
                    return expr.not == true;
                }
                else if (Array.isArray(value)) {
                    if (Array.isArray(expr.value)) {
                        for (var i=0; i<value.length; i++) {
                            if (expr.value.indexOf(stripFragmentHash(value[i])) != -1) return true;
                        }
                    }
                    else {
                        for (var i=0; i<value.length; i++) {
                            if (expr.value == stripFragmentHash(value[i])) return true;
                        }
                    }
                    return false;
                }
                else if (typeof value == "string") {
                    if (Array.isArray(expr.value)) {
                        return expr.value.indexOf(stripFragmentHash(value)) != -1;
                    }
                    else {
                        return stripFragmentHash(value) == String(expr.value);
                    }
                }
                else if (typeof value == "number") {
                    return Number(value) == Number(expr.value);
                }
                else {
                    return false;
                }
            }
        }

        // expr is an array of conditions... ANDed together so first false will short-circuit
        if (exprs == null || !Array.isArray(exprs)) return null;
        for (var i=0; i<exprs.length; i++) {
            var expr = exprs[i];
            if (expr.or && Array.isArray(expr.or)) {
                var ok = false;
                for (var j=0; j<expr.or.length; j++) {
                    ok = doEvalExprNode(expr.or[j], selection);
                    if (ok) break;
                }
                if (!ok) return false;
            }
            else if (expr.and) {
                var ok = true;
                for (var j=0; j<expr.and.length; j++) {
                    ok = doEvalExprNode(expr.and[j], selection);
                    if (!ok) break;
                }
                if (!ok) return false;
            }
            else if (expr.name) {
                if (!doEvalExprNode(expr, selection)) return false;
            }
            else {
                // invalid structure
                return false;
            }
        }
        return true;
    }

    function stripFragmentHash(value)
    {
        if (value == null) return value;
        value = String(value);
        var hash = value.indexOf("#");
        return hash != -1 ? value.substring(0, hash) : value;
    }
    
    function getScriptHelper(filters)
    {
        return {
            filters : filters,
            getFilterValue : function(filterName) {
                for (var i=0; i<filters.length; i++) {
                    if (filters[i]["name"] == filterName) {
                        return filters[i]["value"];
                    }
                }
                return null;
            },
            isSet : function(value) {
                if (value == undefined || value == null) return false;
                if (typeof value == "string") {
                    return value != "" && value != "#####";
                }
                else if (Array.isArray(value)) {
                    return value.length > 0;
                }
                return String(value) != "";
            },
            has : function(value, terms) {
                if (value != null && Array.isArray(terms)) {
                    if (typeof value == "string") {
                        for (var i=0; i<terms.length; i++) {
                            if (stripFragmentHash(value) == stripFragmentHash(terms[i])) return true;
                        }
                    }
                    else if (Array.isArray(value)) {
                        for (var i=0; i<value.length; i++) {
                            for (var j=0; j<terms.length; j++) {
                                if (stripFragmentHash(value[i]) == stripFragmentHash(terms[j])) return true;
                            }
                        }
                    }
                }
                return false;
            },
            getPlugin : function(pluginNameOrPath) {
                return Plugin(pluginNameOrPath);
            },
        };
    }

    function getFilterValueSubstitution(text, selection)
    {
        for (var i=0; i<selection.length; i++) {
            var token = "${"+selection[i]["name"]+"}";
            var start = text.indexOf(token);
            while (start != -1) {
                var end = start + token.length;
                text = text.substring(0, start) + "helper.getFilterValue('"+selection[i]["name"]+"')" + text.substring(end);
                start = text.indexOf(token, start);
            }
        }
        return text;
    }

    function doValueSubstitution(text, selection)
    {
        for (var i=0; i<selection.length; i++) {
            var value = cleanValue(selection[i]["type"], selection[i]["value"]);
            var token = "${"+selection[i]["name"]+"}";
            var start = text.indexOf(token);
            while (start != -1) {
                var end = start + token.length;
                text = text.substring(0, start) + value + text.substring(end);
                start = text.indexOf(token, start);
            }
        }
        return text;
    }
    
    function escapeSingleQuote(value)
    {
        if (value.indexOf("'") != -1) {
            var toks = value.split("'");
            value = toks.join("\\'");
        }
        return value;
    }
    
    function cleanValue(type, value)
    {
        switch (type) {
            case "choice":
                if (value != null && typeof value == "string") {
                    if (value == "") {
                        value = [];
                    }
                    else {
                        value = value.split(",");
                    }
                }
                break;
        }
        if (value != null && Array.isArray(value)) {
            if (value.length == 0) {
                // if value is array and empty, assume will be used in X in (Y) clause
                // SQL does not like empty clause... as X in ()
                // SO we put a DUMMY value to guarantee no match, eg. #####
                value = "'#####'";
            }
            else {
                var buf = [];
                for (var j=0; j<value.length; j++) {
                    buf.push("'" + escapeSingleQuote(value[j]) + "'");
                }
                value = "[" + buf.join(", ") + "]";
            }
        }
        else if (value != null && typeof value == "string") {
            value = '"' + escapeSingleQuote(value) + '"';
        }
        return value;
    }

	function newInstance(clazz, args, scope)
	{
        return new (Function.prototype.bind.apply(clazz, [scope].concat(args)));
	}
	
    function getCookiePath(controller, tile)
    {
        if (!controller || !controller.appController || !controller.initialConfig.item || !tile) return null;

        var buf = [];
        if (controller.appController.modelHierarchy != null) {
            for (var i=0; i<controller.appController.modelHierarchy.length; i++) {
                var model = controller.appController.modelHierarchy[i];
                var toks = model.split("/");
                if (toks.length == 7) {
                    buf.push(toks[4] + "#" + toks[6]);
                }
            }
        }
        if (controller.appController.parentEventRef != null) {
            buf = buf.concat(controller.appController.parentEventRef.path);
            buf.push(controller.appController.parentEventRef.name);
        }
        buf.push(controller.initialConfig.item.owner + "#" + controller.initialConfig.item.name);

        if (!tile.modelTitle) {
            buf.push(tile.modelTitle);
        }
        else if (tile.tileTitle) {
            buf.push(tile.tileTitle);
        }
        else if (tile.currentTileInfo) {
            var tileInfoName = tile.currentTileInfo.getAttribute("name");
            if (tileInfoName) {
                buf.push(tileInfoName);
            }
        }
        return buf.join("/");
    }
	
    function getCookie(path, name, defaultValue)
    {
        if (path != null) {
            var cookieName = encodeURIComponent(path + "." + name);
            var value = null;
            if (window.localStorage) {
                value = window.localStorage.getItem(cookieName);
            } else {
                value = cookie(cookieName);
            }
            if (value != null) {
                value = decodeURIComponent(value);
                if (value == "[object Object]") {
                    return defaultValue;
                }
                value = JSON.parse(value, jsonParseEncoder);
            } else {
                value = defaultValue;
            }
            return value;
        }
        return defaultValue;
    }

    function setCookie(path, name, value)
    {
        if (path != null) {
            var cookieName = encodeURIComponent(path + "." + name);
            if (value != null) {
                value = JSON.stringify(value);
                if (window.localStorage) {
                    window.localStorage.setItem(cookieName, encodeURIComponent(value));
                } else {
                    cookie(cookieName, encodeURIComponent(value), {expires: 30});
                }
            } else {
                if (window.localStorage) {
                    window.localStorage.removeItem(cookieName);
                } else {
                    cookie(cookieName, null, {expires: -1});
                }
            }
        }
    }
    
    // see http://weblog.west-wind.com/posts/2014/Jan/06/JavaScript-JSON-Date-Parsing-and-real-Dates
    function jsonParseEncoder(key, value)
    {
        var reISO = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*))(?:Z|(\+|-)([\d|:]*))?$/;
        var reJSONStringer = /^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2}(?:\.\d*))(?:Z|(\+|-)([\d|:]*))?$/;
        var reMsAjax = /^\/Date\((d|-|.*)\)[\/|\\]$/;
        var reJava = /^(\d{4})\/(\d{2})\/(\d{2}) (\d{2}):(\d{2}):(\d{2}(?:\.\d*))(?:Z|(\+|-)([\d|:]*))?$/;

        if (typeof value === 'string') {
            var a = reJSONStringer.exec(value);
            if (a) {
                return new Date(value);
            }
            var a = reISO.exec(value);
            if (a) {
                return new Date(value);
            }
            var a = reJava.exec(value);
            if (a) {
                return new Date(value);
            }
            var a = reMsAjax.exec(value);
            if (a) {
                var b = a[1].split(/[-+,.]/);
                return new Date(b[0] ? +b[0] : 0 - +b[1]);
            }
        }
        return value;
    }
    
    // this is a HOOK back out to client-side library function
    function getCurrentUnixTime()
    {
        var dt = new Date();
        return Math.floor(dt.getTime() / 1000);
    }
    
    function createTimeIntervalTextBox(name, parentNode, value, style, tooltip, dimension, callback)
    {
        var intervalType = "absolute";
        if (dimension.type == "timeinterval/relative") {
            intervalType = "relative";
        }
        else if (dimension.type == "timeinterval/timeslice") {
            intervalType = "timeslice";
        }
        var DEFAULT_STYLE = "background-color:white;height:auto;border:1px solid #999999;padding:3px;";
        if (style == null || style == "") {
            if (intervalType == "absolute") {
                style = DEFAULT_STYLE + "height:22px;width:310px;white-space:nowrap;";
            }
            else if (intervalType == "relative") {
                style = DEFAULT_STYLE + "height:22px;width:400px;white-space:nowrap;";
            }
            else if (intervalType == "timeslice") {
                style = DEFAULT_STYLE + "height:22px;width:140px;white-space:nowrap;";
            }
            else {
                style = DEFAULT_STYLE;
            }
        }
        else {
            style = DEFAULT_STYLE + style;
        }
        if (value == null || value == "") {
            var now = new Date();
            if (intervalType == "absolute") {
                value = now.toISOString() + "/" + now.toISOString();
            }
            else if (intervalType == "relative") {
                value = now.toISOString() + "/P1" + (dimension.unit || "D");
            }
            else if (intervalType == "timeslice") {
                value = "S1D/" + now.toISOString();
            }
        }
        if (intervalType == "absolute") {
            if (value.indexOf("absolute:") == 0) {
                value = value.substring("absolute:".length);
            }
        }
        var prevValue = value;
        function onChangeCallback(item, commitValue /*optional*/) {
            if (item.value !== prevValue) {
                callback({name: item.name, value: item.value, prev: prevValue});
                prevValue = item.value;
            }
        }
        var config = {
            name       : name,
            value      : value.toString(),
            label      : name,
            onChange   : onChangeCallback,
            buttonMode : "button",
            type       : intervalType,
        };
        if (intervalType == "absolute") {
            if (dimension.minInterval != null) {
                config.minInterval = dimension.minInterval;
            }
            if (dimension.secInterval != null) {
                config.secInterval = dimension.secInterval;
            }
            if (dimension.minHide != null) {
                config.minHide = dimension.minHide;
            }
            if (dimension.secHide != null) {
                config.secHide = dimension.secHide;
            }
        }
        else if (intervalType == "relative") {
            config.constraints = dimension.constraints || {};
            config.dateEditable = dimension.dateEditable != null ? dimension.dateEditable : true;
            config.direction = dimension.direction || "P";
            config.directionEditable = dimension.directionEditable != null ? dimension.directionEditable : true;
            config.intervalValue = dimension.intervalValue || "1";
            config.intervalValueEditable = dimension.intervalValueEditable != null ? dimension.intervalValueEditable : true;
            config.unit = dimension.unit || "D";
            config.unitEditable = dimension.unitEditable != null ? dimension.unitEditable : true;
            config.useCurrent = dimension.useCurrent != null ? dimension.useCurrent : true;
        }
        else if (intervalType == "timeslice") {
            config.constraints = dimension.constraints || {};
            config.dateEditable = dimension.dateEditable != null ? dimension.dateEditable : true;
            config.useCurrent = dimension.useCurrent != null ? dimension.useCurrent : true;
        }
        if (style != null) {
            config.style = style;
        }
        var timeIntervalBox = ViewerUtil.makeControl("timeinterval", config);
        timeIntervalBox.placeAt(parentNode);
        if (intervalType == "absolute") {
            domClass.add(timeIntervalBox.domNode, "absolute-time-interval-control");
        }
        else if (intervalType == "relative") {
            domClass.add(timeIntervalBox.domNode, "relative-time-interval-control");
        }
        else if (intervalType == "timeslice") {
            domClass.add(timeIntervalBox.domNode, "timeslice-time-interval-control");
        }
        return timeIntervalBox;
    }

    function parseDateValue(value)
    {
        if (Array.isArray(value)) {
            // applies to this form, but specified as an array of numbers, eg. [99, 5, 24, 11, 33, 30, 0]
            // var d = new Date(99, 5, 24, 11, 33, 30, 0);
            value = newInstance(Date, value);
        }
        else if (typeof value == "string") {
            if (value.toLowerCase() == "now") {
                // get current time (to seconds)
                value = new Date(getCurrentUnixTime() * 1000);
            }
            else if (value.charAt(0) == "+") {
                // number of seconds after now (in the future)
                var delta = Number(value.substring(1));
                if (!isNaN(delta)) {
                    var unixTime = getCurrentUnixTime() + delta;
                    value = new Date(unixTime * 1000);
                }
            }
            else if (value.charAt(0) == "-") {
                // number of seconds before now (in the past)
                var delta = Number(value.substring(1));
                if (!isNaN(delta)) {
                    var unixTime = getCurrentUnixTime() - delta;
                    value = new Date(unixTime * 1000);
                }
            }
            else if (value.indexOf("now+") == 0) {
                // number of seconds after now (in the future)
                var delta = Number(value.substring(4));
                if (!isNaN(delta)) {
                    var unixTime = getCurrentUnixTime() + delta;
                    value = new Date(unixTime * 1000);
                }
            }
            else if (value.indexOf("now-") == 0) {
                // number of seconds before now (in the past)
                var delta = Number(value.substring(4));
                if (!isNaN(delta)) {
                    var unixTime = getCurrentUnixTime() - delta;
                    value = new Date(unixTime * 1000);
                }
            }
            else if (value.toLowerCase() == "today") {
                // get time (to start of today)
                value = new Date(getCurrentUnixTime() * 1000);
                value.setHours(0, 0, 0);
            }
            else if (value.indexOf("today+") == 0) {
                // number of days (24 hours) after start of today (in the future)
                // not sure if this works when it crosses daylight saving transition...
                // appears to work... but should do more tests
                var delta = Number(value.substring(6));
                if (!isNaN(delta)) {
                    value = new Date(getCurrentUnixTime() * 1000);
                    value.setHours(0, 0, 0);
                    value.setDate(value.getDate() + delta);
                }
            }
            else if (value.indexOf("today-") == 0) {
                // number of days (24 hours) before start of today (in the past)
                // not sure if this works when it crosses daylight saving transition...
                // appears to work... but should do more tests
                var delta = Number(value.substring(6));
                if (!isNaN(delta)) {
                    value = new Date(getCurrentUnixTime() * 1000);
                    value.setHours(0, 0, 0);
                    value.setDate(value.getDate() - delta);
                }
            }
            else if (!isNaN(Number(value))) {
                // unixtime
                value = new Date(Number(value)*1000);
            }
            else {
                // applies to this form
                // var d = new Date("October 13, 2014 11:13:00");
                value = new Date(value);
            }
        }
        else if (typeof value == "number") {
            // applies to this form, but in UNIXTIME (secs)
            // var d = new Date(86400000);
            value = new Date(value * 1000);
        }
        return value;
    }

    function migrateDimension(dimension)
    {
        if (dimension.sql != null && dimension.field != null) {
            // restruture to query : {sql, field}
            if (dimension.query == null) {
                dimension.query = {};
            }
            dimension.query.sql = dimension.sql;
            dimension.query.field = dimension.field;
            delete dimension.sql;
            delete dimension.field;
        }
    }
    
    function findTileNode(node)
    {
        while (node != null) {
            if (domClass.contains(node, "pageFrameLayout")) {
                return null;
            }
            if (node.getAttribute("data-vitria-type") != null) {
                // found it
                return node;
            }
            node = node.parentNode;
        }
        return null;
    }
    
    function adjustForLocalTime(value)
    {
        var unixtime = Number(value);
        if (!isNaN(unixtime)) {
            value = unixtime * 1000;
        }
        var dt = new Date(value);
        dt = new Date(dt.getTime() - (dt.getTimezoneOffset()*60*1000));
        return dt.toISOString();
    }
    
    function loadDialogClass(dialogPath, callback)
    {
        require([dialogPath, "dojo/domReady!"], function(PopupDialogClazz) {
            callback(PopupDialogClazz);
        });
    }

    function loadCustomWidgetClass(widgetPath, callback)
    {
        if (widgetPath.indexOf("/app/dbp/") == 0 || widgetPath.indexOf("/") == -1) {
            // user defined widget... either full path or just name
            Widget(widgetPath, function(CustomWidget) {
                callback(CustomWidget);
            });
        }
        else {
            // builtin
            require([widgetPath, "dojo/domReady!"], callback);
        }
    }
    
    function parseStyleString(str)
    {
        var style = null;
        var toks1 = str.split(";");
        for (var i=0; i<toks1.length; i++) {
            var toks2 = (toks1[i]).split("=");
            if (toks2.length == 1) {
                // try ':'
                toks2 = (toks1[i]).split(":");
            }
            if (toks2.length == 2) {
                if (style == null) {
                    style = {};
                }
                style[toks2[0]] = toks2[1];
            }
        }
        return style;
    }

    function getDimensionValueAsString(dimension, value)
    {
        if (value != null) {
            if (dimension["$getValueAsString"] != null) {
                // if model defines this... use it... can be used to override what is defined in the widget
                var getValueAsString = dimension["$getValueAsString"];
                if (getValueAsString.charAt(0) == "@") {
                    // script in resource
                    Resource(getValueAsString.substring(1), function(scriptText) {
                        var func = new Function("value", "dimension", scriptText);
                        var result = func(value, dimension);
                        return result != null ? result : "";
                    });
                }
                else {
                    // inline script
                    var func = new Function("value", "dimension", getValueAsString);
                    var result = func(value, dimension);
                    return result != null ? result : "";
                }
            }
            else if (dimension._getValueAsString != null && typeof dimension._getValueAsString == "function") {
                // defined in widget
                var result = dimension._getValueAsString(value, dimension);
                return result != null ? result : "";
            }
            else if (Array.isArray(value) && value.length > 0) {
                // LOOK for "_label" attribute on items to use for display
                var label = [];
                for (var i=0; i<value.length; i++) {
                    if (value[i]["_label"] != null) {
                        label.push(value[i]["_label"]);
                    }
                }
                return label.length > 0 ? label.join(",") : "Set";
            }
            else if (String(value) == "[object Object]" && value["_label"] != null) {
                return value["_label"];
            }
            else {
                return "Set";
            }
        }
        else {
            return "";
        }
    }

    function getDimensionByName(controls, name)
    {
        var toks = name.split(".");
        if (toks.length == 2) {
            var controlName = toks[0];
            var dimensionName = toks[1];
            for (var i=0; i<controls.length; i++) {
                var control = controls[i];
                if (control.name == controlName) {
                    for (var j=0; j<control.dimensions.length; j++) {
                        var dimension = control.dimensions[j];
                        if (dimension.name == dimensionName && dimension.widget != null) {
                            return dimension;
                        }
                    }
                }
            }
        }
        return null;
    }

    function parseTimeInterval(value)
    {
    	if (Array.isArray(value) && value.length == 1 && (typeof value[0] == "string")) {
    	    // if array of 1 string, put it out
    	    value = value[0];
    	}
    	// enhanced to support new compound format
    	// predefined:XXX
    	// absolute:###/###
    	// ["predefined", "XXX"]
    	// ["absolute", ###, ###]
    	if (Array.isArray(value)) {
    		// expects array of 2 array
    		if (value.length == 2) {
    			if (value[0] == "predefined") {
    				return "predefined:" + value[1];
    			}
    			else {
    				// old format... assume [FROM, TO]
    				// values for FROM/TO can be one of the following
    				// - valid date string, eg. October 13, 2014 11:13:00
    				// - epoch (# secs from 1970), eg. 1548272836
    				// - now
    				// - # seconds after now, eg. +30 or now+30
    				// - # seconds before now, eg. -30 or now-30
    				// - begining of today, eg. today
    				// - # days after today, eg. today+2
    				// - # days before start of today, eg. today-2
    				var from = parseDateValue(value[0]);
    				var to = parseDateValue(value[1]);
    				return "absolute:" + getUnixTime(from, true) + "/" + getUnixTime(to, true);
    				//return "absolute:" + from.toISOString() + "/" + to.toISOString();
    			}
    		}
    		else if (value.length == 3) {
    			if (value[0] == "absolute") {
    				var from = parseDateValue(value[1]);
    				var to = parseDateValue(value[2]);
    				return "absolute:" + getUnixTime(from, true) + "/" + getUnixTime(to, true);
    				// return "absolute:" + from.toISOString() + "/" + to.toISOString();
    			}
    		}
    	}
    	else if (typeof value == "string") {
    		var colon = value.indexOf(":");
    		var predefined = colon != -1 ? value.substring(0, colon) == "predefined" : false;
    		var absolute = colon != -1 ? value.substring(0, colon) == "absolute" : false;
    		var slash = value.indexOf("/");
    		if (!predefined && !absolute) {
    			var toks = value.split("/");
    			if (toks.length == 2) {
    				// old format... assume FROM/TO
    				// values for FROM/TO can be one of the following
    				// - valid date string, eg. October 13, 2014 11:13:00
    				// - epoch (# secs from 1970), eg. 1548272836
    				// - now
    				// - # seconds after now, eg. +30 or now+30
    				// - # seconds before now, eg. -30 or now-30
    				// - begining of today, eg. today
    				// - # days after today, eg. today+2
    				// - # days before start of today, eg. today-2
    				var from = parseDateValue(toks[0]);
    				var to = parseDateValue(toks[1]);
    				return "absolute:" + getUnixTime(from, true) + "/" + getUnixTime(to, true);
    				// return "absolute:" + from.toISOString() + "/" + to.toISOString();
    			}
    		}
    		else if (predefined && slash == -1) {
    			// predefined:XXX
				return "predefined:" + value.substring(colon+1);
    		}
    		else if (absolute && slash != -1) {
    			// absolute:###/###
				var from = parseDateValue(value.substring(colon+1, slash));
				var to = parseDateValue(value.substring(slash+1));
    			return "absolute:" + getUnixTime(from, true) + "/" + getUnixTime(to, true);
				// return "absolute:" + from.toISOString() + "/" + to.toISOString();
    		}
    	}
    	return null;
    }
    
    function parseAbsoluteTimeInterval(value)
    {
    	if (Array.isArray(value)) {
    		// expects array of 2 array
    		if (value.length == 2) {
    			var from = parseDateValue(value[0]);
    			var to = parseDateValue(value[1]);
    			return from.toISOString() + "/" + to.toISOString();
    		}
    	}
    	else if (typeof value == "string" && value.indexOf("/") != -1) {
    		var toks = value.split("/");
    		if (toks.length == 2) {
    			var from = parseDateValue(toks[0]);
    			var to = parseDateValue(toks[1]);
    			return from.toISOString() + "/" + to.toISOString();
    		}
    	}
    	return null;
    }
    
    function parseRelativeTimeInterval(value)
    {
    	if (typeof value == "string" && value.indexOf("/") != -1) {
    		var toks = value.split("/");
    		if (toks.length == 2) {
    			if ((toks[0]).charAt(0) == "P") {
    				// duration/time
    				var dt = parseDateValue(toks[1]);
    				return toks[0] + "/" + dt.toISOString();
    			}
    			else if ((toks[1]).charAt(0) == "P") {
    				// time/duration
    				var dt = parseDateValue(toks[0]);
    				return dt.toISOString() + "/" + toks[1];
    			}
    		}
    	}
    	return null;
    }
    
    function parseTimeSliceInterval(value)
    {
    	if (typeof value == "string" && value.indexOf("/") != -1) {
    		var toks = value.split("/");
    		if (toks.length == 2) {
    			if ((toks[0]).charAt(0) == "S") {
    				// slice/time
    				var dt = parseDateValue(toks[1]);
    				return toks[0] + "/" + dt.toISOString();
    			}
    		}
    	}
    	return null;
    }

    function getUnixTime(dt, asLocalTime)
    {
        if (asLocalTime == true) {
            // return value selected as local time
            return Math.floor(dt.getTime() / 1000);
        }
        else {
            // default (for backward compat) is to treat and return value selected as GMT time
            var utc = Date.UTC(dt.getFullYear(), dt.getMonth(), dt.getDate(), dt.getHours(), dt.getMinutes(), dt.getSeconds());
            return Math.floor(utc / 1000);
        }
    }
    
    function getDimensionDataType(dimension)
    {
        var dataType = dimension.type;
        if (dimension["data-type"] != null) {
            dataType = dimension["data-type"];
        }
        return dataType;
    }
    
    function isPopupDimension(dimension)
    {
        if (dimension["fa-control"] == true && dimension["dependent"] != null && dimension["type"] == "enumeration" && dimension["position-float"] == true) {
            return true;
        }
        return false;
    }

    function parseValue(dimension, value)
    {
        switch (getDimensionDataType(dimension)) {
            case "choice":
                if (typeof value == "string") {
                    value = value.split(",");
                }
                break;
            case "date":
            case "time":
            case "datetime":
        	case "timestamp":
        	    // see https://www.w3schools.com/js/js_dates.asp for more detail
    			if (value != null && value != "") {
    			    value = parseDateValue(value);
    			}
    			break;
            case "timeinterval":
                // enhanced to support new compound format
                // predefined:XXX
                // absolute:###/###
                // ["predefined", "XXX"]
                // ["absolute", ###, ###]
                if (value != null && value != "") {
                    value = parseTimeInterval(value);
                }
                break;
            case "timeinterval/absolute":
                if (value != null && value != "") {
                    value = parseAbsoluteTimeInterval(value);
                }
                break;
            case "timeinterval/relative":
                if (value != null && value != "") {
                    value = parseRelativeTimeInterval(value);
                }
                break;
            case "timeinterval/timeslice":
                if (value != null && value != "") {
                    value = parseTimeSliceInterval(value);
                }
                break;
        }
        return value;
    }

    function applyChangeList(self, startMS, list, callback)
    {
        require(["af/utils/Indicator", "dojo/domReady!"], function(Indicator) {
			if (startMS == 0) {
				startMS = Date.now();
				Indicator.busy({id:"via.common.applyChangeList", label:"Updating dimension filters..."});
			}
			if (list.length == 0) {
				Indicator.release({id:"via.common.applyChangeList"});
				console.debug("###### applyChangeList: elapsed=" + (Date.now() - startMS) + "ms");
				callback();
			}
			else {
				var item = list.shift();
				if (item.value != null) {
					if (Array.isArray(item.value) && item.value.length > 0) {
						DEBUG(self._name + " " + item.control.name + "." + item.dimension.name + "=" + JSON.stringify(item.value));
					}
					if (item.control.lastSetValues == null) item.control.lastSetValues = {};
					item.control.lastSetValues[item.dimension.name] = item.value;
					item.control.values[item.dimension.name] = item.value;
					if (Array.isArray(item.value) && item.value.length > 0) {
						DEBUG(self._name + " " + item.control.name + "/values==" + JSON.stringify(item.control.values));
						DEBUG(self._name + " " + item.control.name + "/lastSetValues=" + JSON.stringify(item.control.lastSetValues));
					}
				}
				else {
					delete item.control.values[item.dimension.name];
				}
				self._updateDimensionControl(item.control, item.index, null, function() {
					if (Array.isArray(item.value) && item.value.length > 0) {
						DEBUG(self._name + " " + item.control.name + "/values/=" + JSON.stringify(item.control.values));
					}
					applyChangeList(self, startMS, list, callback);
				});
			}
		});
    }

    function DEBUG(str)
    {
        //console.debug("DIMENSIONFILTER: " + str);
    }
    
    // temporary work-around to support grouping
    // code patched in 3.7.1 BUT need work-around to work in 3.7
    // -engkee
    function FormUtil_createMultiSelect(name, parentNode, choices, values, style, tooltip, callback)
    {
        if (choices == null) choices = [];
        if (values != null && typeof values == "string") values = values.split(",");
        else choices = lang.clone(choices);
        var options = [];
        var constraints = [];
        var selected = [];
        array.forEach(choices, function(choice, index) {
            if (choice.isGroupLabel == true) {
                var option = {
                    id           : generateRandomUuid(),
                    label        : choice.label,
                    isGroupLabel : true,
                };
                options.push(option);
            }
            else {
                var option = {
                    id    : choice.value,
                    label : choice.label,
                };
                options.push(option);
                constraints.push(option.id);
                if (values != null && values.indexOf(choice.value) != -1) {
                    selected.push(option.id);
                }
            }
        });
        var config = {
            options      : options, 
            multiple     : "true",
            enableAll    : "true",
            enableOthers : "false",
            withQuotes   : "false",
        };
        var onSelect = null;
        if (callback != null) {
            var prevValue = selected;
            onSelect = function(item) {
                var selected = item.value.split(",").sort();
                if (JSON.stringify(selected) !== JSON.stringify(prevValue)) {
                    callback({name: name, value: selected, prev: prevValue});
                    prevValue = selected;
                }
            };
        }
        var select = ViewerUtil.createControlString(name, "enumeration", constraints.join(","), selected.join(","), config, null, onSelect, style, 'button');
        if (tooltip != null) {
            select.set("title", tooltip);
        }
        select.placeAt(parentNode);
        return select;
    }
]]>
        </CodeText>
        <CodeText segment="#updateWidthAndHeight">
          <![CDATA[            ]]>
        </CodeText>
        <CodeText segment="undefined">
          <![CDATA[]]>
        </CodeText>
        <CodeText segment="#onTileMaxsize">
          <![CDATA[            if (this.tile != null) {
            	this.tile.updateUIEvent([{
                    "__TYPE__" : "onMaxSize",
                    "__EVENT__" : {
                        "properties" : this.initialConfig.properties,
                        "tile" : {
                            "name" : this.tile.modelName,
                            "title" : this.tile.modelTitle
                        }
                    }
                }]);
            }]]>
        </CodeText>
        <CodeText segment="#onTileMinisize">
          <![CDATA[            if (this.tile != null) {
            	this.tile.updateUIEvent([{
                    "__TYPE__" : "onRegSize",
                    "__EVENT__" : {
                        "properties" : this.initialConfig.properties,
                        "tile" : {
                            "name" : this.tile.modelName,
                            "title" : this.tile.modelTitle
                        }
                    }
                }]);
            }]]>
        </CodeText>
        <CodeText segment="#constructor">
          <![CDATA[
            this.OPTION_VALUE_SEP = "@@@";]]>
        </CodeText>
        <HtmlText>
          <![CDATA[<div style="width:100%;height:100%;">
    <style>
        @import '/vitria-oi/rest/app/dbp/user/via_common/dbpm/VIA - Common/VIA-CSS';

        .common-plugin.dimension-filter .main-div-minimized {
            width:calc(100% - 60px);
            height:calc(100% - 50px);
            padding-left:20px;
            padding-right:20px;
            padding-bottom:20px;
            background-color:white;
        }
        .common-plugin.dimension-filter .main-div-inline {
            width:100%;
            height:100%;
        }
        .common-plugin.dimension-filter .category-table {
        	padding-bottom:10px;
        }
        .common-plugin.dimension-filter .category-label {
        	font-size:large;
        	font-weight:bold;
        	padding-left:0px;
        }
        .common-plugin.dimension-filter .category-control-name {
        	padding-left:10px;
        	padding-bottom:0px;
        }
        .common-plugin.dimension-filter .category-control-value {
        	padding:10px;
        	padding-top:5px;
        	padding-bottom:0px;
        	white-space:normal;
        }
        .common-plugin.dimension-filter .subcategory-control-name {
        	padding-left:25px;
        	padding-bottom:0px;
        	font-weight:bold;
        }
        .common-plugin.dimension-filter .subcategory-control-value {
        	padding:10px;
        	padding-top:5px;
        	padding-bottom:0px;
        	white-space:normal;
        }
        .common-plugin.dimension-filter .dimension-disabled .dimension-control {
        	opacity:0.4;
        }
        .common-plugin.dimension-filter .dimension-disabled .dimension-control.popup-reset-button {
        	opacity:1.0;
        }
        .common-plugin.dimension-filter .click-to-open-div {
        	width:calc(100% - 5px);
        	height:20px;
        	text-align:right;
        }
        .common-plugin.dimension-filter .highlight {
        	background-color: rgba(20, 138, 196, 0.8);
        	color: white;
        }
        .common-plugin.dimension-filter div.highlight:hover {
        	background-color: rgba(20, 138, 196, 0.5) !important;
        }
        .common-plugin.dimension-filter span.click-to-open-link {
            cursor:pointer;
        }
        .common-plugin.dimension-filter div.click-to-open-link {
            cursor:pointer;
            margin-left: 20px;
            margin-right: 20px;
            border-radius: 10px;
            text-align:center;
        }
        .common-plugin.dimension-filter div.click-to-open-link:hover {
            background-color:#e9e9e9;
        }
        .common-plugin.dimension-filter span.click-for-summary-link {
            cursor:pointer;
            padding-left:10px;
        }
        .common-plugin.dimension-filter div.click-for-summary-link {
            cursor:pointer;
            margin-left: 20px;
            margin-right: 20px;
            border-radius: 10px;
            text-align:center;
        }
        .common-plugin.dimension-filter div.click-for-summary-link:hover {
            background-color:#e9e9e9;
        }
        .common-plugin.dimension-filter .ok-cancel-div {
        	width:calc(100% - 10px);
        	height:20px;
        	text-align:right;
        }
        .common-plugin.dimension-filter .minimized-div {
        	width:calc(100% - 5px);
        	height:calc(100% - 20px);
        	overflow-x:hidden;
        	overflow-y:auto;
        }
        .common-plugin.dimension-filter .string-control {
            border:thin solid lightgray;
        	height:20px;
        }
        .common-plugin.dimension-filter .enumeration-control {
        	border:thin solid lightgray;
        	min-width:100px;
        	font-family:arial;
        }
        .common-plugin.dimension-filter .choice-control {
        	border:thin solid lightgray;
        	min-width:100px;
        	font-family:arial;
        }
        .common-plugin.dimension-filter .enumeration-fa-bar-control {
        	border:thin solid lightgray;
        }
        .common-plugin.dimension-filter .enumeration-fa-bar-control.is-empty {
        	border:none;
        }
        .common-plugin.dimension-filter .choice-fa-bar-control {
        	border:thin solid lightgray;
        }
        .common-plugin.dimension-filter .choice-fa-bar-control.is-empty {
        	border:none;
        }
        .common-plugin.dimension-filter .date-control {
        	min-width:100px;
        	whitespace:nowrap;
        }
        .common-plugin.dimension-filter .time-control {
        	min-width:100px;
        	whitespace:nowrap;
        }
        .common-plugin.dimension-filter .date-time-control {
        	width:auto;
        	whitespace:nowrap;
        }
        .common-plugin.dimension-filter .time-interval-control {
        	white-space:nowrap;
        	padding-top:2px !important;
        	padding-bottom:1px !important;
        }
        .common-plugin.dimension-filter .absolute-time-interval-control .datetimeBox {
        	padding-left:10px !important;
        }
        .common-plugin.dimension-filter .relative-time-interval-control .clickableText {
        	width:auto !important;
        }
        .common-plugin.dimension-filter .popup-button-control {
            font-size:7pt;
            font-family:arial;
            border-radius:2px;
            margin-top:3px;
        }
        .common-plugin.dimension-filter .popup-text-control {
            border:thin solid lightgray;
            background-color:#efefef;
            font-family:monospace;
            color:black;
            min-width:100px;
        	height:20px;
        	pointer-events:none;
        }
        .common-plugin.dimension-filter .minimized-category-text {
        	font-weight:bold;
        	padding:3px;
        }
        .common-plugin.dimension-filter .minimized-name {
        	padding-left:10px;
        }
        .common-plugin.dimension-filter .minimized-value {
        	
        }
        .common-plugin.dimension-filter .no-filter-text {
        	font-style:italic;
        	padding:3px;
        }
        .common-plugin.dimension-filter .time-interval-text-box {
        	background-color:white;
        	height:auto;
        	border:1px solid #999999;
        	padding:3px;
        }
        .common-plugin.dimension-filter .message-table {
            padding-bottom:10px;
        }
        .common-plugin.dimension-filter .message-row {
            vertical-align:top;
        }
        .common-plugin.dimension-filter .message-td {
            padding:5px;
        }
        .common-plugin.dimension-filter .error-td {
            color:red;
            font-weight:bold;
            padding:5px;
        }
        .common-plugin.dimension-filter .apply-button {
        }
        .common-plugin.dimension-filter .apply-fa-div {
            color: rgb(45, 53, 56); 
            width: 40px; 
            height: 38px; 
            text-align: center; 
            cursor: pointer;
        }
        .common-plugin.dimension-filter .apply-fa-label {
            font-weight: normal;
            font-size: 11px;
        }
        .common-plugin.dimension-filter .apply-fa-div:hover {
            color: #148ac4 !important;
        }
        .common-plugin.dimension-filter .apply-fa-icon {
            font-size: 30px;
        }
        .common-plugin.dimension-filter .apply-fa-icon:hover {
            font-size: 38px;
            margin-top: -4px;
        }
        .common-plugin.dimension-filter .enumeration-fa-bar-control {
            height: 40px;
            width: fit-content;
            display: flex;
            padding: 2px;
        }
        .common-plugin.dimension-filter .popup-button-fa-div {
        	border:thin solid lightgray;
            color: rgb(45, 53, 56); 
            width: 70px; 
            height: 40px; 
            text-align: center; 
            cursor: pointer;
            padding: 2px;
        }
        .common-plugin.dimension-filter .popup-button-fa-div:hover {
            color: #148ac4 !important;
        }
        .common-plugin.dimension-filter .popup-button-fa-icon {
            font-size: 30px;
        }
        .common-plugin.dimension-filter .popup-button-fa-label {
            width: 70px; 
            font-size: 11px; 
            font-weight: normal; 
            color: rgb(0, 0, 0); 
            display: block;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }
        .dijitPopup {
            z-index:1000 !important;
        }
    </style>
</div>
]]>
        </HtmlText>
        <SchemaText>
          <![CDATA[var schema = [];
schema.push({ name:"name",    label:"Name",    type:"string",  _isDimension:true,   _isMeasure:false });
schema.push({ name:"type",    label:"Type",    type:"string",  _isDimension:false,  _isMeasure:false });
schema.push({ name:"value",   label:"Value",   type:"string",  _isDimension:false,  _isMeasure:true  });
return schema;
]]>
        </SchemaText>
      </Widget>
      <Widget name="Dual List Builder" private="false">
        <PropertyText>
          <![CDATA[[]]]>
        </PropertyText>
        <CodeText segment="#postCreate">
          <![CDATA[
            var self = this;
            this._initOptions("Loading options...", function() {
                // done
            });

            this._btnAdd.set("disabled", true);
            this._btnRemove.set("disabled", true);
            this._btnAddAll.set("disabled", true);
            this._btnRemoveAll.set("disabled", true);

            this._preLeftRowId = null;
            this._preRightRowId = null;
            this._leftClickTime = 0;
            this._rightClickTime = 0;]]>
        </CodeText>
        <CodeText segment="#methods">
          <![CDATA[
        // MUST implement resize, setModel() and getModel() if to be used in edit mode
        
        resize : function() {
        },
        
        setModel : function(values) {
            alert("setModel()");
        },
        
        getModel : function() {
            // alert("getModel()");
            this._model = [];
            if (this._rightGrid != null) {
                for (var i=0; i<this._rightGrid.grid.collection.data.length; i++) {
                    var item = this._rightGrid.grid.collection.data[i];
                    this._model.push(item.value);
                }
            }
            //alert(this._model.join(","));
            return this._model;
        },

        DOUBLE_CLICK_TIMEOUT : 500,
        
        _getOptions : function(callback) {
            if (this.editorConfig.getOptions != null) {
                this.editorConfig.getOptions(this.editorConfig.values, this._searchString, callback);
            }
            else {
                getOptionsFromService(this.editorConfig.service, this.editorConfig.values, this._searchString, callback);
            }
        },

        _initOptions : function(message, callback) {
            var self = this;
            this._showProgressMessage(message);
            this._getOptions(function(options) {
                if (options.length == 0) {
                    self._hideProgressMessage("Query returned no result.");
                }
                else {
                    self._hideProgressMessage("");
                }
                var leftover = (self.model || []).slice(0);
                var available = [];
                var selected = [];
                for (var i=0; i<options.length; i++) {
                    var item = options[i];
                    var match = leftover.indexOf(item.value);
                    if (match != -1) {
                        selected.push(item);
                        leftover.splice(match, 1);
                    }
                    else {
                        available.push(item);
                    }
                }
                if (leftover.length > 0) {
                    for (var i=0; i<leftover.length; i++) {
                        selected.push({
                            value : leftover[i],
                            label : "* " + leftover[i]
                        });
                    }
                }
                if (self._leftGrid == null) {
                    self._leftGrid = createGrid(self._leftDiv, lang.hitch(self, "_onLeftSelect"), available);
                }
                else {
                    self._leftGrid.store.setData(available);
                    self._leftGrid.grid.refresh();
                }
                self._btnAddAll.set("disabled", self._leftGrid.grid.collection.data.length == 0);
                if (self._rightGrid == null) {
                    self._rightGrid = createGrid(self._rightDiv, lang.hitch(self, "_onRightSelect"), selected);
                }
                else {
                    self._rightGrid.store.setData(selected);
                    self._rightGrid.grid.refresh();
                }
                self._btnRemoveAll.set("disabled", self._rightGrid.grid.collection.data.length == 0);
            });
        },

        _updateOptions : function(message, callback) {
            var self = this;
            this._showProgressMessage(message);
            var inRightList = null;
            if (this._rightGrid.grid.collection.data.length > 0) {
                inRightList = {};
                this._rightGrid.grid.collection.data.forEach(function(item) {
                    inRightList[item.value] = true;
                });
            }
            this._getOptions(function(options) {
                // filter options to exclude values already in the right list
                if (inRightList != null) {
                    options = options.filter(function(item) {
                        return inRightList[item.value] == null;
                    });
                }
                if (options.length == 0) {
                    self._hideProgressMessage("Query returned no result.");
                }
                else {
                    self._hideProgressMessage("");
                }
                if (self._leftGrid == null) {
                    self._leftGrid = createGrid(self._leftDiv, lang.hitch(self, "_onLeftSelect"), options);
                }
                else {
                    self._leftGrid.store.setData(options);
                    self._leftGrid.grid.refresh();
                }
                self._btnAddAll.set("disabled", self._leftGrid.grid.collection.data.length == 0);
            });
        },

        _onChangeSearch : function(value) {
            if (this._searchString != null && this._searchString == value) {
                return;
            }
            this._searchString = value;

            var self = this;
            this._updateOptions("Updating options...", function() {
                // done
            });
        },

        _onKeyUpSearch : function(evt) {
            var self = this;
            if (evt.keyCode == 13) {
                var value = this._inputSearch.get("value");
                if (this._searchString != null && this._searchString == value) {
                    return;
                }
                this._searchString = value;
                
                var self = this;
                this._updateOptions("Updating options...", function() {
                    // done
                });
            }
        },

        _onLeftSelect : function(evt) {
            var rowId = evt.rows[0].id;
            var now = Date.now();
            if (evt.type == "dgrid-deselect" && this._leftClickRowId != null && this._leftClickTime != null) {
                this._preLeftRowId = rowId;
            }
            if (evt.type == "dgrid-select") {
                this._leftClickRowId = rowId;
                if (this._preLeftRowId == this._leftClickRowId && (now - this._leftClickTime) < this.DOUBLE_CLICK_TIMEOUT) {
                    // is double-click
                    delete this._leftClickRowId;
                    delete this._leftClickTime;
                    this._addItems = [evt.rows[0].data];
                    this._btnAdd.set("disabled", true);
                    window.setTimeout(lang.hitch(this, "_onClickAdd"), 10);
                    return;
                }
                this._leftClickTime = now;
            }
            this._addItems = getSelectedItems(evt.grid);
            this._btnAdd.set("disabled", this._addItems.length == 0);
            this._btnAddAll.set("disabled", this._leftGrid.grid.collection.data.length == 0);
        },
        
        _onRightSelect : function(evt) {
            var rowId = evt.rows[0].id;
            var now = Date.now();
            if (evt.type == "dgrid-deselect" && this._rightClickRowId != null && this._rightClickTime != null) {
                this._preRightRowId = rowId;
            }
            if (evt.type == "dgrid-select") {
                this._rightClickRowId = rowId;
                if (this._preRightRowId == this._rightClickRowId && (now - this._rightClickTime) < this.DOUBLE_CLICK_TIMEOUT) {
                    // is double-click
                    delete this._rightClickRowId;
                    delete this._rightClickTime;
                    this._removeItems = [evt.rows[0].data];
                    this._btnRemove.set("disabled", true);
                    window.setTimeout(lang.hitch(this, "_onClickRemove"), 10);
                    return;
                }
                this._rightClickTime = now;
            }
            this._removeItems = getSelectedItems(evt.grid);
            this._btnRemove.set("disabled", this._removeItems.length == 0);
            this._btnRemoveAll.set("disabled", this._rightGrid.grid.collection.data.length == 0);
        },
        
        _onClickAdd : function(evt) {
            if (this._addItems != null && this._addItems.length > 0) {
                var items = lang.clone(this._addItems);
                for (var i=0; i<items.length; i++) {
                    var item = items[i];
                    this._leftGrid.store.remove(item.value);
                    this._rightGrid.store.put(item);
                }
                this._leftGrid.grid.refresh();
                this._rightGrid.grid.refresh();
                this._btnRemoveAll.set("disabled", this._rightGrid.grid.collection.data.length == 0);
            }
        },
        
        _onClickRemove : function(evt) {
            if (this._removeItems != null && this._removeItems.length > 0) {
                var items = lang.clone(this._removeItems);
                for (var i=0; i<items.length; i++) {
                    var item = items[i];
                    this._rightGrid.store.remove(item.value);
                    this._leftGrid.store.put(item);
                }
                this._leftGrid.grid.refresh();
                this._rightGrid.grid.refresh();
                this._btnAddAll.set("disabled", this._leftGrid.grid.collection.data.length == 0);
            }
        },
        
        _onClickAddAll : function(evt) {
            // UI-182 - replace store instead of adding one at a time to improve performance
            var leftItems = lang.clone(this._leftGrid.grid.collection.data);
            var rightItems = lang.clone(this._rightGrid.grid.collection.data);
            var items = leftItems.concat(rightItems);
            var leftStore = GridUtil.createGridStore("value", []);
            var rightStore = GridUtil.createGridStore("value", items);
            this._leftGrid.grid.set("collection",leftStore);
            this._rightGrid.grid.set("collection",rightStore);
            this._leftGrid.store = leftStore;
            this._rightGrid.store = rightStore;
            
            this._leftGrid.grid.refresh();
            this._rightGrid.grid.refresh();
            this._btnAddAll.set("disabled", this._leftGrid.grid.collection.data.length == 0);
            this._btnRemoveAll.set("disabled", this._rightGrid.grid.collection.data.length == 0);
        },
        
        _onClickRemoveAll : function(evt) {
            // UI-182 - replace store instead of adding one at a time to improve performance
            var leftItems = lang.clone(this._leftGrid.grid.collection.data);
            var rightItems = lang.clone(this._rightGrid.grid.collection.data);
            var items = leftItems.concat(rightItems);
            var leftStore = GridUtil.createGridStore("value", items);
            var rightStore = GridUtil.createGridStore("value", []);
            this._leftGrid.grid.set("collection",leftStore);
            this._rightGrid.grid.set("collection",rightStore);
            this._leftGrid.store = leftStore;
            this._rightGrid.store = rightStore;

            this._leftGrid.grid.refresh();
            this._rightGrid.grid.refresh();
            this._btnAddAll.set("disabled", this._leftGrid.grid.collection.data.length == 0);
            this._btnRemoveAll.set("disabled", this._rightGrid.grid.collection.data.length == 0);
        },
        
        _showProgressMessage : function(message) {
            this._statusDiv.innerHTML = message;
            var self = this;
            require(["dijit/ProgressBar", "dojo/domReady!"], function(ProgressBar) {
                var div = domConstruct.create("div");
                self._progressBarTd.appendChild(div);
                self._progressBar = new ProgressBar({ 
                    style: "width:80%;height:100%;float:right;",
                    indeterminate : true,
                    layoutAlign: "right",
                }, div);
                domStyle.set(self._progressBar.internalProgress, "height", "100%");
            });
        },
        
        _hideProgressMessage : function(message) {
            this._statusDiv.innerHTML = message;
            if (this._progressBar != null) {
                this._progressBar.destroy();
                delete this._progressBar;
            }
            AppUtil.removeAllChildrenOf(this._progressBarTd);
        },

        "$getValueAsString" : function(value) {
            if (value != null && Array.isArray(value)) {
                var arr = value.slice(0);
                arr.sort();
                return arr.join(", ");
            }
            return null;
        },
]]>
        </CodeText>
        <CodeText segment="#functions">
          <![CDATA[    function createGrid(parentNode, onSelect, data)
    {
        var div = domConstruct.create("div", {});
        parentNode.appendChild(div);
        
        var columns = [{
            field : "label",
            label : "Label",
            style : "font-family:monospace;cursor:pointer;",
            sortable : true,
        }];
        var store = GridUtil.createGridStore("value", data);
        var grid = GridUtil.createGridWidget("Left", div, false, null, columns, store,
                                             onSelect, null, "extended", onSelect, null);
        grid.set('sort', 'label');
        return {
            store : store,
            grid  : grid,
        };
    }

    function getSelectedItems(grid)
    {
        var items = [];
        for (var i=0; i<grid.collection.data.length; i++) {
            var item = grid.collection.data[i];
            if (grid.selection[item.value] == true) {
                items.push(item);
            }
        }
        return items;
    }

    function getOptionsFromService(service, values, search, callback)
    {
        var method = service.method.toLowerCase();
        var uri = service.url;
        var params = service.params;
        var headers = {
        	values  : JSON.stringify(values),
        	search  : search,
        	context : service.context != null ? JSON.stringify(service.context) : null,
        };
        var self = this;
        doREST(method, uri, params, headers, function(t) {
            var options = [];
            if (t != null && t != "") {
                var response = JSON.parse(t);
                if (response.status == "OK") {
                    options = response.value;
                    array.forEach(options, function(option, index) {
                        if (typeof option == "string") {
                            options[index] = { value:option, label:option };
                        }
                        else if (typeof option == "number") {
                            options[index] = { value:String(option), label:String(option) };
                        }
                        else if (option.value != null) {
                            if (typeof option.value == "number") {
                                option.value = String(option.value);
                            }
                            if (option.value != null && option.label == null) {
                                option.label = option.value;
                            }
                        }
                    });
                    if (service.sortByLabel != false) {
                        options.sort(function(a,b) {
                            return a.label.localeCompare(b.label);
                        });
                    }
                }
            }
            callback(options);
        });
    }
]]>
        </CodeText>
        <HtmlText>
          <![CDATA[<table style="width:100%;height:100%;">
    <style>
        .AddRemoveButton span {
            width: 30px;
        }
    </style>
    <tr>
        <td colspan="3" style="width:100%;height:30px;">
            <table style="width:100%;height:100%;">
                <tr>
                    <td style="width:1%;">Search:</td>
                    <td style="width:99%;">
                        <input type="text"
                               style="width:calc(100% - 0px);font-family:monospace;"
                               data-dojo-type="dijit/form/TextBox"
                               data-dojo-props="trim:true"
                               data-dojo-attach-point="_inputSearch"
                               data-dojo-attach-event="change:_onChangeSearch,onKeyUp:_onKeyUpSearch"/>
                    </td>
                </tr>
            </table>
        </td>
    </tr>
    <tr>
        <td style="width:49%;height:100%;">
            <div data-dojo-attach-point='_leftDiv' style="width:100%;height:100%;background-color:white;">
            </div>
        </td>
        <td style="width:2%;height:100%;text-align:center;">
            <table>
                <tr style="height:49%;">
                    <td>&nbsp;</td>
                </tr>
                <tr>
                    <td>
                        <button data-dojo-type="dijit.form.Button"
                                data-dojo-attach-point='_btnAddAll'
                                data-dojo-attach-event="click:_onClickAddAll"
                                type="button" class="AddRemoveButton">&gt;&gt;&nbsp;</button>
                    </td>
                </tr>
                <tr>
                    <td>
                        <button data-dojo-type="dijit.form.Button"
                                data-dojo-attach-point='_btnAdd'
                                data-dojo-attach-event="click:_onClickAdd"
                                type="button" class="AddRemoveButton">&gt;&nbsp;</button>
                    </td>
                </tr>
                <tr>
                    <td>
                        <button data-dojo-type="dijit.form.Button"
                                data-dojo-attach-point='_btnRemove'
                                data-dojo-attach-event="click:_onClickRemove"
                                type="button" class="AddRemoveButton">&lt;&nbsp;</button>
                    </td>
                </tr>
                <tr>
                    <td>
                        <button data-dojo-type="dijit.form.Button"
                                data-dojo-attach-point='_btnRemoveAll'
                                data-dojo-attach-event="click:_onClickRemoveAll"
                                type="button" class="AddRemoveButton">&lt;&lt;&nbsp;</button>
                    </td>
                </tr>
                <tr style="height:49%;">
                    <td>&nbsp;</td>
                </tr>
            </table>
        </td>
        <td style="width:49%;height:100%;">
            <div data-dojo-attach-point='_rightDiv'
                 style="width:100%;height:100%;background-color:white;">
            </div>
        </td>
    </tr>
    <tr>
        <td colspan="2" style="width:100%;height:20px;vertical-align:bottom;">
            <div data-dojo-attach-point='_statusDiv' style="width:100%;padding-top:5px;vertical-align:bottom;font-size:12px;font-style:italic;overflow:hidden;"></div>
        </td>
        <td data-dojo-attach-point='_progressBarTd'>
        </td>
    </tr>
</table>
]]>
        </HtmlText>
      </Widget>
      <Widget name="Font Awesome Bar" private="false">
        <PropertyText>
          <![CDATA[[]]]>
        </PropertyText>
        <CodeText segment="#buildRendering">
          <![CDATA[
            this._selected = null;
            this._none_ = false;
            this._items = [];
            for (var i=0; i<this.initialConfig.options.length; i++) {
                var option = this.initialConfig.options[i];
                
                // skip items with no value... eg. group label
                if (option.value == null) continue;
                
                if (option.value == "#none#") {
                    this._none_ = true;
                    continue;
                }

                // omit if faClass is not defined for the option and default also not defined
                // ... easy way to exclude showing "anonymous" entries
                // ... example of faClass is "fas fa-home"
                if (option.faClass == null && this.initialConfig.faClass == null) continue;

                var div = domConstruct.create("div", {
                    "class" : "menuItem fa-bar-menu-item",
                    "title" : option.faTooltip || ""
                });
                this.itemContainer.appendChild(div);
                
                var fa = domConstruct.create("i", {
                    "class" : "fa-bar-icon " + (option.faClass || this.initialConfig.faClass),
                });
                div.appendChild(fa);
                
                var label = domConstruct.create("div", {
                    "class" : "fa-bar-label"
                });
                label.innerHTML = option.faLabel || option.label;
                div.appendChild(label);

                var item = {
                    div   : div,
                    fa    : fa,
                    label : label,
                    value : option.value
                };
                this._items.push(item);

                var self = this;
                on(div, "click", lang.partial(function(item, evt) {
                    for (var j=0; j<self._items.length; j++) {
                        domClass.remove(self._items[j].div, "selected");
                    }
                    if (self._none_) {
                        // if none allowed, check to see if we clicked on selected item
                        if (self._selected == item) {
                            delete self._selected;
                            if (self.initialConfig.onChange != null) {
                                self.initialConfig.onChange("#none#");
                            }
                        }
                        else {
                            self._selected = item;
                            domClass.add(item.div, "selected");
                            if (self.initialConfig.onChange != null) {
                                self.initialConfig.onChange(item.value);
                            }
                        }
                    }
                    else {
                        self._selected = item;
                        domClass.add(item.div, "selected");
                        if (self.initialConfig.onChange != null) {
                            self.initialConfig.onChange(item.value);
                        }
                    }
                    self.onExecute();
                }, item));
                
                if (this.initialConfig.value == option.value) {
                    this._selected = item;
                    domClass.add(item.div, "selected");
                }
            }
]]>
        </CodeText>
        <CodeText segment="#constructor">
          <![CDATA[
            if (this._useDummyData()) {
                this._createDummyData();
            }
]]>
        </CodeText>
        <CodeText segment="#postCreate">
          <![CDATA[]]>
        </CodeText>
        <CodeText segment="#methods">
          <![CDATA[
        _useDummyData : function() {
            if (this.controller != null && this.controller.initialConfig.appId == "dbp") {
                // in Dashboard Plugin app... so either modeling preview or summary preview
                return true;
            }
            if (this.controller != null && this.controller.initialConfig.appId == "ax" && this.controller.mode == "edit.model") {
                // in dashboard builder modeling context
                return true;
            }
            return false;
        },

        _createDummyData : function() {
            this.initialConfig.options = [
                {
                    value   : "E-Mail",
                    label   : "E-Mail",
                    faClass : "fa fa-envelope"
                },
                {
                    value   : "Video",
                    label   : "STVA",
                    faClass : "fa fa-video"
                },
            ];
        },
        
        getItems: function() {
            return this._items;
        },
        
        getSelection: function() {
            return this._selected;
        },
        
        onExecute: function() {
        },
        
        baseClass: "fa-bar-menu",
]]>
        </CodeText>
        <CodeText segment="#onNotify">
          <![CDATA[
            this._colorMaps = evt.colors;
            for (var i=0; i<this._items.length; i++) {
                var item = this._items[i];
                var color = this._colorMaps[item.value];
                domStyle.set(item.fa, "color", color);
            }
]]>
        </CodeText>
        <HtmlText>
          <![CDATA[<div>
<style>
    .fa-bar-menu {
        display:flex;
        flex-direction:column;
        align-items:center;
    }
    .fa-bar-menu-item {
        color: rgb(45, 53, 56); 
        width: 70px; 
        height: 40px; 
        text-align: center; 
        cursor: pointer;
        display:flex;
        flex-direction:column;
        align-items:center;
    }
    .fa-bar-menu-item:hover {
        color: #148ac4;
    }
    .selected {
        background-color: rgba(20,138,196,.1);
    }
    .fa-bar-icon {
        font-size: 30px;
    }
    .fa-bar-label {
        width: 70px; 
        font-size: 11px; 
        font-weight: normal; 
        color: rgb(0, 0, 0); 
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
        line-height:normal;
    }
    .fa-bar-menu-container{
        width: fit-content;
        height: 36px;
        display: flex;
    }
    .popup-fa-bar-arrow{
        display:none;
    }
</style>
    <div class="popup-fa-bar-arrow"></div>
    <div class="fa-bar-menu-container" data-dojo-attach-point="itemContainer"></div>
</div>
]]>
        </HtmlText>
      </Widget>
      <Widget name="Form Widget" private="false">
        <PropertyText>
          <![CDATA[[{
    "name" : "model",
    "label" : "Model",
    "type" : "json"
}]]]>
        </PropertyText>
        <CodeText segment="#methods">
          <![CDATA[
        resize : function() {
        },

        getModel : function() {
            // update this.model from value map
            // generate in order defined
            var selectiveChange  = this._options["selective-change"] == true;
            var selectiveDisable = this._options["selective-disable"] == true;
            var model = [];
            if (this._model.values != null) {
                for (var name in this._model.values) {
                    model.push({
                        name  : name,
                        value : this._model.values[name],
                    });
                }
            }
            var items = this._getItems();
            if (items != null && Array.isArray(items)) {
                for (var i=0; i<items.length; i++) {
                    var item = items[i];
                    if (item.widget != null) {
                        if (!selectiveChange && !selectiveDisable) {
                            model.push({
                                name  : item.name,
                                value : this.values[item.name],
                            });
                        }
                        else if (selectiveChange) {
                            if (this.checks[item.name] == null || (this.checks[item.name]).get("value")) {
                                model.push({
                                    name  : item.name,
                                    value : this.values[item.name],
                                });
                            }
                        }
                        else if (selectiveDisable) {
                            model.push({
                                name  : item.name,
                                value : this.values[item.name],
                            });
                            if (this.checks[item.name] != null && !(this.checks[item.name]).get("value")) {
                                model.push({
                                    name  : item.name + "$disabled",
                                    value : true,
                                });
                            }
                        }
                    }
                }
            }
            return model;
        },

        showItem : function(name, show) {
            if (this._rows != null) {
                var row = this._rows[name];
                if (row != null) {
                    domStyle.set(row, "display", show ? "" : "none");
                }
            }
        },
        
        showError : function(error) {
            if (error != null && error != "") {
                this._errorTd.innerHTML = error;
                domStyle.set(this._errorTd, "display", "");
            }
            else {
                this._errorTd.innerHTML = "";
                domStyle.set(this._errorTd, "display", "none");
            }
        },
 
        _getColumnCount : function() {
            return this._model.columns != null ? this._model.columns.length : 0;
        },

        _getColumnItems : function(index) {
            var items = this._model.columns[index];
            if (typeof items == "function") {
                return items(this._value);
            }
            else {
                return items;
            }
        },
        
        _getGroupCount : function() {
            return this._model.groups != null ? this._model.groups.length : 0;
        },

        _getGroupItems : function(index) {
            var items = this._model.groups[index];
            if (typeof items == "function") {
                return items(this._value);
            }
            else {
                return items;
            }
        },

        _getItems : function() {
            if (typeof this._model.items == "function") {
                return this._model.items(this._value);
            }
            else {
                return this._model.items;
            }
        },

        _createForm : function(parentNode) {
            this._widgets = {};
            this._rows = {};
            this.values = {};
            this.checks = {};

            for (var i=0; i<this._value.length; i++) {
                var item = this._value[i];
                this.values[item.name] = item.value;
            }
            
            var table = createTable(parentNode);
            if (this._model.title != null) {
                var td = addTitleRow(table, this._model.title, this._model.style, this._enableCheckBox);
                domClass.add(td, "ax-form-title-cell");
                domClass.add(td.parentElement, "ax-form-title-row");
            }

            if (this._enableCheckBox) {
                var self = this;
                addSectionRow(table, "Check/Uncheck to enable/disable all items.", "font-style:italic;", true, function(prop) {
                    for (var name in self.checks) {
                        (self.checks[name]).set("value", prop.value);
                    }
                });
            }

            var columnCount = this._getColumnCount();
            if (columnCount > 0) {
                // multi-column structure
                var bodyStyle = this._model["body-style"] || "";
                var columnStyles = this._model["column-styles"] || [];
                var columnTitles = this._model["column-titles"] || [];
                var tables = addColumnRow(table, columnCount, bodyStyle, columnStyles, columnTitles);
                for (var i=0; i<columnCount; i++) {
                    var items = this._getColumnItems(i);
                    this._createFormItems(tables[i], items);
                    domClass.add(tables[i], "ax-form-column-table-"+i);
                    domClass.add(tables[i].parentElement, "ax-form-column-div-"+i);
                }
            }
            else {
                var groupCount = this._getGroupCount();
                if (groupCount > 0) {
                    // multi-group structure
                    var bodyStyle = this._model["body-style"] || "";
                    var groupStyles = this._model["group-styles"] || [];
                    var groupTitles = this._model["group-titles"] || [];
                    var tables = addGroupRow(table, groupCount, bodyStyle, groupStyles, groupTitles);
                    for (var i=0; i<groupCount; i++) {
                        var items = this._getGroupItems(i);
                        this._createFormItems(tables[i], items);
                        domClass.add(tables[i], "ax-form-group-table-"+i);
                        domClass.add(tables[i].parentElement, "ax-form-group-div-"+i);
                    }
                }
                else {
                    var items = this._getItems();
                    this._createFormItems(table, items);
                }
            }

            this._errorTd = addErrorRow(table);

            if (items != null && typeof items == "string") {
                this.showError(items);
            }
        },
        
        _createFormItems : function(table, items) {
            var self = this;
            if (items != null && Array.isArray(items)) {
                for (var i=0; i<items.length; i++) {
                    var item = items[i];
                    if (item.config == null) item.config = {};
                    var labelStyle = "font-style:italic;";
                    if (item.config.labelStyle)
                        labelStyle = item.config.labelStyle;
                    var row = null;
                    if (item.type == "section") {
                        var td = addSectionRow(table, item.label, labelStyle, this._enableCheckBox, null);
                        row = td.parentElement;
                    }
                    else {
                        var obj = addItemRow(table, item.label, labelStyle, this._enableCheckBox, lang.partial(function(item, prop) {
                            item.widget.set("disabled", !prop.value);
                        }, item));
                        if (obj.check != null) {
                            if (item.required == true) {
                                domStyle.set(obj.check.domNode, "display", "none");
                            }
                            else {
                                this.checks[item.name] = obj.check;
                            }
                        }
                        var td = obj.value;
                        row = table.childNodes[table.childElementCount - 1];
                        var widget = this._createFormItem(td, item.name, item.type, this.values[item.name], item.config, lang.partial(function(config, prop) {
                            self.values[prop.name] = prop.value;
                            if (config.onchange && typeof config.onchange == "function") {
                                config.onchange(self.initialConfig.model, self.initialConfig.item, prop, self._widgets, self._rows, self.values, self._model);
                            }
                            if (config.reset && typeof config.reset == "function") {
                                config.reset();
                            }
                        }, item.config));
                        this._widgets[item.name] = widget;
                        item.widget = widget;
                        domClass.add(td, "ax-form-value-"+item.name);
                        domClass.add(td, "ax-form-"+item.type+"-value");
                        domClass.add(td.previousSibling, "ax-form-label-"+item.name);
                        domClass.add(td.previousSibling, "ax-form-"+item.type+"-label");
                        if (widget.domNode != null) {
                            domClass.add(widget.domNode, "ax-form-widget-"+item.name);
                            domClass.add(widget.domNode, "ax-form-"+item.type+"-widget");
                        }
                        if (obj.check != null && item.disabled == true) {
                            obj.check.set("value", false);
                        }
                    }
                    if (row != null) {
                        this._rows[item.name] = row;
                        domClass.add(row, "ax-form-row-"+i);
                        domClass.add(row, "ax-form-row-"+item.name);
                        domClass.add(row, "ax-form-"+item.type+"-row");
                    }
                }
            }
        },
        
        _createFormItem : function(td, name, type, value, config, callback) {
            switch (type) {
                case "int":
                case "integer":
                case "long":
                    return FormUtil.createNumberSpinner(name, td, value, config.min, config.max, config.inc || 1, 0, true, config.style, config.tooltip, callback);
                case "float":
                case "double":
                case "number":
                    return this._createNumberTextBox(name, td, value, config.constraints, config.required == true, config.style, config.tooltip, callback);
                case "boolean":
                    return FormUtil.createCheckBox(name, td, value, config.tooltip, callback);
                case "password":
                    return FormUtil.createPasswordInput(name, td, value, config.style, config.tooltip, false, callback);
                case "string":
                default:
                    if (config.enums != undefined && config.enums != null) {
                        var enums = config.enums;
                        if (enums != undefined && enums != null && typeof enums == "function") {
                            if (enums.length == 2) {
                                enums = enums(this.editorConfig.axflow, this.editorConfig.item);
                            }
                            else if (enums.length == 3) {
                                var widget = FormUtil.createSingleSelect(name, td, [], value, config.style, config.tooltip, callback);
                                var self = this;
                                enums(this.editorConfig.axflow, this.editorConfig.item, function(enums) {
                                    if (value != undefined && value != "#none#") {
                                        enums = [{value : "#none#", label : I18N.getString('af.controls', 'none.select.label')} ].concat(enums);
                                    }
                                    FormUtil.updateSingleSelect(widget, enums, value, value == null || value == "" || value == "#none#");
                                    callback(widget);
                                });
                                return widget;
                            }
                        }
                        return FormUtil.createSingleSelect(name, td, enums, value, config.style, config.tooltip, callback);
                    }
                    else if (config.choices != undefined && config.choices != null) {
                        var choices = config.choices;
                        if (choices != undefined && choices != null && typeof choices == "function") {
                            choices = choices(this.editorConfig.axflow, this.editorConfig.item);
                        }
                        return FormUtil.createMultiSelect(name, td, choices, value, config.style, config.tooltip, callback);
                    }
                    else if (config.multiline == true) {
                        domStyle.set(td.parentElement, "vertical-align", "top");
                        domStyle.set(td.parentElement.firstElementChild, "padding-top", "3px");
                        return FormUtil.createTextArea(name, td, value, config.style, false, config.tooltip, callback);
                    }
                    else {
                        return FormUtil.createTextBox(name, td, value, config.style, config.tooltip, config.readonly == true, callback);
                    }
                    break;
            }
            return null;
        },

        _useDummyModel : function() {
            if (this.controller.initialConfig.appId == "dbp") {
                // in Dashboard Plugin app... so either modeling preview or summary preview
                return true;
            }
            if (this.controller.initialConfig.appId == "ax" && this.controller.mode == "edit.model") {
                // in dashboard builder modeling context
                return true;
            }
            return false;
        },

        _getDummyModel : function(callback) {
            doREST("get", this.controller.item.uri + "/FORM_WIDGET_SAMPLE", null, null, function(t) {
                if (t != null && t != "") {
                    callback(JSON.parse(t));
                }
            });
        },

        _createNumberTextBox : function(name, parentNode, value, constraints, required, style, tooltip, callback) {
            if (style == null || style == "") {
                style = "width:80px;";
            }
            if (value == null || value == "") {
                value = 0;
            }
            else {
                value = Number(value);
            }
            var config = {
                name  : name,
                value : value,
            };
            if (style != null) {
                config.style = style;
            }
            if (tooltip != null) {
                config.title = tooltip;
            }
            if (constraints != null) {
                config.constraints = constraints;
            }
            if (required != null) {
                config.required = required;
            }
            if (callback != null) {
                var prevValue = value;
                config.onChange = function(value) {
                    if (value !== prevValue) {
                        callback({name: name, value: value, prev: prevValue});
                        prevValue = value;
                    }
                };
            }
            var textbox = new this.NumberTextBoxClass(config);
            textbox.placeAt(parentNode);
            textbox.startup();
            return textbox;
        },
]]>
        </CodeText>
        <CodeText segment="#functions">
          <![CDATA[
    /*
     * var formDef = {
     *     title : "Setup Database Connection",
     *     style : "font-size:larger;",
     *     items : [
     *         {
     *             name  : "url",
     *             label : "URL",
     *             type  : "string",
     *             config : {
     *                 enums   : [],
     *                 choices : [],
     *                 style   : "width:100%;font-family:monospace;",
     *                 min     : #,
     *                 max     : #,
     *                 inc     : #,
     *             },
     *         },
     *         {
     *             name  : "username",
     *             label : "User Name",
     *             type  : "string",
     *             config : {
     *                 ...
     *             },
     *         },
     *         {
     *             name  : "password",
     *             label : "Password",
     *             type  : "password",
     *             config : {
     *                 ...
     *             },
     *         }
     *     ]
     * };
     */

    function createTable(parentNode)
    {
        var table = domConstruct.create("table", {
            cellspacing : 5,
            cellpadding : 0,
            border      : 0,
            style       : "width:100%;white-space:nowrap;"
        });
        parentNode.appendChild(table);
        return table;
    }

    function addTitleRow(table, title, style, selectiveChange)
    {
        var tr = domConstruct.create("tr", {
            style : "width:100%;"
        });
        table.appendChild(tr);
        
        var td = domConstruct.create("td", {
            colspan : selectiveChange ? 3 : 2,
            style   : "width:100%;" + (style || ""),
        });
        tr.appendChild(td);
        
        td.innerHTML = title;
        return td;
    }

    function addColumnRow(table, count, bodyStyle, columnStyles, columnTitles)
    {
        var tr = domConstruct.create("tr", {
            style : "width:100%;"
        });
        table.appendChild(tr);
        
        var td = domConstruct.create("td", {
            colspan : 2,
            style   : "width:100%;white-space:nowrap;display:flex;" + (bodyStyle || ""),
        });
        tr.appendChild(td);
        
        var pct = Math.floor(100/count);
        var tables = [];
        for (var i=0; i<count; i++) {
            var style = "width:" + pct + "%;";
            if (typeof columnStyles == "string") {
                style += columnStyles;
            }
            else if (Array.isArray(columnStyles) && i < columnStyles.length) {
                style += columnStyles[i] || "";
            }
            var div = domConstruct.create("div", {
                style : style
            });
            td.appendChild(div);
            if (Array.isArray(columnTitles) && i < columnTitles.length) {
                var columnTitle = columnTitles[i];
                if (columnTitle != null && columnTitle.text != null) {
                    var titleDiv = domConstruct.create("div", {
                        "class" : "ax-form-column-title",
                        style : "font-weight:bold;overflow:hidden;padding:5px;" + (columnTitle.style || "")
                    });
                    titleDiv.innerHTML = columnTitle.text;
                    div.appendChild(titleDiv);
                }
            }
            var table = domConstruct.create("table", {
                "class" : "ax-form-column-table",
                cellspacing : 5,
                cellpadding : 0,
                border      : 0,
                style       : "width:100%;"
            });
            div.appendChild(table);
            tables.push(table);
        }
        return tables;
    }

    function addGroupRow(table, count, bodyStyle, groupStyles, groupTitles)
    {
        var tr = domConstruct.create("tr", {
            style : "width:100%;"
        });
        table.appendChild(tr);
        
        var td = domConstruct.create("td", {
            colspan : 2,
            style   : "width:100%;white-space:nowrap;display:block;" + (bodyStyle || ""),
        });
        tr.appendChild(td);
        
        var tables = [];
        for (var i=0; i<count; i++) {
            var style = "width:100%;";
            if (typeof groupStyles == "string") {
                style += groupStyles;
            }
            else if (Array.isArray(groupStyles) && i < groupStyles.length) {
                style += groupStyles[i] || "";
            }
            var div = domConstruct.create("div", {
                style : style
            });
            td.appendChild(div);
            if (Array.isArray(groupTitles) && i < groupTitles.length) {
                var groupTitle = groupTitles[i];
                if (groupTitle != null && groupTitle.text != null) {
                    var titleDiv = domConstruct.create("div", {
                        "class" : "ax-form-group-title",
                        style : "font-weight:bold;overflow:hidden;padding:5px;" + (groupTitle.style || "")
                    });
                    titleDiv.innerHTML = groupTitle.text;
                    div.appendChild(titleDiv);
                }
            }
            var table = domConstruct.create("table", {
                "class" : "ax-form-group-table",
                cellspacing : 5,
                cellpadding : 0,
                border      : 0,
                style       : "width:100%;"
            });
            div.appendChild(table);
            tables.push(table);
        }
        return tables;
    }

    function addSectionRow(table, title, style, selectiveChange, selectiveCallback)
    {
        var tr = domConstruct.create("tr", {
            style : "width:100%;"
        });
        table.appendChild(tr);
        
        if (selectiveCallback != null) {
            var tdCheck = domConstruct.create("td", {
                style : "width:20px;",
            });
            tr.appendChild(tdCheck);
            FormUtil.createCheckBox(label, tdCheck, true, "Enable/Disable form item.", selectiveCallback);

            var td = domConstruct.create("td", {
                colspan : 2,
                style   : "width:100%;" + (style || ""),
            });
            tr.appendChild(td);
        }
        else {
            var td = domConstruct.create("td", {
                colspan : selectiveChange ? 3 : 2,
                style   : "width:100%;" + (style || ""),
            });
            tr.appendChild(td);
        }
        
        td.innerHTML = title;
        return td;
    }
    
    function addItemRow(table, label, style, selectiveChange, selectiveCallback)
    {
        var tr = domConstruct.create("tr", {
            style : "width:100%;"
        });
        table.appendChild(tr);
        
        var checkbox = null;
        if (selectiveChange) {
            var tdCheck = domConstruct.create("td", {
                style : "width:20px;",
            });
            tr.appendChild(tdCheck);
            checkbox = FormUtil.createCheckBox(label, tdCheck, true, "Enable/Disable form item.", selectiveCallback);
        }

        var tdLabel = domConstruct.create("td", {
            style : "width:10%;" + (style || ""),
            "title":label + ":",
        });
        tr.appendChild(tdLabel);
        
        tdLabel.innerHTML = label + ":";
        
        var tdValue = domConstruct.create("td", {
            style : "width:90%;",
        });
        tr.appendChild(tdValue);
        
        return {
            check : checkbox,
            label : tdLabel,
            value : tdValue,
        };
    }
    
    function addErrorRow(table)
    {
        var tr = domConstruct.create("tr", {
            style : "width:100%;"
        });
        table.appendChild(tr);
        
        var td = domConstruct.create("td", {
            colspan : 2,
            style   : "width:100%;color:red;white-space:normal;display:none;",
        });
        tr.appendChild(td);
        
        return td;
    }
]]>
        </CodeText>
        <CodeText segment="#constructor">
          <![CDATA[
            this._model = null;
            this._value = this.initialConfig.model || [];
            this._options = {};

            if (this.editorConfig != null) {
                this._model = this.editorConfig.form || {};
                this.controller = this.editorConfig.controller;
                this._options = this.editorConfig.options || {};
            }
            else if (this.initialConfig.properties != null && this.initialConfig.properties.model != null && this.initialConfig.properties.model.trim() != "") {
                this._model = JSON.parse(this.initialConfig.properties.model);
            }

            this._enableCheckBox = this._options["selective-change"] == true || this._options["selective-disable"] == true;
]]>
        </CodeText>
        <CodeText segment="#buildRendering">
          <![CDATA[]]>
        </CodeText>
        <CodeText segment="#postCreate">
          <![CDATA[
            var self = this;
            require(["dijit/form/NumberTextBox", "dojo/domReady!"], function(NumberTextBox) {
                self.NumberTextBoxClass = NumberTextBox;
                if (self._model == null && self._useDummyModel()) {
                    self._getDummyModel(function(model) {
                        self._model = model;
                        self._createForm(self.domNode);
                    });
                }
                else {
                    self._createForm(self.domNode);
                }
            });
]]>
        </CodeText>
        <HtmlText>
          <![CDATA[<div class="via-scroller" style="width:100%;height:100%;background-color:white;overflow-x:hidden;overflow-y:auto;">
</div>
]]>
        </HtmlText>
      </Widget>
      <Widget name="Progress Bar Console" private="false">
        <PropertyText>
          <![CDATA[[]]]>
        </PropertyText>
        <CodeText segment="#constructor">
          <![CDATA[
            this._progressBars = {};]]>
        </CodeText>
        <CodeText segment="#onNotify">
          <![CDATA[            if (evt.actions != null) {
                var self = this;
                evt.actions.forEach(function(action) {
                    switch (action.operation) {
                        case "add":
                            var item = self._progressBars[action.id];
                            if (item == null) {
                                createProgressBar(action.message, function(item) {
                                    self._progressBars[action.id] = item;
                                    self.domNode.appendChild(item.contentDiv);
                                });
                            }
                            else {
                                item.messageDiv.innerHTML = action.message;
                            }
                            break;
                        case "remove":
                            var item = self._progressBars[action.id];
                            if (item != null) {
                                delete self._progressBars[action.id];
                                self.domNode.removeChild(item.contentDiv);
                            }
                            break;
                    }
                });
            }]]>
        </CodeText>
        <CodeText segment="#functions">
          <![CDATA[    function createProgressBar(message, callback)
    {
        require(["dijit/ProgressBar",
                 "dojo/domReady!"],
                 function(ProgressBar) {
            var contentDiv = domConstruct.create("div", {
                style : "width:100%;"
            });
            var messageDiv = domConstruct.create("div", {
                style : "width:100%;padding:5px;white-space:normal;"
            });
            messageDiv.innerHTML = message;
            contentDiv.appendChild(messageDiv);
            var progressDiv = domConstruct.create("div", {
                style : "width:100%;padding:5px;"
            });
            contentDiv.appendChild(progressDiv);
            var progressBar = new ProgressBar({ 
                style: "height:5px;",
                indeterminate : true,
                layoutAlign: "left",
            }, progressDiv);
            callback({
                contentDiv : contentDiv,
                messageDiv : messageDiv,
            });
        });
    }]]>
        </CodeText>
        <CodeText segment="#methods">
          <![CDATA[
        _useDummyData : function() {
            if (this.controller.initialConfig.appId == "dbp") {
                // in Dashboard Plugin app... so either modeling preview or summary preview
                return true;
            }
            if (this.controller.initialConfig.appId == "ax" && this.controller.mode == "edit.model") {
                // in dashboard builder modeling context
                return true;
            }
            return false;
        },

        _createDummyData : function() {
            var self = this;
            var add = true;
            this._dummyEvents = window.setInterval(function() {
                if (add) {
                    self.onNotify({
                        actions : [{
                            operation : "add",
                            id : "1",
                            message : "Start dummy task #1"
                        }, {
                            operation : "add",
                            id : "2",
                            message : "Start dummy task #2"
                        }]
                    });
                    add = false;
                }
                else {
                    self.onNotify({
                        actions : [{
                            operation : "remove",
                            id : "1",
                        }, {
                            operation : "remove",
                            id : "2",
                        }]
                    });
                    add = true;
                }
            }, 2000);
        },
]]>
        </CodeText>
        <CodeText segment="#postCreate">
          <![CDATA[
            if (this._useDummyData()) {
                this._createDummyData();
            }]]>
        </CodeText>
        <CodeText segment="#destroy">
          <![CDATA[
            if (this._dummyEvents != null) {
                window.clearInterval(this._dummyEvents);
                delete this._dummyEvents;
            }
            ]]>
        </CodeText>
        <HtmlText>
          <![CDATA[<div style="width:100%;height:100%;">
</div>
]]>
        </HtmlText>
      </Widget>
    </Widgets>
    <Functions>
      <Function name="applyDrilldownHoverConfig" args="evt,config,callback" private="false">
        <CodeText>
          <![CDATA[if (evt == null) evt = {};
if (evt.tile == null) evt.tile = {};

// explicit disabling of drilldown should NOT be use much... only as dev
// shortcut. No drilldown will be selected if record does not have appropriate
// drilldown meta
if (config.drilldown == false || config["drilldown-config"] == null) {
    // disable drilldown
    evt.tile.disableDrillDown = true;
}
// because we do not currently support nav rules for Hover, we need a way to
// disable hover... so by default, hover will be disabled UNLESS enabled
// in the top level config
if (config.hover == false || config["hover-config"] == null) {
    // disable hover
    evt.tile.disableHoverDetail = true;
    callback(evt);
}
else {
    // customize Hover style... type = tooltip or dialog, width, height
    var self = this;
    this.invokeService(config["hover-config"], null, null, function(response) {
        if (response.status == "OK") {
            var hoverConfig = response.value;
            evt.tile.hoverConfig = lang.partial(function(defaultHoverConfig, selection) {
                var info = self.hvGetInfo(selection);
                var cfg = lang.clone(defaultHoverConfig);
                if (info.style != null) {
                    cfg.hoverType = info.style;
                }
                if (info.width != null) {
                    cfg.hoverWidth = info.width;
                }
                if (info.height != null) {
                    cfg.hoverHeight = info.height;
                }
                if (info.name != null || info.label != null) {
                    cfg.hoverTitle = info.label || (info.name.toUpperCase() + " hover detail");
                }
                return cfg;
            }, hoverConfig["default-config"] || {});
        }
        callback(evt);
    });
}
]]>
        </CodeText>
      </Function>
      <Function name="cancelService" args="service,refId,callback" private="false">
        <CodeText>
          <![CDATA[function handleResponse(t)
{
    if (t != null && t != "") {
        var response = JSON.parse(t);
        if (response.status == null && response.value == null) {
            // not a DBP service response... fake it
            response = {
                status : "Error",
                value  : "Service cancellation not support."
            };
        }
        callback(response);
    }
    else {
        callback({
            status : "Error",
            error  : "Service '" + service["cancel-url"] + "' not reachable or not implemented."
        });
    }
}

if (service == null || service["cancel-url"] == null || service.method == null) {
    callback({
        status : "Error",
        error  : "Cancel Service definition not defined or incomplete."
    });
}
else {
    var url = "/vitria-oi/rest" + service["cancel-url"];
    var params = {
        "vtServiceRefId" : String(refId)
    };
    switch (service.method) {
        case "GET":
            GET(url, params, handleResponse, true);
            break;
        case "POST":
            POST(url, params, {}, handleResponse, true);
            break;
    }
}
]]>
        </CodeText>
      </Function>
      <Function name="ddGetConfig" args="config,info" private="false">
        <CodeText>
          <![CDATA[if (info.type != null) {
    config = config[info.type];
}
if (config["config["+info.view+"]["+info.name+"]"] != null) {
    return config["config["+info.view+"]["+info.name+"]"];
}
if (config["config["+info.name+"]"] != null) {
    return config["config["+info.name+"]"];
}
if (config["config["+info.view+"]"] != null) {
    return config["config["+info.view+"]"];
}
return config["config"];
]]>
        </CodeText>
      </Function>
      <Function name="ddGetData" args="selection" private="false">
        <CodeText>
          <![CDATA[var drilldownItems = {};
var drilldownData = [];
for (var i=0; i<selection.length; i++) {
    for (var name in selection[i]) {
        if (name == "_vtid" || name == "__userClick" || name == "__ITEM__") {
            // ignore
        }
        else {
            var item = drilldownItems[name];
            if (item == null) {
                item = {
                    _name_ : name
                };
                drilldownItems[name] = item;
                drilldownData.push(item);
            }
            item["_value"+i+"_"] = selection[i][name];
        }
    }
}
drilldownData.sort(function(a,b) {
    return a._name_.localeCompare(b._name_);
});
return drilldownData;
]]>
        </CodeText>
      </Function>
      <Function name="ddGetInfo" args="selection" private="false">
        <CodeText>
          <![CDATA[var drilldownType = null;
var drilldownName = null;
var drilldownLabel = null;
var drilldownView = null;
var drilldownModel = null;
var drilldownData = null;
if (selection != null && selection.length > 0) {
    var metas = selection[0]["_meta_"];
    if (metas != null) {
        var meta = metas.split(";");
        for (var i=0; i<meta.length; i++) {
            var directive = (meta[i]).split(":");
            if (directive.length == 2) {
                switch (directive[0]) {
                    case "drilldown-type":
                        drilldownType = directive[1];
                        break;
                    case "drilldown-name":
                        drilldownName = directive[1];
                        break;
                    case "drilldown-label":
                        drilldownLabel = directive[1];
                        break;
                    case "drilldown-view":
                        drilldownView = directive[1];
                        break;
                    case "drilldown-model":
                        drilldownModel = directive[1];
                        break;
                }
            }
        }
    }
    drilldownData = this.ddGetData(selection);
}
return {
    type  : drilldownType,
    name  : drilldownName,
    label : drilldownLabel,
    view  : drilldownView,
    model : drilldownModel,
    data  : drilldownData,
};
]]>
        </CodeText>
      </Function>
      <Function name="ddGetModel" args="config,info" private="false">
        <CodeText>
          <![CDATA[if (info.type != null) {
    config = config[info.type];
}
if (info.name != null && info.name != "" && config["model["+info.name+"]"] != null) {
    return config["model["+info.name+"]"];
}
return config["model"];
]]>
        </CodeText>
      </Function>
      <Function name="ddGetNotify" args="config,info" private="false">
        <CodeText>
          <![CDATA[var title = info.label;
if (title == null || title == "") {
    title = this.ddGetTitle(config, info) || info.name;
}
var evt = {};
if (title != null && title != "") {
    evt.page = {
        title : {
            text : title
        }
    };
}
if (info.model != null) {
    evt.axflow = {
        "change-nested-component" : true,
    };
    evt.widget = {
        path : info.model
    };
}
return evt;]]>
        </CodeText>
      </Function>
      <Function name="ddGetService" args="config,info" private="false">
        <CodeText>
          <![CDATA[if (info.type != null) {
    config = config[info.type];
}
if (info.name != null && info.name != "" && config["service["+info.name+"]"] != null) {
    return config["service["+info.name+"]"];
}
return config["service"];
]]>
        </CodeText>
      </Function>
      <Function name="ddGetTitle" args="config,info" private="false">
        <CodeText>
          <![CDATA[if (info.type != null) {
    config = config[info.type];
}
if (info.name != null && info.name != "" && config["title["+info.name+"]"] != null) {
    return config["title["+info.name+"]"];
}
return config["title"];
]]>
        </CodeText>
      </Function>
      <Function name="enrichSelection" args="selection,config" private="false">
        <CodeText>
          <![CDATA[var changed = false;
config._labels = {};
for (var i=0; i<selection.length; i++) {
    var item = selection[i];
    if (config.attributes != null) {
        for (var j=0; j<config.attributes.length; j++) {
            var attr = "_attr" + this.padLeftWith(j, 2, "0") + "_";
            item[attr] = item[config.attributes[j][0]];
            config._labels[attr] = config.attributes[j][1];
            changed = true;
        }
    }
    if (config.metrics != null) {
        for (var k=0; k<config.metrics.length; k++) {
            var metric = "_metric" + this.padLeftWith(k, 2, "0") + "_";
            item[metric] = item[config.metrics[k][0]];
            config._labels[metric] = config.metrics[k][1];
            changed = true;
        }
    }
}
return changed;]]>
        </CodeText>
      </Function>
      <Function name="getCustomGridStyle" args="config" private="false">
        <CodeText>
          <![CDATA[var MAX_ATTR_COLS = 50;
var MAX_METRIC_COLS = 50;
var attrs = config != null ? config.attributes : null;
var metrics = config != null ? config.metrics : null;
var evt = null;
if ((attrs != null && attrs.length > 0) || (metrics != null && metrics.length > 0)) {
    evt = {
        tile : {
        },
        grid : {
            labels : {},
            displays : {},
        }
    };
}
if (attrs != null && attrs.length > 0) {
    for (var i=0; i<MAX_ATTR_COLS; i++) {
        var field = "_attr"+this.padLeftWith(i,2,"0")+"_";
        evt.grid.displays[field] = false;
    }
    for (var i=0; i<attrs.length; i++) {
        var attr = attrs[i];
        var field = "_attr"+this.padLeftWith(i,2,"0")+"_";
        if (attr.highLightSetting != null) {
            var settings = lang.clone(attr.highLightSetting);
            if (evt.grid.highLightSetting == null) {
                evt.grid.highLightSetting = settings;
            }
            else {
                array.forEach(settings, function(item) {
                    evt.grid.highLightSetting.push(item);
                });
            }
        }
        if (attr.columnSetting != null) {
            if (evt.grid.columnSetting == null) {
                evt.grid.columnSetting = {};
            }
            evt.grid.columnSetting[field] = lang.clone(attr.columnSetting);
        }
        evt.grid.labels[field] = attr.label;
        evt.grid.displays[field] = true;
    }
}
if (metrics != null && metrics.length > 0) {
    for (var i=0; i<MAX_METRIC_COLS; i++) {
        var field = "_metric"+this.padLeftWith(i,2,"0")+"_";
        evt.grid.displays[field] = false;
    }
    for (var i=0; i<metrics.length; i++) {
        var metric = metrics[i];
        var field = "_metric"+this.padLeftWith(i,2,"0")+"_";
        if (metric.highLightSetting != null) {
            var settings = lang.clone(attr.highLightSetting);
            if (evt.grid.highLightSetting == null) {
                evt.grid.highLightSetting = settings;
            }
            else {
                array.forEach(settings, function(item) {
                    evt.grid.highLightSetting.push(item);
                });
            }
        }
        if (metric.columnSetting != null) {
            if (evt.grid.columnSetting == null) {
                evt.grid.columnSetting = {};
            }
            evt.grid.columnSetting[field] = lang.clone(metric.columnSetting);
        }
        evt.grid.labels[field] = metric.label;
        evt.grid.displays[field] = true;
    }
}
return evt;
]]>
        </CodeText>
      </Function>
      <Function name="getLocalData" args="name,defaultValue" private="false">
        <CodeText>
          <![CDATA[var scope = this.getUserName();
var path = scope + ".data."+ name;
if (path != null) {
    var dataName = encodeURIComponent(path);
    var value = null;
    if (window.localStorage) {
        value = window.localStorage.getItem(dataName);
    } else {
        value = cookie(dataName);
    }
    if (value != null) {
        value = decodeURIComponent(value);
        if (value == "[object Object]") {
            return defaultValue;
        }
        value = JSON.parse(value);
    } else {
        value = defaultValue;
    }
    return value;
}
return defaultValue;
]]>
        </CodeText>
      </Function>
      <Function name="getLocaleDateTime" args="epoch,locale,tz,interval,range" private="false">
        <CodeText>
          <![CDATA[function setFormatOption(option, interval, seconds) {
    switch (interval) {
        case "T15M":
            option["timeZoneName"] = "short";
            option["hour"] = "numeric";
            option["minute"] = "numeric";
            if (seconds >= (24*60*60)) {
                // if more than 24 hours, we need to add month/day
                option["month"] = "short";
                option["day"] = "numeric";
            }
            break;
        case "T1H":
            option["timeZoneName"] = "short";
            option["hour"] = "numeric";
            option["minute"] = "numeric";
            if (seconds >= (24*60*60)) {
                // if more than 24 hours, we need to add month/day
                option["month"] = "short";
                option["day"] = "numeric";
            }
            break;
        case "T8H":
            option["timeZoneName"] = "short";
            option["month"] = "short";
            option["day"] = "numeric";
            option["hour"] = "numeric";
            option["minute"] = "numeric";
            break;
        case "T1D":
            option["month"] = "short";
            option["day"] = "numeric";
            break;
    }
}
var date = new Date(epoch*1000);
var option = {
    "hour12" : true,
    "timeZone" : tz,
};
setFormatOption(option, interval, range);
return date.toLocaleString(locale, option);
]]>
        </CodeText>
      </Function>
      <Function name="getUserFullName" args="" private="false">
        <CodeText>
          <![CDATA[if (window.af != null && window.af.utils != null && window.af.utils.AppFrame != null) {
    var userName = window.af.utils.AppFrame.getUserFullName(false);
    if (userName != null) return userName;
}
return this.getUserName();

]]>
        </CodeText>
      </Function>
      <Function name="getUserName" args="" private="false">
        <CodeText>
          <![CDATA[if (window.af != null && window.af.utils != null && window.af.utils.AppFrame != null) {
    var userId = window.af.utils.AppFrame.getUserName();
    if (userId != null) return userId;
}
return "anonymous";
]]>
        </CodeText>
      </Function>
      <Function name="httpGetAndParseCSV" args="url,callback" private="false">
        <CodeText>
          <![CDATA[if (d3 != null) {
    d3.csv(url, function(rows) {
        callback(rows);
    });
}
else {
    callback(null);
}
]]>
        </CodeText>
      </Function>
      <Function name="hvGetConfig" args="config,info" private="false">
        <CodeText>
          <![CDATA[if (info.type != null) {
    config = config[info.type];
}
if (config["config["+info.view+"]["+info.name+"]"] != null) {
    return config["config["+info.view+"]["+info.name+"]"];
}
if (config["config["+info.name+"]"] != null) {
    return config["config["+info.name+"]"];
}
if (config["config["+info.view+"]"] != null) {
    return config["config["+info.view+"]"];
}
return config["config"];
]]>
        </CodeText>
      </Function>
      <Function name="hvGetData" args="selection" private="false">
        <CodeText>
          <![CDATA[var hoverItems = {};
var hoverData = [];
for (var i=0; i<selection.length; i++) {
    for (var name in selection[i]) {
        if (name == "_vtid" || name == "__userClick" || name == "__ITEM__") {
            // ignore
        }
        else {
            var item = hoverItems[name];
            if (item == null) {
                item = {
                    _name_ : name
                };
                hoverItems[name] = item;
                hoverData.push(item);
            }
            item["_value"+i+"_"] = selection[i][name];
        }
    }
}
hoverData.sort(function(a,b) {
    return a._name_.localeCompare(b._name_);
});
return hoverData;
]]>
        </CodeText>
      </Function>
      <Function name="hvGetInfo" args="selection" private="false">
        <CodeText>
          <![CDATA[var hoverType = null;
var hoverName = null;
var hoverLabel = null;
var hoverModel = null;
var hoverStyle = null;
var hoverWidth = null;
var hoverHeight = null;
var hoverData = null;
if (selection != null && selection.length > 0) {
    var metas = selection[0]["_meta_"];
    if (metas != null) {
        var meta = metas.split(";");
        for (var i=0; i<meta.length; i++) {
            var directive = (meta[i]).split(":");
            if (directive.length == 2) {
                switch (directive[0]) {
                    case "hover-type":
                        hoverType = directive[1];
                        break;
                    case "hover-name":
                        hoverName = directive[1];
                        break;
                    case "hover-label":
                        hoverLabel = directive[1];
                        break;
                    case "hover-model":
                        hoverModel = directive[1];
                        break;
                    case "hover-style":
                        hoverStyle = directive[1];
                        break;
                    case "hover-width":
                        hoverWidth = directive[1];
                        break;
                    case "hover-height":
                        hoverHeight = directive[1];
                        break;
                }
            }
        }
    }
    hoverData = this.hvGetData(selection);
}
return {
    type   : hoverType,
    name   : hoverName,
    label  : hoverLabel,
    model  : hoverModel,
    style  : hoverStyle,
    width  : hoverWidth,
    height : hoverHeight,
    data   : hoverData,
};
]]>
        </CodeText>
      </Function>
      <Function name="hvGetModel" args="config,info" private="false">
        <CodeText>
          <![CDATA[if (info.type != null) {
    config = config[info.type];
}
if (info.name != null && info.name != "" && config["model["+info.name+"]"] != null) {
    return config["model["+info.name+"]"];
}
return config["model"];
]]>
        </CodeText>
      </Function>
      <Function name="hvGetNotify" args="config,info" private="false">
        <CodeText>
          <![CDATA[var title = info.label;
if (title == null || title == "") {
    title = this.hvGetTitle(config, info) || info.name;
}
var evt = {};
if (title != null && title != "") {
    evt.page = {
        title : {
            text : title
        }
    };
}
if (info.model != null) {
    evt.axflow = {
        "change-nested-component" : true,
    };
    evt.widget = {
        path : info.model
    };
}
return evt;]]>
        </CodeText>
      </Function>
      <Function name="hvGetService" args="config,info" private="false">
        <CodeText>
          <![CDATA[if (info.type != null) {
    config = config[info.type];
}
if (info.name != null && info.name != "" && config["service["+info.name+"]"] != null) {
    return config["service["+info.name+"]"];
}
return config["service"];
]]>
        </CodeText>
      </Function>
      <Function name="hvGetTitle" args="config,info" private="false">
        <CodeText>
          <![CDATA[if (info.type != null) {
    config = config[info.type];
}
if (info.name != null && info.name != "" && config["title["+info.name+"]"] != null) {
    return config["title["+info.name+"]"];
}
return config["title"];
]]>
        </CodeText>
      </Function>
      <Function name="invokeDrilldownView" args="config,selection,filters,drilldownType,drilldownName,callback" private="false">
        <CodeText>
          <![CDATA[var self = this;
var info = this.ddGetInfo(selection);
if (drilldownType != null) info.type = drilldownType;
if (drilldownName != null) info.name = drilldownName;
this.invokeService(config["drilldown-config"], null, null, function(response) {
    if (response.status == "OK") {
        var drilldownConfig = response.value;
        if (info.type != null && drilldownConfig[info.type] != null) {
            var ddConfig = self.ddGetConfig(drilldownConfig, info);
            if (self.enrichSelection(selection, ddConfig)) {
                // if selection changed, we need to re-extract info.data
                info.data = self.ddGetData(selection);
            }
            if (info.type == "custom") {
                if (info.model == null) {
                    info.model = self.ddGetModel(drilldownConfig, info);
                }
                callback({
                    info   : info,
                    notify : self.ddGetNotify(drilldownConfig, info),
                    data   : info.data,
                    config : ddConfig,
                });
            }
            else {
                var service = self.ddGetService(drilldownConfig, info);
                if (service != null) {
                    var headers = {
                        data    : JSON.stringify(info.data),
                        filters : JSON.stringify(filters)
                    };
                    self.invokeService(service, null, headers, function(response) {
                        if (response.status == "OK") {
                            switch (info.type) {
                                case "list":
                                    callback({
                                        info   : info,
                                        notify : self.getCustomGridStyle(ddConfig),
                                        data   : response.value,
                                    });
                                    break;
                                case "summary":
                                case "trend":
                                case "geo":
                                    callback({
                                        info   : info,
                                        notify : ddConfig,
                                        data   : response.value,
                                    });
                                    break;
                            }
                        }
                    });
                }
            }
        }
    }
});
]]>
        </CodeText>
      </Function>
      <Function name="invokeHoverView" args="config,selection,filters,hoverType,hoverName,callback" private="false">
        <CodeText>
          <![CDATA[var self = this;
var info = this.hvGetInfo(selection);
if (hoverType != null) info.type = hoverType;
if (hoverName != null) info.name = hoverName;
this.invokeService(config["hover-config"], null, null, function(response) {
    if (response.status == "OK") {
        var hoverConfig = response.value;
        if (info.type != null && hoverConfig[info.type] != null) {
            var hvConfig = self.hvGetConfig(hoverConfig, info);
            if (self.enrichSelection(selection, hvConfig)) {
                // if selection changed, we need to re-extract info.data
                info.data = self.hvGetData(selection);
            }
            if (info.type == "custom") {
                if (info.model == null) {
                    info.model = self.hvGetModel(hoverConfig, info);
                }
                callback({
                    info   : info,
                    notify : self.hvGetNotify(hoverConfig, info),
                    data   : info.data,
                    config : hvConfig,
                });
            }
            else if (hoverConfig[info.type]["service"] != null) {
                var headers = {
                    data    : JSON.stringify(info.data),
                    filters : JSON.stringify(filters)
                };
                // not yet implemented
                callback({
                    info   : info,
                });
            }
        }
    }
});
]]>
        </CodeText>
      </Function>
      <Function name="invokeService" args="service,params,headers,callback,busy,refId" private="false">
        <CodeText>
          <![CDATA[function handleResponse(t)
{
    if (t != null && t != "") {
        var response = JSON.parse(t);
        if (response.status == null && response.value == null) {
            // not a DBP service response... fake it
            response = {
                status : "OK",
                value  : response
            };
        }
        callback(response);
    }
    else {
        callback({
            status : "Error",
            error  : "Service '" + service.url + "' not reachable or not implemented."
        });
    }
}

if (service == null || service.url == null || service.method == null) {
    callback({
        status : "Error",
        error  : "Service definition not defined or incomplete."
    });
}
else {
    switch (service.method) {
        case "GET":
            params = lang.mixin(lang.clone(service.params || {}), params || {});
            if (service["cancel-url"] != null && refId != null) {
                params["vtServiceRefId"] = String(refId);
            }
            GET("/vitria-oi/rest"+service.url, params, handleResponse, busy);
            break;
        case "POST":
            params = lang.mixin(lang.clone(service.params || {}), params || {});
            headers = lang.mixin(lang.clone(service.headers || {}), headers || {});
            if (service["cancel-url"] != null && refId != null) {
                params["vtServiceRefId"] = String(refId);
            }
            POST("/vitria-oi/rest"+service.url, params, headers, handleResponse, busy);
            break;
    }
}
]]>
        </CodeText>
      </Function>
      <Function name="loadLocaleResources" args="namespace,locales,callback" private="false">
        <CodeText>
          <![CDATA[if (locales.length == 0) {
    callback();
}
else {
    var locale = locales.shift();
    var self = this;
    this.__loadPluginLocale(locale.url, namespace, locale.code, function() {
        self.loadLocaleResources(namespace, locales, callback);
    });
}
]]>
        </CodeText>
      </Function>
      <Function name="localize" args="namespace,languageCode,str" private="false">
        <CodeText>
          <![CDATA[var isNotString = false;
if (typeof str != "string") {
    isNotString = true;
    str = JSON.stringify(str);
}
var start = str.indexOf("{i18n::");
while (start != -1) {
    var end = str.indexOf("}", start);
    if (end != -1) {
        var i18nKey = str.substring(start+"{i18n::".length, end);
        str = str.substring(0, start) + this.__getLocaleString(namespace, languageCode, i18nKey, i18nKey) + str.substring(end+1);
        start = str.indexOf("{i18n::", start);
    }
    else {
        start = -1;
    }
}
return isNotString ? JSON.parse(str) : str;
]]>
        </CodeText>
      </Function>
      <Function name="makeFormBooleanItem" args="name,label" private="false">
        <CodeText>
          <![CDATA[return {
    name   : name,
    label  : label,
    type   : "boolean",
    config : {
	    labelStyle : "padding-left:10px;text-align:right;",
        style : "width: calc( 100% - 30px ); padding-left: 20px;",
    }
};
]]>
        </CodeText>
      </Function>
      <Function name="makeFormChoiceItem" args="name,label,options" private="false">
        <CodeText>
          <![CDATA[for (var i=0; i<options.length; i++) {
    if (typeof options[i] == "string") {
        var eq = (options[i]).indexOf("=");
        if (eq == -1) {
            options[i] = {
                value : options[i],
                label : options[i]
            };
        }
        else {
            options[i] = {
                value : (options[i]).substring(0, eq),
                label : (options[i]).substring(eq+1)
            };
        }
    }
}
return {
    name   : name,
    label  : label,
    type   : "string",
    config : {
	    labelStyle : "padding-left:10px;text-align:right;",
        style      : "font-weight:bold;width: calc( 100% - 30px ); max-width: 450px;",
        choices    : options,
    }
};
]]>
        </CodeText>
      </Function>
      <Function name="makeFormEnumeratedItem" args="name,label,options" private="false">
        <CodeText>
          <![CDATA[for (var i=0; i<options.length; i++) {
    if (typeof options[i] == "string") {
        var eq = (options[i]).indexOf("=");
        if (eq == -1) {
            options[i] = {
                value : options[i],
                label : options[i]
            };
        }
        else {
            options[i] = {
                value : (options[i]).substring(0, eq),
                label : (options[i]).substring(eq+1)
            };
        }
    }
}
return {
    name   : name,
    label  : label,
    type   : "string",
    config : {
	    labelStyle : "padding-left:10px;text-align:right;",
        style : "font-weight:bold;width: calc( 100% - 30px ); max-width: 450px;",
        enums : options,
    }
};
]]>
        </CodeText>
      </Function>
      <Function name="makeFormIntegerItem" args="name,label,min,max,inc" private="false">
        <CodeText>
          <![CDATA[return {
	name   : name,
	label  : label,
	type   : "integer",
	config : {
	    labelStyle : "padding-left:10px;text-align:right;",
		style : "font-weight:bold; width: calc( 100% - 30px ); max-width: 450px;",
		min   : min,
		max   : max,
		inc   : inc,
	}
};
]]>
        </CodeText>
      </Function>
      <Function name="makeFormLabelItem" args="name,label" private="false">
        <CodeText>
          <![CDATA[return {
	name   : name,
	label  : label,
	type   : "section",
	config : {
	    labelStyle : "padding-left:10px;text-align:left;color:#148ac4;font-weight:normal;font-style:italic;white-space:normal;",
		style : "width:20px;display:none;",
	}
};
]]>
        </CodeText>
      </Function>
      <Function name="makeFormNumberItem" args="name,label,constraints" private="false">
        <CodeText>
          <![CDATA[return {
	name   : name,
	label  : label,
	type   : "number",
	config : {
	    labelStyle : "padding-left:10px;text-align:right;",
		style : "font-weight:bold; width: calc( 100% - 30px ); max-width: 450px;",
		constraints : constraints,
	}
};
]]>
        </CodeText>
      </Function>
      <Function name="makeFormSectionItem" args="name,label" private="false">
        <CodeText>
          <![CDATA[return {
	name   : name,
	label  : label,
	type   : "section",
	config : {
	    labelStyle : "padding-left:10px;padding-top:10px;text-align:left;color:#148ac4;font-size:16px;font-weight:bold;font-style:normal;",
	}
};
]]>
        </CodeText>
      </Function>
      <Function name="makeFormSpacerItem" args="" private="false">
        <CodeText>
          <![CDATA[return {
	name   : "spacer_" + Math.round( Math.random() + 99999999 ),
	label  : "",
	type   : "label",
	config : {
		style : "font-weight:bold;width:10px;display: none;",
	}
};
]]>
        </CodeText>
      </Function>
      <Function name="makeFormStringItem" args="name,label" private="false">
        <CodeText>
          <![CDATA[return {
    name   : name,
    label  : label,
    type   : "string",
    config : {
	    labelStyle : "padding-left:10px;text-align:right;",
        style : "font-weight:bold;width: calc( 100% - 30px ); max-width: 450px;",
    }
};
]]>
        </CodeText>
      </Function>
      <Function name="makeFormTextItem" args="name,label" private="false">
        <CodeText>
          <![CDATA[return {
    name   : name,
    label  : label,
    type   : "string",
    config : {
	    labelStyle : "padding-left:10px;text-align:right;",
        style : "font-weight:bold;width: calc( 100% - 30px ); max-width: 450px; height: 80px;",
        multiline : true,
    }
};
]]>
        </CodeText>
      </Function>
      <Function name="mixinDeep" args="dest,source" private="false">
        <CodeText>
          <![CDATA[// Recursively mix the properties of two objects
dest = dest || {};
source = source || {};

var empty = {};
for (var name in source) {
    if(!(name in dest) || (dest[name] !== source[name] && (!(name in empty) || empty[name] !== source[name]))){
        try {
            if ( source[name].constructor==Object ) {
                 dest[name] = this.mixinDeep(dest[name], source[name]);
            } else {
                 dest[name] = source[name];
            };
        } catch(e) {
            // Property in destination object not set. Create it and set its value.
            dest[name] = source[name];
        };
    };
}
return dest;
]]>
        </CodeText>
      </Function>
      <Function name="padLeftWith" args="str,len,pad" private="false">
        <CodeText>
          <![CDATA[if (typeof str != "string") {
    str = String(str);
}
while (str.length < len) {
    str = pad + str;
}
return str;
]]>
        </CodeText>
      </Function>
      <Function name="padRightWith" args="str,len,pad" private="false">
        <CodeText>
          <![CDATA[if (typeof str != "string") {
    str = String(str);
}
while (str.length < len) {
    str = str + pad;
}
return str;
]]>
        </CodeText>
      </Function>
      <Function name="pbHideBusyCursor" args="id" private="false">
        <CodeText>
          <![CDATA[require(["af/utils/Indicator", "dojo/domReady!"], function(Indicator) {
    Indicator.release({
        id : id
    });
});
]]>
        </CodeText>
      </Function>
      <Function name="pbHideProgressBar" args="id" private="false">
        <CodeText>
          <![CDATA[if (window.__PROGRESSBAR_DIALOG__ == null) return;

function removeProgressBar(self, progressbar)
{
    if (window.__PROGRESSBAR_DIALOG__ != null) {
        window.__PROGRESSBAR_DIALOG__._ContentDiv.removeChild(progressbar.messageDiv);
        progressbar.progressBar.destroy();
        window.__PROGRESSBAR_DIALOG__.resize();
        
        if (JSON.stringify(window.__PROGRESSBAR_DIALOG__._ProgressBars) == "{}") {
            window.__PROGRESSBAR_DIALOG__.hide();
            delete window.__PROGRESSBAR_DIALOG__;
        }
    }
}

var progressbar = window.__PROGRESSBAR_DIALOG__._ProgressBars[id];
if (progressbar != null) {
    delete window.__PROGRESSBAR_DIALOG__._ProgressBars[id];
    var elapsed = Date.now() - progressbar.timestamp;
    var delay = (1*1000) - elapsed;
    if (delay > 0) {
        console.debug("remove progressbar in " + delay + " ms");
        var self = this;
        window.setTimeout(function() {
            removeProgressBar(self, progressbar);
        }, delay);
    }
    else {
        removeProgressBar(this, progressbar);
    }
}
else {
    console.warn("Cannot close remove dialog '" + id + "'. Not found.");
}
]]>
        </CodeText>
      </Function>
      <Function name="pbShowBusyCursor" args="id,label" private="false">
        <CodeText>
          <![CDATA[require(["af/utils/Indicator", "dojo/domReady!"], function(Indicator) {
    return Indicator.busy({
        id    : id,
        label : label,
    }, null, true);
});
]]>
        </CodeText>
      </Function>
      <Function name="pbShowProgressBar" args="id,message,onCancelCallback" private="false">
        <CodeText>
          <![CDATA[if (window.__PROGRESSBAR_DIALOG__ != null && window.__PROGRESSBAR_DIALOG__._ProgressBars[id] != null) {
    console.warn("Progress dialog: " + id + " already opened. Ignore call.");
    return;
}
var self = this;
require(["dijit/Dialog",
         "dijit/ProgressBar",
         "dojox/uuid/generateRandomUuid",
         "dojo/dom-construct", 
         "dojo/domReady!"],
         function(Dialog, ProgressBar, generatedRandomUuid, domConstruct) {
             
    if (id == null) {
        id = generateRandomUuid();
    }

    var show = false;
    var dialog = window.__PROGRESSBAR_DIALOG__;
    if (dialog == null) {
        dialog = new Dialog({
            style:"width:400px;",
            onCancel:function() {
                // user cancelled by clicking on [x]
                for (var pid in window.__PROGRESSBAR_DIALOG__._ProgressBars) {
                    var progressbar = window.__PROGRESSBAR_DIALOG__._ProgressBars[pid];
                    if (progressbar.onCancelCallback != null) {
                        progressbar.onCancelCallback();
                    }
                }
                delete window.__PROGRESSBAR_DIALOG__;
            },
        });
        window.__PROGRESSBAR_DIALOG__ = dialog;

        var contentDiv = domConstruct.create("div", {
            style : "width:100%;"
        });
        dialog.setContent(contentDiv);
        dialog._ContentDiv = contentDiv;
        dialog._ProgressBars = {};
        
        show = true;
    }
    
    var messageDiv = domConstruct.create("div", {
        style : "width:100%;padding:5px;white-space:normal;"
    });
    messageDiv.innerHTML = message;
    dialog._ContentDiv.appendChild(messageDiv);
    var progressDiv = domConstruct.create("div", {
        style : "width:100%;padding:5px;"
    });
    dialog._ContentDiv.appendChild(progressDiv);
    var progressBar = new ProgressBar({ 
        indeterminate : true,
        layoutAlign: "left",
    }, progressDiv);
    
    dialog._ProgressBars[id] = {
        messageDiv : messageDiv,
        progressBar : progressBar,
        onCancelCallback : onCancelCallback,
        timestamp : Date.now(),
    };
    
    if (show) {
        dialog.show();
    }
    else {
        dialog.resize();
    }
});
]]>
        </CodeText>
      </Function>
      <Function name="popupDialog" args="title,width,height,maximizable,callback,okCallback,okLabel" private="false">
        <CodeText>
          <![CDATA[require(["af/controls/MaximizableAppDialog",
         "af/controls/ButtonMode",
         "af/utils/I18N",
         "dojo/dom-geometry",
         "dojo/dom-style",
         "dojo/dom-class",
         "dojo/dom-attr",
         "dojo/dom-construct",
         "dojo/on",
         "dojo/domReady!"],
function(MaximizableAppDialog, ButtonMode, I18N, domGeom, domStyle, domClass, domAttr, domConstruct, on) {
    var dialog = new MaximizableAppDialog({
        title    : title,
        vtWidth  : width,
        vtHeight : height,
    });
    dialog.showTitle = title != null;
    if (okCallback == null) {
        dialog.buttonMode = ButtonMode.YES;
        dialog.set("okLabel", okLabel || I18N.getString("af.frame", "Close"));
        dialog.setOkButtonEnable(true);
        dialog.okHandler = function() {
            this.hide();
        };
    }
    else {
        if (okLabel != null) {
            dialog.set("okLabel", okLabel);
        }
        dialog.okHandler = function() {
            this.hide();
            okCallback(this.value);
        };
    }
    dialog.show();
    domStyle.set(dialog.containerNode, {
        "width"    : "100%",
        "height"   : "100%",
        "overflow" : "hidden"
    });
    if (!maximizable) {
        domStyle.set(dialog.resizeBtn, "display", "none");
    }
    callback(dialog, domGeom, domStyle, domClass, domAttr, domConstruct, on);
});
]]>
        </CodeText>
      </Function>
      <Function name="popupDialogForm" args="title,width,height,value,formDef,callback" private="false">
        <CodeText>
          <![CDATA[require(["af/controls/PopupEditorDialog",
         "ax/flow/impl/editors/FormDialog",
         "dojo/dom-geometry",
         "dojo/dom-style",
         "dojo/dom-class",
         "dojo/dom-attr",
         "dojo/dom-construct",
         "dojo/domReady!"],
function(PopupDialogClazz, PopupDialogWidget, domGeom, domStyle, domClass, domAttr, domConstruct) {
    var dialog = new PopupDialogClazz({
        title    : title,
        vtWidth  : width,
        vtHeight : height,
        model    : value,
        editorClass : PopupDialogWidget,
        editorConfig : {
            form : formDef
        },
        onClickOk : callback
    });
    domStyle.set(dialog._widget.modelTd.domNode, "overflow", "hidden");
    domClass.add(dialog._widget.editorTitleLabel, "popup-title-label");
    domStyle.set(dialog._widget.editorTitleLabel, {
        "display"     : "none",
        "height"      : "0px",
        "line-height" : "0px"
    });
    domClass.add(dialog.domNode, "popup-dialog");
    dialog.show();
});
]]>
        </CodeText>
      </Function>
      <Function name="popupEditForm" args="controller,record,title,width,height,description,items,buttonDefs,callback,options" private="false">
        <CodeText>
          <![CDATA[var self = this;
var existingValues = [];
items.forEach(function(item) {
    var itemName = item.name;
    var itemType = item.type;
    switch (itemType) {
        case "number":
        case "integer":
            var itemValue = record[item.name];
            if (itemValue != null) {
                itemValue = Number(itemValue);
            }
            if (itemValue == null || isNaN(itemValue)) {
                itemValue = 0;
            }
            break;
        case "boolean":
            var itemValue = record[item.name];
            if (itemValue != null) {
                itemValue = itemValue == true || itemValue == "true";
            }
            if (itemValue == null) {
                itemValue = false;
            }
            break;
        case "percent":
            var itemValue = record[item.name];
            if (itemValue != null) {
                itemValue = Number(itemValue);
            }
            if (itemValue == null || isNaN(itemValue)) {
                itemValue = 0;
            }
            itemValue = Number((itemValue*100).toFixed(0));
            break;
        case "string":
        case "text":
            var itemValue = record[item.name];
            if (itemValue == null) {
                itemValue = "";
            }
            break;
        case "enumeration":
            var itemValue = record[item.name];
            if (itemValue == null) {
                itemValue = "";
            }
            break;
        case "choice":
            var itemValue = record[item.name];
            if (itemValue == null) {
                itemValue = [];
            }
            break;
    }
    existingValues.push({
        name  : itemName,
        value : itemValue,
    });
});
var formDefs = {
    title : description.join(""),
    items : [],
};
items.forEach(function(item) {
    var itemName  = item.name;
    var itemType  = item.type;
    var formItem  = null;
    switch (itemType) {
        case "section":
            formItem = self.makeFormSectionItem(itemName, item.label);
            break;
        case "label":
            formItem = self.makeFormLabelItem(itemName, item.text.join("<br>"));
            break;
        case "number":
            formItem = self.makeFormNumberItem(itemName, item.label, {});
            break;
        case "integer":
            formItem = self.makeFormIntegerItem(itemName, item.label, item.min || 0, item.max || 1000000, item.inc || 10);
            break;
        case "boolean":
            formItem = self.makeFormBooleanItem(itemName, item.label);
            break;
        case "percent":
            formItem = self.makeFormIntegerItem(itemName, item.label, item.min || 0, item.max || 1000000, item.inc || 10);
            break;
        case "string":
            formItem = self.makeFormStringItem(itemName, item.label);
            break;
        case "text":
            formItem = self.makeFormTextItem(itemName, item.label);
            break;
        case "enumeration":
            formItem = self.makeFormEnumeratedItem(itemName, item.label, item.enums);
            break;
        case "choice":
            formItem = self.makeFormChoiceItem(itemName, item.label, item.enums);
            break;
    }
    if (formItem != null) {
        if (item.config != null) {
            if (formItem.config == null) formItem.config = {};
            for (var key in item.config) {
                formItem.config[key] = item.config[key];
            }
        }
        if (item.required == true) {
            formItem.required = true;
        }
        if (record[itemName+"$disabled"] == true) {
            formItem.disabled = true;
        }
        formItem._itemDef = item;
        formDefs.items.push(formItem);
    }
});
if (width == null) width = 700;
if (height == null) height = 500;
self.popupFormWidget(controller, title, width+"px", height+"px", existingValues, formDefs, function(values) {
    if (values != null) {
        var obj = {};
        for (var key in record) {
            if (key.indexOf("$disabled") == -1) {
                obj[key] = record[key];
            }
        }
        for (var i=0; i<values.length; i++) {
            if (values[i]["value"] != null) {
                obj[values[i]["name"]] = values[i]["value"];
            }
        }
        items.forEach(function(item) {
            var itemName = item.name;
            var itemType = item.type;
            switch (itemType) {
                case "percent":
                    if (obj[itemName] != null) {
                        var pct = Number(obj[itemName]);
                        if (!isNaN(pct)) {
                            obj[itemName] = pct/100;
                        }
                        else {
                            obj[itemName] = 0;
                        }
                    }
                    break;
            }
        });
        callback(obj);
    }
}, buttonDefs, options);
]]>
        </CodeText>
      </Function>
      <Function name="popupFormWidget" args="controller,title,width,height,value,formDef,callback,buttonDefs,options" private="false">
        <CodeText>
          <![CDATA[var PATH = this["$uri"];
var NAME = "Form Widget";
require(["af/controls/PopupEditorDialog",
         "af/utils/AppUtil",
         "af/utils/RestRequest",
         "dbp/utils/ClientUtil",
         "dojox/xml/parser",
         "dojo/on",
         "dojo/dom-geometry",
         "dojo/dom-style",
         "dojo/dom-class",
         "dojo/dom-attr",
         "dojo/dom-construct",
         "dojo/domReady!"],
function(PopupDialogClazz, AppUtil, RestRequest, ClientUtil, XmlParser, on, domGeom, domStyle, domClass, domAttr, domConstruct) {
    function doGetModel(path, callback)
    {
        RestRequest.json({
            url       : AppUtil.getItemURL(path),
            method    : "get",
            parameter : null,
            header    : null,
            callback  : function(t) {
                var doc = XmlParser.parse(t);
                var xml = doc.documentElement;
                callback(xml);
            },
        });
    }
    function insertButton(parentNode, label, tooltip)
    {
        var button = domConstruct.create("button", {
            "type"  : "button",
            "class" : "popup-command-button",
            "title" : tooltip,
        });
        button.innerHTML = label;
        parentNode.insertBefore(button, parentNode.firstElementChild);
        return button;
    }
    doGetModel(PATH, function(xml) {
        var plugin = {};
        ClientUtil.decodeModel(plugin, xml);
        for (var i=0;i<plugin._widgets.length; i++) {
            var w = plugin._widgets[i];
			w.path = PATH;
            if (w.name == NAME) {
                var WidgetClass = ClientUtil.getWidgetClass(controller, w, plugin._widgets, plugin._resources);
                var dialog = new PopupDialogClazz({
                    title    : title,
                    vtWidth  : width,
                    vtHeight : height,
                    model    : value,
                    editorClass : WidgetClass,
                    editorConfig : {
                        controller : controller,
                        form       : formDef,
                        options    : options || {}
                    },
                    onClickOk : callback
                });
                domStyle.set(dialog._widget.modelTd.domNode, "overflow", "hidden");
                domClass.add(dialog._widget.editorTitleLabel, "popup-title-label");
                domStyle.set(dialog._widget.editorTitleLabel, {
                    "display"     : "none",
                    "height"      : "0px",
                    "line-height" : "0px"
                });
                domClass.add(dialog._dialog.domNode, "popup-dialog");
                dialog.show();
                if (buttonDefs != null) {
                    var footerDiv = dialog._dialog.buttonBarContainer;
                    buttonDefs.forEach(function(def) {
                        def.widget = insertButton(footerDiv, def.label, def.tooltip);
                        if (def.callback != null) {
                            on(def.widget, "click", function(evt) {
                                def.callback(formDef, evt);
                            });
                            def.disable = function(disable) {
                                if (disable) {
                                    domStyle.set(this.widget, {
                                        "pointer-events" : "none",
                                        "opacity" : 0.3,
                                        "cursor" : "not-allowed",
                                    });
                                }
                                else {
                                    domStyle.set(this.widget, {
                                        "pointer-events" : "auto",
                                        "opacity" : 1.0,
                                        "cursor" : "pointer",
                                    });
                                }
                            };
                        }
                        else {
                            domStyle.set(def.widget, {
                                "opacity" : 0.3,
                                "cursor" : "not-allowed",
                            });
                        }
                    });
                }
                break;
            }
        }
    });
});
]]>
        </CodeText>
      </Function>
      <Function name="setLocalData" args="name,value" private="false">
        <CodeText>
          <![CDATA[var scope = this.getUserName();
var path = scope + ".data."+ name;
if (path != null) {
    var cookieName = encodeURIComponent(path);
    if (value != null) {
        value = JSON.stringify(value);
        if (window.localStorage) {
            window.localStorage.setItem(cookieName, encodeURIComponent(value));
        } else {
            cookie(cookieName, encodeURIComponent(value), {expires: 30});
        }
    } else {
        if (window.localStorage) {
            window.localStorage.removeItem(cookieName);
        } else {
            cookie(cookieName, null, {expires: -1});
        }
    }
}
]]>
        </CodeText>
      </Function>
      <Function name="stripDisabledFormData" args="record" private="false">
        <CodeText>
          <![CDATA[var obj = {};
for (var key in record) {
    if (key.indexOf("$disabled") == -1) {
        if (record[key+"$disabled"] != true) {
            obj[key] = record[key];
        }
    }
}
return obj;
]]>
        </CodeText>
      </Function>
      <Function name="updateFormWidget" args="formDef,record" private="false">
        <CodeText>
          <![CDATA[record = lang.clone(record);
for (var i=0; i<formDef.items.length; i++) {
    var item = formDef.items[i];
    if (item.widget != null && record[item.name] != null) {
        if (item._itemDef != null && item._itemDef.type == "percent") {
            item.widget.set("value", 100*record[item.name]);
        }
        else {
            item.widget.set("value", record[item.name]);
        }
        delete record[item.name];
    }
}
for (var name in record) {
    if (formDef.values == null) formDef.values = {};
    formDef.values[name] = record[name];
}
]]>
        </CodeText>
      </Function>
      <Function name="uploadFile" args="mimeTypes,content,callback" private="false">
        <CodeText>
          <![CDATA[require(["af/controls/FileUploadHelper", "dojo/domReady!"], function(FileUploadHelper) {
    var helper = new FileUploadHelper();
    var widget = helper.getUploader({
        showLabel: false,
        autoWidth : true,
        label: "",
        "class": "clear-dijit-style",
        onChangeHandler: function(file) {
            // file = {"index":0,"name":"DatabaseResources-hello.zip","size":134330,"type":"application/x-zip-compressed","uploadType":"html5"}
            console.debug("onChangeHandler");
            window._vtUploadedFile = file;
        },
        uploadCompleteHandler: function(data) {
            // data = {uid:"743f8540-2991-478a-8e2d-45743c4a3a7a"}
            console.debug("uploadCompleteHandler");
            if (window._vtUploadedFile != null) {
                if (mimeTypes == null || mimeTypes == "" || mimeTypes.indexOf(window._vtUploadedFile.type) != -1) {
                    window._vtUploadedFile.uid = data.uid;
                    if (content == true) {
                        // grab file content... ascii ONLY
                        GET("/vitria-oi/rest/app/dojoclient/user/vtbaadmin/foo.txt", {op:"download", uid:data.uid}, function(t) {
                            window._vtUploadedFile.status = "OK";
                            window._vtUploadedFile.content = t;
                            callback(window._vtUploadedFile);
                            delete window._vtUploadedFile;
                        });
                    }
                    else {
                        window._vtUploadedFile.status = "OK";
                        callback(window._vtUploadedFile);
                        delete window._vtUploadedFile;
                    }
                }
                else {
                    window._vtUploadedFile.status = "ERROR";
                    window._vtUploadedFile.error = "Invalid import file format: " + window._vtUploadedFile.type;
                    console.error(window._vtUploadedFile.error);
                    callback(window._vtUploadedFile);
                    delete window._vtUploadedFile;
                }
            }
        }
    });
    widget.startup();
    widget.domNode.childNodes[0].click();
});
]]>
        </CodeText>
      </Function>
    </Functions>
    <Services>
      <Service name="fixupDependentPluginPath" args="modelPath" private="false">
        <CodeText>
          <![CDATA[var XmlUtil = com.vitria.util.XmlUtil;
var XmlList = com.vitria.util.XmlList;
var HashMap = java.util.HashMap;

var URI_PATTERNS = [
    { space : "/space/Charter Digital Operations", user : "/user/charter_admin" },
    { space : "/space/VIA Digital Operations", user : "/user/viaops_admin" },
    { space : "/space/VIA Common Library", user : "/user/via_common" },
];

var INDEXED_TYPES = [
    "text/plain",
    "text/css",
    "text/html",
    "text/csv",
    "application/javascript",
    "application/xml",
    "application/json",
    "application/sql"
];

function getProperties(rootElem, modelInfo)
{
    var uuids = [];
    var xl = modelInfo.elements("Resources").elements("Resource");
    for (var i=0, n=xl.size(); i<n; i++) {
        var el = xl.get(i);
        var type = el.getAttribute("type");
        var uuid = el.getAttribute("uuid");
        if (INDEXED_TYPES.indexOf(type) != -1) {
            uuids.push(uuid);
        }
    }
    var buf = [];
    buf.push("<properties>");
    buf.push('<property name="modelStatus" value="valid"/>');
    buf.push('<property name="_RESOURCE_Description" value="' + rootElem.getAttribute("description") + '"/>');
    if (uuids.length > 0) {
        buf.push('<property name="__indexed_contents__" value="' + uuids.join(",") + '"/>');
    }
    buf.push("</properties>");
    return buf.join("");
}

function patchPluginURI(modelInfo)
{
    var patched = [];
    var xl = modelInfo.elements("Plugins").elements("Plugin");
    for (var i=0, n=xl.size(); i<n; i++) {
        var el = xl.get(i);
        var oldPath = el.getAttribute("uri");
        for (var j=0; j<URI_PATTERNS.length; j++) {
            var pattern = URI_PATTERNS[j];
            var start = oldPath.indexOf(pattern.space);
            if (start != -1) {
                var newPath = oldPath.substring(0, start) + pattern.user + oldPath.substring(start+pattern.space.length);
                el.setAttribute("uri", newPath);
                patched.push(oldPath + " ==> " + el.getAttribute("uri"));
            }
        }
    }
    return patched;
}

function revertPluginURI(uri)
{
    var modelText = Context.GET(uri);
    if (modelText == null || modelText == "") {
        throw "Model '" + uri + "' not found";
    }
    var doc = XmlUtil.fromString(modelText);
    var rootElem = doc.getDocumentElement();
    var modelInfo = XmlList.create(rootElem).elements("ModelInfo");
    
    var patched = patchPluginURI(modelInfo);
    if (patched.length > 0) {
        var headers = new HashMap();
        headers.put("force", "true");
        headers.put("document", XmlUtil.toString(doc));
        headers.put("properties", getProperties(rootElem, modelInfo));
        Context.POST(uri + "?op=save", headers);
        print("Fixed Path: " + uri);
        patched.forEach(function(msg) {
            print("--- " + msg);
        });
    }
    else {
        print("Skipped Path: " + uri);
    }
    return {
        model   : uri,
        patched : patched,
    }
}

return revertPluginURI(modelPath);
]]>
        </CodeText>
      </Service>
      <Service name="forceSavePluginModel" args="modelPath" private="false">
        <CodeText>
          <![CDATA[var XmlUtil = com.vitria.util.XmlUtil;
var XmlList = com.vitria.util.XmlList;
var HashMap = java.util.HashMap;

var INDEXED_TYPES = [
    "text/plain",
    "text/css",
    "text/html",
    "text/csv",
    "application/javascript",
    "application/xml",
    "application/json",
    "application/sql"
];

function getProperties(rootElem, modelInfo)
{
    var uuids = [];
    var xl = modelInfo.elements("Resources").elements("Resource");
    for (var i=0, n=xl.size(); i<n; i++) {
        var el = xl.get(i);
        var type = el.getAttribute("type");
        var uuid = el.getAttribute("uuid");
        if (INDEXED_TYPES.indexOf(type) != -1) {
            uuids.push(uuid);
        }
    }
    var buf = [];
    buf.push("<properties>");
    buf.push('<property name="modelStatus" value="valid"/>');
    buf.push('<property name="_RESOURCE_Description" value="' + rootElem.getAttribute("description") + '"/>');
    if (uuids.length > 0) {
        buf.push('<property name="__indexed_contents__" value="' + uuids.join(",") + '"/>');
    }
    buf.push("</properties>");
    return buf.join("");
}

function forceSave(uri)
{
    var modelText = Context.GET(uri);
    if (modelText == null || modelText == "") {
        throw "Model '" + uri + "' not found";
    }
    else {
        var doc = XmlUtil.fromString(modelText);
        var rootElem = doc.getDocumentElement();
        var modelInfo = XmlList.create(rootElem).elements("ModelInfo");
        
        var headers = new HashMap();
        headers.put("force", "true");
        headers.put("document", XmlUtil.toString(doc));
        headers.put("properties", getProperties(rootElem, modelInfo));
        Context.POST(uri + "?op=save", headers);
        print("Saved: " + uri);
        return "Saved: " + uri;
    }
}

return forceSave(modelPath);
]]>
        </CodeText>
      </Service>
    </Services>
    <Resources>
      <Resource uuid="93f1e06c-9ecd-4dc5-8bb6-7d0d6f0276f4" name="FORM_WIDGET_SAMPLE" type="application/json" size="6014" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="052f78fb-b746-4910-8066-f5c46255930a" name="PROGRAMMATIC_HOVER_DRILLDOWN_META" type="application/javascript" size="0" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="b59aeef2-d3be-4d93-80e9-710da9872b35" name="SAMPLE_DRILLDOWN_CONFIG" type="application/javascript" size="0" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="5d99145b-d95d-4e6d-89e7-75fa1c648979" name="SAMPLE_HOVER_CONFIG" type="application/javascript" size="0" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
      <Resource uuid="293e216b-2a15-47c5-8632-760a5da7f0e3" name="VIA-CSS" type="text/css" size="4048" private="false">
        <Description>
          <![CDATA[]]>
        </Description>
      </Resource>
    </Resources>
    <Plugins>
    </Plugins>
  </ModelInfo>
</DashboardPluginModel>